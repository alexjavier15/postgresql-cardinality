From abee6a2fb34faaaf66d145a72de31614f0b4b112 Mon Sep 17 00:00:00 2001
From: JavierRivas <javieralejandro.rivas@epfl.ch>
Date: Tue, 3 Jun 2014 00:30:34 +0200
Subject: [PATCH] test

---
 contrib/auto_explain/auto_explain.c     |  301 ++--
 src/backend/optimizer/path/costsize.c   | 2269 +++++++++++------------
 src/backend/optimizer/path/indxpath.c   |   11 +-
 src/backend/optimizer/path/joinpath.c   |    8 +-
 src/backend/optimizer/path/joinrels.c   |    1 +
 src/backend/optimizer/plan/createplan.c | 2967 +++++++++++++------------------
 src/backend/optimizer/plan/planmain.c   |    2 +-
 src/backend/optimizer/plan/planner.c    |    9 +-
 src/backend/optimizer/util/pathnode.c   |   71 +
 src/backend/optimizer/util/plancat.c    |    2 +-
 src/backend/optimizer/util/relnode.c    |  454 +++--
 src/backend/utils/misc/guc.c            |   20 +-
 src/include/nodes/plannodes.h           |    2 +-
 src/include/nodes/relation.h            |  136 +-
 src/include/optimizer/cost.h            |    3 +
 src/include/optimizer/pathnode.h        |    2 +
 16 files changed, 2832 insertions(+), 3426 deletions(-)

diff --git a/contrib/auto_explain/auto_explain.c b/contrib/auto_explain/auto_explain.c
index c8ca7c4..de1b088 100644
--- a/contrib/auto_explain/auto_explain.c
+++ b/contrib/auto_explain/auto_explain.c
@@ -11,35 +11,33 @@
  *-------------------------------------------------------------------------
  */
 #include "postgres.h"
-
 #include <limits.h>
-
+#include <stdio.h>
+#include "optimizer/cost.h"
 #include "commands/explain.h"
 #include "executor/instrument.h"
 #include "utils/guc.h"
-
+#include "optimizer/cost.h"
 PG_MODULE_MAGIC;
 
 /* GUC variables */
-static int	auto_explain_log_min_duration = -1; /* msec or -1 */
+static int auto_explain_log_min_duration = 0; /* msec or -1 */
 static bool auto_explain_log_analyze = false;
+static bool auto_explain_log_memo = false;
 static bool auto_explain_log_verbose = false;
 static bool auto_explain_log_buffers = false;
 static bool auto_explain_log_triggers = false;
 static bool auto_explain_log_timing = false;
-static int	auto_explain_log_format = EXPLAIN_FORMAT_TEXT;
+static int auto_explain_log_format = EXPLAIN_FORMAT_TEXT;
 static bool auto_explain_log_nested_statements = false;
 
-static const struct config_enum_entry format_options[] = {
-	{"text", EXPLAIN_FORMAT_TEXT, false},
-	{"xml", EXPLAIN_FORMAT_XML, false},
-	{"json", EXPLAIN_FORMAT_JSON, false},
-	{"yaml", EXPLAIN_FORMAT_YAML, false},
-	{NULL, 0, false}
-};
+static const struct config_enum_entry format_options[] = { { "text",
+		EXPLAIN_FORMAT_TEXT, false }, { "xml", EXPLAIN_FORMAT_XML, false }, {
+		"json", EXPLAIN_FORMAT_JSON, false }, { "yaml", EXPLAIN_FORMAT_YAML,
+		false }, { NULL, 0, false } };
 
 /* Current nesting depth of ExecutorRun calls */
-static int	nesting_level = 0;
+static int nesting_level = 0;
 
 /* Saved hook values in case of unload */
 static ExecutorStart_hook_type prev_ExecutorStart = NULL;
@@ -51,157 +49,96 @@ static ExecutorEnd_hook_type prev_ExecutorEnd = NULL;
 	(auto_explain_log_min_duration >= 0 && \
 	 (nesting_level == 0 || auto_explain_log_nested_statements))
 
-void		_PG_init(void);
-void		_PG_fini(void);
+void _PG_init(void);
+void _PG_fini(void);
 
 static void explain_ExecutorStart(QueryDesc *queryDesc, int eflags);
-static void explain_ExecutorRun(QueryDesc *queryDesc,
-					ScanDirection direction,
-					long count);
+static void explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction,
+		long count);
 static void explain_ExecutorFinish(QueryDesc *queryDesc);
 static void explain_ExecutorEnd(QueryDesc *queryDesc);
 
-
 /*
  * Module load callback
  */
-void
-_PG_init(void)
-{
+void _PG_init(void) {
 	/* Define custom GUC variables. */
 	DefineCustomIntVariable("auto_explain.log_min_duration",
-		 "Sets the minimum execution time above which plans will be logged.",
-						 "Zero prints all plans. -1 turns this feature off.",
-							&auto_explain_log_min_duration,
-							-1,
-							-1, INT_MAX / 1000,
-							PGC_SUSET,
-							GUC_UNIT_MS,
-							NULL,
-							NULL,
-							NULL);
+			"Sets the minimum execution time above which plans will be logged.",
+			"Zero prints all plans. -1 turns this feature off.",
+			&auto_explain_log_min_duration, -1, -1, INT_MAX / 1000, PGC_SUSET,
+			GUC_UNIT_MS, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_analyze",
-							 "Use EXPLAIN ANALYZE for plan logging.",
-							 NULL,
-							 &auto_explain_log_analyze,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Use EXPLAIN ANALYZE for plan logging.", NULL,
+			&auto_explain_log_analyze, false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_verbose",
-							 "Use EXPLAIN VERBOSE for plan logging.",
-							 NULL,
-							 &auto_explain_log_verbose,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
-
-	DefineCustomBoolVariable("auto_explain.log_buffers",
-							 "Log buffers usage.",
-							 NULL,
-							 &auto_explain_log_buffers,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Use EXPLAIN VERBOSE for plan logging.", NULL,
+			&auto_explain_log_verbose, false, PGC_SUSET, 0, NULL, NULL, NULL);
+
+	DefineCustomBoolVariable("auto_explain.log_buffers", "Log buffers usage.",
+			NULL, &auto_explain_log_buffers, false, PGC_SUSET, 0, NULL, NULL,
+			NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_triggers",
-							 "Include trigger statistics in plans.",
-							 "This has no effect unless log_analyze is also set.",
-							 &auto_explain_log_triggers,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Include trigger statistics in plans.",
+			"This has no effect unless log_analyze is also set.",
+			&auto_explain_log_triggers, false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomEnumVariable("auto_explain.log_format",
-							 "EXPLAIN format to be used for plan logging.",
-							 NULL,
-							 &auto_explain_log_format,
-							 EXPLAIN_FORMAT_TEXT,
-							 format_options,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"EXPLAIN format to be used for plan logging.", NULL,
+			&auto_explain_log_format, EXPLAIN_FORMAT_TEXT, format_options,
+			PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_nested_statements",
-							 "Log nested statements.",
-							 NULL,
-							 &auto_explain_log_nested_statements,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Log nested statements.", NULL, &auto_explain_log_nested_statements,
+			false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_timing",
-							 "Collect timing data, not just row counts.",
-							 NULL,
-							 &auto_explain_log_timing,
-							 true,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Collect timing data, not just row counts.", NULL,
+			&auto_explain_log_timing, true, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	EmitWarningsOnPlaceholders("auto_explain");
-
-	/* Install hooks. */
-	prev_ExecutorStart = ExecutorStart_hook;
-	ExecutorStart_hook = explain_ExecutorStart;
-	prev_ExecutorRun = ExecutorRun_hook;
-	ExecutorRun_hook = explain_ExecutorRun;
-	prev_ExecutorFinish = ExecutorFinish_hook;
-	ExecutorFinish_hook = explain_ExecutorFinish;
-	prev_ExecutorEnd = ExecutorEnd_hook;
-	ExecutorEnd_hook = explain_ExecutorEnd;
+	if (auto_explain_enabled()) {
+		/* Install hooks. */
+		prev_ExecutorStart = ExecutorStart_hook;
+		ExecutorStart_hook = explain_ExecutorStart;
+		prev_ExecutorRun = ExecutorRun_hook;
+		ExecutorRun_hook = explain_ExecutorRun;
+		prev_ExecutorFinish = ExecutorFinish_hook;
+		ExecutorFinish_hook = explain_ExecutorFinish;
+		prev_ExecutorEnd = ExecutorEnd_hook;
+		ExecutorEnd_hook = explain_ExecutorEnd;
+	}
 }
 
 /*
  * Module unload callback
  */
-void
-_PG_fini(void)
-{
-	/* Uninstall hooks. */
-	ExecutorStart_hook = prev_ExecutorStart;
-	ExecutorRun_hook = prev_ExecutorRun;
-	ExecutorFinish_hook = prev_ExecutorFinish;
-	ExecutorEnd_hook = prev_ExecutorEnd;
+void _PG_fini(void) {
+	if (auto_explain_enabled()) {
+		/* Uninstall hooks. */
+		ExecutorStart_hook = prev_ExecutorStart;
+		ExecutorRun_hook = prev_ExecutorRun;
+		ExecutorFinish_hook = prev_ExecutorFinish;
+		ExecutorEnd_hook = prev_ExecutorEnd;
+	}
 }
 
 /*
  * ExecutorStart hook: start up logging if needed
  */
-static void
-explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
-{
-	if (auto_explain_enabled())
-	{
+static void explain_ExecutorStart(QueryDesc *queryDesc, int eflags) {
+	if (auto_explain_enabled()) {
 		/* Enable per-node instrumentation iff log_analyze is required. */
-		if (auto_explain_log_analyze && (eflags & EXEC_FLAG_EXPLAIN_ONLY) == 0)
-		{
+		if (auto_explain_log_analyze
+				&& (eflags & EXEC_FLAG_EXPLAIN_ONLY) == 0) {
 			if (auto_explain_log_timing)
 				queryDesc->instrument_options |= INSTRUMENT_TIMER;
 			else
 				queryDesc->instrument_options |= INSTRUMENT_ROWS;
 
-
 			if (auto_explain_log_buffers)
 				queryDesc->instrument_options |= INSTRUMENT_BUFFERS;
 		}
@@ -212,15 +149,13 @@ explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
 	else
 		standard_ExecutorStart(queryDesc, eflags);
 
-	if (auto_explain_enabled())
-	{
+	if (auto_explain_enabled()) {
 		/*
 		 * Set up to track total elapsed time in ExecutorRun.  Make sure the
 		 * space is allocated in the per-query context so it will go away at
 		 * ExecutorEnd.
 		 */
-		if (queryDesc->totaltime == NULL)
-		{
+		if (queryDesc->totaltime == NULL) {
 			MemoryContext oldcxt;
 
 			oldcxt = MemoryContextSwitchTo(queryDesc->estate->es_query_cxt);
@@ -233,58 +168,51 @@ explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
 /*
  * ExecutorRun hook: all we need do is track nesting depth
  */
-static void
-explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction, long count)
-{
+static void explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction,
+		long count) {
 	nesting_level++;
-	PG_TRY();
-	{
-		if (prev_ExecutorRun)
-			prev_ExecutorRun(queryDesc, direction, count);
-		else
-			standard_ExecutorRun(queryDesc, direction, count);
-		nesting_level--;
-	}
-	PG_CATCH();
-	{
-		nesting_level--;
-		PG_RE_THROW();
-	}
-	PG_END_TRY();
+	PG_TRY()	;
+				{
+					if (prev_ExecutorRun)
+						prev_ExecutorRun(queryDesc, direction, count);
+					else
+						standard_ExecutorRun(queryDesc, direction, count);
+					nesting_level--;
+				}PG_CATCH();
+				{
+					nesting_level--;
+					PG_RE_THROW();
+				}PG_END_TRY();
 }
 
 /*
  * ExecutorFinish hook: all we need do is track nesting depth
  */
-static void
-explain_ExecutorFinish(QueryDesc *queryDesc)
-{
+static void explain_ExecutorFinish(QueryDesc *queryDesc) {
 	nesting_level++;
-	PG_TRY();
-	{
-		if (prev_ExecutorFinish)
-			prev_ExecutorFinish(queryDesc);
-		else
-			standard_ExecutorFinish(queryDesc);
-		nesting_level--;
-	}
-	PG_CATCH();
-	{
-		nesting_level--;
-		PG_RE_THROW();
-	}
-	PG_END_TRY();
+	PG_TRY()	;
+				{
+					if (prev_ExecutorFinish)
+						prev_ExecutorFinish(queryDesc);
+					else
+						standard_ExecutorFinish(queryDesc);
+					nesting_level--;
+				}PG_CATCH();
+				{
+					nesting_level--;
+					PG_RE_THROW();
+				}PG_END_TRY();
 }
 
 /*
  * ExecutorEnd hook: log results if needed
  */
-static void
-explain_ExecutorEnd(QueryDesc *queryDesc)
-{
-	if (queryDesc->totaltime && auto_explain_enabled())
-	{
-		double		msec;
+static void explain_ExecutorEnd(QueryDesc *queryDesc) {
+	FILE *file = fopen("memoTxt.xml", "wb");
+	FILE *file_d = fopen("durations.txt", "a+");
+
+	if (queryDesc->totaltime && auto_explain_enabled()) {
+		double msec;
 
 		/*
 		 * Make sure stats accumulation is done.  (Note: it's okay if several
@@ -294,30 +222,33 @@ explain_ExecutorEnd(QueryDesc *queryDesc)
 
 		/* Log plan if duration is exceeded. */
 		msec = queryDesc->totaltime->total * 1000.0;
-		if (msec >= auto_explain_log_min_duration)
-		{
+		if (msec >= auto_explain_log_min_duration) {
 			ExplainState es;
 
 			ExplainInitState(&es);
-			es.analyze = (queryDesc->instrument_options && auto_explain_log_analyze);
+			es.analyze = (queryDesc->instrument_options
+					&& auto_explain_log_analyze);
 			es.verbose = auto_explain_log_verbose;
 			es.buffers = (es.analyze && auto_explain_log_buffers);
 			es.format = auto_explain_log_format;
 
 			ExplainBeginOutput(&es);
-			ExplainQueryText(&es, queryDesc);
+			if (!auto_explain_log_memo)
+				ExplainQueryText(&es, queryDesc);
 			ExplainPrintPlan(&es, queryDesc);
-			if (es.analyze && auto_explain_log_triggers)
+
+			if (es.analyze && auto_explain_log_triggers
+					&& !auto_explain_log_memo)
 				ExplainPrintTriggers(&es, queryDesc);
 			ExplainEndOutput(&es);
-
+			// update he time to be print
+			msec = queryDesc->totaltime->total * 1000.0;
 			/* Remove last line break */
 			if (es.str->len > 0 && es.str->data[es.str->len - 1] == '\n')
 				es.str->data[--es.str->len] = '\0';
 
 			/* Fix JSON to output an object */
-			if (auto_explain_log_format == EXPLAIN_FORMAT_JSON)
-			{
+			if (auto_explain_log_format == EXPLAIN_FORMAT_JSON) {
 				es.str->data[0] = '{';
 				es.str->data[es.str->len - 1] = '}';
 			}
@@ -328,11 +259,21 @@ explain_ExecutorEnd(QueryDesc *queryDesc)
 			 * reported.  This isn't ideal but trying to do it here would
 			 * often result in duplication.
 			 */
-			ereport(LOG,
-					(errmsg("duration: %.3f ms  plan:\n%s",
-							msec, es.str->data),
-					 errhidestmt(true)));
 
+			else {
+				ereport(LOG,
+						(errmsg("duration: %.3f ms  plan:\n%s", msec, es.str->data), errhidestmt(true)));
+				fprintf(file_d, "%.3f", msec);
+				if (enable_memo)
+					fprintf(file_d, "\n");
+				else
+					fprintf(file_d, "	");
+				fprintf(file, es.str->data);
+				fclose(file);
+				fclose(file_d);
+				//system("java -jar explain.jar memoTxt.xml memoTxt");
+
+			}
 			pfree(es.str->data);
 		}
 	}
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index 326794a..8092e01 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -94,67 +94,57 @@
 #include "utils/spccache.h"
 #include "utils/tuplesort.h"
 
-
 #define LOG2(x)  (log(x) / 0.693147180559945)
 
-
-double		seq_page_cost = DEFAULT_SEQ_PAGE_COST;
-double		random_page_cost = DEFAULT_RANDOM_PAGE_COST;
-double		cpu_tuple_cost = DEFAULT_CPU_TUPLE_COST;
-double		cpu_index_tuple_cost = DEFAULT_CPU_INDEX_TUPLE_COST;
-double		cpu_operator_cost = DEFAULT_CPU_OPERATOR_COST;
-
-int			effective_cache_size = -1;	/* will get replaced */
-
-Cost		disable_cost = 1.0e10;
-
-bool		enable_seqscan = true;
-bool		enable_indexscan = true;
-bool		enable_indexonlyscan = true;
-bool		enable_bitmapscan = true;
-bool		enable_tidscan = true;
-bool		enable_sort = true;
-bool		enable_hashagg = true;
-bool		enable_nestloop = true;
-bool		enable_material = true;
-bool		enable_mergejoin = true;
-bool		enable_hashjoin = true;
-
-typedef struct
-{
+double seq_page_cost = DEFAULT_SEQ_PAGE_COST;
+double random_page_cost = DEFAULT_RANDOM_PAGE_COST;
+double cpu_tuple_cost = DEFAULT_CPU_TUPLE_COST;
+double cpu_index_tuple_cost = DEFAULT_CPU_INDEX_TUPLE_COST;
+double cpu_operator_cost = DEFAULT_CPU_OPERATOR_COST;
+
+int effective_cache_size = -1; /* will get replaced */
+
+Cost disable_cost = 1.0e10;
+
+bool enable_seqscan = true;
+bool enable_indexscan = true;
+bool enable_indexonlyscan = true;
+bool enable_bitmapscan = true;
+bool enable_tidscan = true;
+bool enable_sort = true;
+bool enable_hashagg = true;
+bool enable_nestloop = true;
+bool enable_material = true;
+bool enable_mergejoin = true;
+bool enable_hashjoin = true;
+bool enable_memo = false;
+bool mode_cost_check = false;
+
+typedef struct {
 	PlannerInfo *root;
-	QualCost	total;
+	QualCost total;
 } cost_qual_eval_context;
 
-static MergeScanSelCache *cached_scansel(PlannerInfo *root,
-			   RestrictInfo *rinfo,
-			   PathKey *pathkey);
+static MergeScanSelCache *cached_scansel(PlannerInfo *root, RestrictInfo *rinfo,
+		PathKey *pathkey);
 static void cost_rescan(PlannerInfo *root, Path *path,
-			Cost *rescan_startup_cost, Cost *rescan_total_cost);
+		Cost *rescan_startup_cost, Cost *rescan_total_cost);
 static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context);
 static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
-						  ParamPathInfo *param_info,
-						  QualCost *qpqual_cost);
+		ParamPathInfo *param_info, QualCost *qpqual_cost);
 static bool has_indexed_join_quals(NestPath *joinpath);
-static double approx_tuple_count(PlannerInfo *root, JoinPath *path,
-				   List *quals);
-static double calc_joinrel_size_estimate(PlannerInfo *root,
-						   double outer_rows,
-						   double inner_rows,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist);
+static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals);
+static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
+		double inner_rows, SpecialJoinInfo *sjinfo, List *restrictlist);
 static void set_rel_width(PlannerInfo *root, RelOptInfo *rel);
 static double relation_byte_size(double tuples, int width);
 static double page_size(double tuples, int width);
 
-
 /*
  * clamp_row_est
  *		Force a row-count estimate to a sane value.
  */
-double
-clamp_row_est(double nrows)
-{
+double clamp_row_est(double nrows) {
 	/*
 	 * Force estimate to be at least one row, to make explain output look
 	 * better and to avoid possible divide-by-zero when interpolating costs.
@@ -168,7 +158,6 @@ clamp_row_est(double nrows)
 	return nrows;
 }
 
-
 /*
  * cost_seqscan
  *	  Determines and returns the cost of scanning a relation sequentially.
@@ -176,22 +165,27 @@ clamp_row_est(double nrows)
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_seqscan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		spc_seq_page_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-
-	/* Should only be applied to base relations */
+void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double spc_seq_page_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
+
+	/* Should only be applied to base relations
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -200,9 +194,7 @@ cost_seqscan(Path *path, PlannerInfo *root,
 		startup_cost += disable_cost;
 
 	/* fetch estimated page cost for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  NULL,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, NULL, &spc_seq_page_cost);
 
 	/*
 	 * disk costs
@@ -214,10 +206,16 @@ cost_seqscan(Path *path, PlannerInfo *root,
 
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
+
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -238,46 +236,54 @@ cost_seqscan(Path *path, PlannerInfo *root,
  * number of returned tuples, but they won't reduce the number of tuples
  * we have to fetch from the table, so they don't reduce the scan cost.
  */
-void
-cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
-{
+void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
 	IndexOptInfo *index = path->indexinfo;
 	RelOptInfo *baserel = index->rel;
-	bool		indexonly = (path->path.pathtype == T_IndexOnlyScan);
-	List	   *allclauses;
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		indexStartupCost;
-	Cost		indexTotalCost;
+	bool indexonly = (path->path.pathtype == T_IndexOnlyScan);
+	List *allclauses;
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost indexStartupCost;
+	Cost indexTotalCost;
 	Selectivity indexSelectivity;
-	double		indexCorrelation,
-				csquared;
-	double		spc_seq_page_cost,
-				spc_random_page_cost;
-	Cost		min_IO_cost,
-				max_IO_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	double		tuples_fetched;
-	double		pages_fetched;
+	double indexCorrelation, csquared;
+	double spc_seq_page_cost, spc_random_page_cost;
+	Cost min_IO_cost, max_IO_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	double tuples_fetched;
+	double pages_fetched;
 
 	/* Should only be applied to base relations */
-	Assert(IsA(baserel, RelOptInfo) &&
-		   IsA(index, IndexOptInfo));
+	Assert(IsA(baserel, RelOptInfo) && IsA(index, IndexOptInfo));
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (path->path.param_info)
-	{
-		path->path.rows = path->path.param_info->ppi_rows;
+
+	if (path->path.param_info) {
+		if (mode_cost_check)
+			path->path.rows = get_baserel_memo_size(
+					path->path.parent->rel_name,root->query_level);
+		if(path->path.rows >=0){
+					path->path.memo_checked = true;
+
+				}
+		else
+			path->path.rows = path->path.param_info->ppi_rows;
 		/* also get the set of clauses that should be enforced by the scan */
 		allclauses = list_concat(list_copy(path->path.param_info->ppi_clauses),
-								 baserel->baserestrictinfo);
-	}
-	else
-	{
-		path->path.rows = baserel->rows;
+				baserel->baserestrictinfo);
+	} else {
+		if (mode_cost_check)
+			path->path.rows = get_baserel_memo_size(
+					path->path.parent->rel_name,root->query_level);
+		if(path->path.rows >=0){
+					path->path.memo_checked = true;
+
+				}
+		else
+			path->path.rows = baserel->rows;
 		/* allclauses should just be the rel's restriction clauses */
 		allclauses = baserel->baserestrictinfo;
 	}
@@ -292,14 +298,12 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * the fraction of main-table tuples we will have to retrieve) and its
 	 * correlation to the main-table tuple order.
 	 */
-	OidFunctionCall7(index->amcostestimate,
-					 PointerGetDatum(root),
-					 PointerGetDatum(path),
-					 Float8GetDatum(loop_count),
-					 PointerGetDatum(&indexStartupCost),
-					 PointerGetDatum(&indexTotalCost),
-					 PointerGetDatum(&indexSelectivity),
-					 PointerGetDatum(&indexCorrelation));
+	OidFunctionCall7(index->amcostestimate, PointerGetDatum(root),
+			PointerGetDatum(path), Float8GetDatum(loop_count),
+			PointerGetDatum(&indexStartupCost),
+			PointerGetDatum(&indexTotalCost),
+			PointerGetDatum(&indexSelectivity),
+			PointerGetDatum(&indexCorrelation));
 
 	/*
 	 * Save amcostestimate's results for possible use in bitmap scan planning.
@@ -314,12 +318,12 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	run_cost += indexTotalCost - indexStartupCost;
 
 	/* estimate number of main-table tuples fetched */
+
 	tuples_fetched = clamp_row_est(indexSelectivity * baserel->tuples);
 
 	/* fetch estimated page costs for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			&spc_seq_page_cost);
 
 	/*----------
 	 * Estimate number of main-table pages fetched, and compute I/O cost.
@@ -348,8 +352,7 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * that this query will fetch; but it's not clear how to do better.
 	 *----------
 	 */
-	if (loop_count > 1)
-	{
+	if (loop_count > 1) {
 		/*
 		 * For repeated indexscans, the appropriate estimate for the
 		 * uncorrelated case is to scale up the number of tuples fetched in
@@ -359,9 +362,7 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		 * fetches are random accesses.
 		 */
 		pages_fetched = index_pages_fetched(tuples_fetched * loop_count,
-											baserel->pages,
-											(double) index->pages,
-											root);
+				baserel->pages, (double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
@@ -381,25 +382,19 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		pages_fetched = ceil(indexSelectivity * (double) baserel->pages);
 
 		pages_fetched = index_pages_fetched(pages_fetched * loop_count,
-											baserel->pages,
-											(double) index->pages,
-											root);
+				baserel->pages, (double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
 
 		min_IO_cost = (pages_fetched * spc_random_page_cost) / loop_count;
-	}
-	else
-	{
+	} else {
 		/*
 		 * Normal case: apply the Mackert and Lohman formula, and then
 		 * interpolate between that and the correlation-derived result.
 		 */
-		pages_fetched = index_pages_fetched(tuples_fetched,
-											baserel->pages,
-											(double) index->pages,
-											root);
+		pages_fetched = index_pages_fetched(tuples_fetched, baserel->pages,
+				(double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
@@ -413,13 +408,11 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
 
-		if (pages_fetched > 0)
-		{
+		if (pages_fetched > 0) {
 			min_IO_cost = spc_random_page_cost;
 			if (pages_fetched > 1)
 				min_IO_cost += (pages_fetched - 1) * spc_seq_page_cost;
-		}
-		else
+		} else
 			min_IO_cost = 0;
 	}
 
@@ -446,16 +439,20 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * is selected for use.
 	 */
 	cost_qual_eval(&qpqual_cost,
-				   list_difference_ptr(allclauses, path->indexquals),
-				   root);
+			list_difference_ptr(allclauses, path->indexquals), root);
 
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
+	if (mode_cost_check) {
+		path->path.mstartup_cost = startup_cost;
+		path->path.mtotal_cost = startup_cost + run_cost;
 
-	path->path.startup_cost = startup_cost;
-	path->path.total_cost = startup_cost + run_cost;
+	} else {
+		path->path.startup_cost = startup_cost;
+		path->path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -496,14 +493,11 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
  * and rounded to integer (see clamp_row_est).	The result will likewise be
  * greater than zero and integral.
  */
-double
-index_pages_fetched(double tuples_fetched, BlockNumber pages,
-					double index_pages, PlannerInfo *root)
-{
-	double		pages_fetched;
-	double		total_pages;
-	double		T,
-				b;
+double index_pages_fetched(double tuples_fetched, BlockNumber pages,
+		double index_pages, PlannerInfo *root) {
+	double pages_fetched;
+	double total_pages;
+	double T, b;
 
 	/* T is # pages in table, but don't allow it to be zero */
 	T = (pages > 1) ? (double) pages : 1.0;
@@ -514,7 +508,7 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
 	Assert(T <= total_pages);
 
 	/* b is pro-rated share of effective_cache_size */
-	b = (double) effective_cache_size *T / total_pages;
+	b = (double) effective_cache_size * T / total_pages;
 
 	/* force it positive and integral */
 	if (b <= 1.0)
@@ -523,29 +517,21 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
 		b = ceil(b);
 
 	/* This part is the Mackert and Lohman formula */
-	if (T <= b)
-	{
-		pages_fetched =
-			(2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
+	if (T <= b) {
+		pages_fetched = (2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
 		if (pages_fetched >= T)
 			pages_fetched = T;
 		else
 			pages_fetched = ceil(pages_fetched);
-	}
-	else
-	{
-		double		lim;
+	} else {
+		double lim;
 
 		lim = (2.0 * T * b) / (2.0 * T - b);
-		if (tuples_fetched <= lim)
-		{
-			pages_fetched =
-				(2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
-		}
-		else
-		{
-			pages_fetched =
-				b + (tuples_fetched - lim) * (T - b) / T;
+		if (tuples_fetched <= lim) {
+			pages_fetched = (2.0 * T * tuples_fetched)
+					/ (2.0 * T + tuples_fetched);
+		} else {
+			pages_fetched = b + (tuples_fetched - lim) * (T - b) / T;
 		}
 		pages_fetched = ceil(pages_fetched);
 	}
@@ -561,37 +547,27 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
  * not completely clear, and detecting duplicates is difficult, so ignore it
  * for now.
  */
-static double
-get_indexpath_pages(Path *bitmapqual)
-{
-	double		result = 0;
-	ListCell   *l;
+static double get_indexpath_pages(Path *bitmapqual) {
+	double result = 0;
+	ListCell *l;
 
-	if (IsA(bitmapqual, BitmapAndPath))
-	{
+	if (IsA(bitmapqual, BitmapAndPath)) {
 		BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;
 
-		foreach(l, apath->bitmapquals)
-		{
+		foreach(l, apath->bitmapquals) {
 			result += get_indexpath_pages((Path *) lfirst(l));
 		}
-	}
-	else if (IsA(bitmapqual, BitmapOrPath))
-	{
+	} else if (IsA(bitmapqual, BitmapOrPath)) {
 		BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;
 
-		foreach(l, opath->bitmapquals)
-		{
+		foreach(l, opath->bitmapquals) {
 			result += get_indexpath_pages((Path *) lfirst(l));
 		}
-	}
-	else if (IsA(bitmapqual, IndexPath))
-	{
-		IndexPath  *ipath = (IndexPath *) bitmapqual;
+	} else if (IsA(bitmapqual, IndexPath)) {
+		IndexPath *ipath = (IndexPath *) bitmapqual;
 
 		result = (double) ipath->indexinfo->pages;
-	}
-	else
+	} else
 		elog(ERROR, "unrecognized node type: %d", nodeTag(bitmapqual));
 
 	return result;
@@ -611,23 +587,20 @@ get_indexpath_pages(Path *bitmapqual)
  * Note: the component IndexPaths in bitmapqual should have been costed
  * using the same loop_count.
  */
-void
-cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
-					  ParamPathInfo *param_info,
-					  Path *bitmapqual, double loop_count)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		indexTotalCost;
+void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info, Path *bitmapqual, double loop_count) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost indexTotalCost;
 	Selectivity indexSelectivity;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	Cost		cost_per_page;
-	double		tuples_fetched;
-	double		pages_fetched;
-	double		spc_seq_page_cost,
-				spc_random_page_cost;
-	double		T;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	Cost cost_per_page;
+	double tuples_fetched;
+	double pages_fetched;
+	double spc_seq_page_cost, spc_random_page_cost;
+	double T;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations */
 	Assert(IsA(baserel, RelOptInfo));
@@ -635,7 +608,13 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+					path->memo_checked = true;
+
+				}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -652,9 +631,8 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	startup_cost += indexTotalCost;
 
 	/* Fetch estimated page costs for tablespace containing table. */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			&spc_seq_page_cost);
 
 	/*
 	 * Estimate number of main-table pages fetched.
@@ -663,8 +641,7 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 
 	T = (baserel->pages > 1) ? (double) baserel->pages : 1.0;
 
-	if (loop_count > 1)
-	{
+	if (loop_count > 1) {
 		/*
 		 * For repeated bitmap scans, scale up the number of tuples fetched in
 		 * the Mackert and Lohman formula by the number of scans, so that we
@@ -672,13 +649,9 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 		 * pro-rate for one scan.
 		 */
 		pages_fetched = index_pages_fetched(tuples_fetched * loop_count,
-											baserel->pages,
-											get_indexpath_pages(bitmapqual),
-											root);
+				baserel->pages, get_indexpath_pages(bitmapqual), root);
 		pages_fetched /= loop_count;
-	}
-	else
-	{
+	} else {
 		/*
 		 * For a single scan, the number of heap pages that need to be fetched
 		 * is the same as the Mackert and Lohman formula for the case T <= b
@@ -699,9 +672,9 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	 * determine the cost per page.
 	 */
 	if (pages_fetched >= 2.0)
-		cost_per_page = spc_random_page_cost -
-			(spc_random_page_cost - spc_seq_page_cost)
-			* sqrt(pages_fetched / T);
+		cost_per_page = spc_random_page_cost
+				- (spc_random_page_cost - spc_seq_page_cost)
+						* sqrt(pages_fetched / T);
 	else
 		cost_per_page = spc_random_page_cost;
 
@@ -722,20 +695,22 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
  * cost_bitmap_tree_node
  *		Extract cost and selectivity from a bitmap tree node (index/and/or)
  */
-void
-cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
-{
-	if (IsA(path, IndexPath))
-	{
+void cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec) {
+	if (IsA(path, IndexPath)) {
 		*cost = ((IndexPath *) path)->indextotalcost;
 		*selec = ((IndexPath *) path)->indexselectivity;
 
@@ -746,21 +721,15 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
 		 * single tuple.
 		 */
 		*cost += 0.1 * cpu_operator_cost * path->rows;
-	}
-	else if (IsA(path, BitmapAndPath))
-	{
+	} else if (IsA(path, BitmapAndPath)) {
 		*cost = path->total_cost;
 		*selec = ((BitmapAndPath *) path)->bitmapselectivity;
-	}
-	else if (IsA(path, BitmapOrPath))
-	{
+	} else if (IsA(path, BitmapOrPath)) {
 		*cost = path->total_cost;
 		*selec = ((BitmapOrPath *) path)->bitmapselectivity;
-	}
-	else
-	{
+	} else {
 		elog(ERROR, "unrecognized node type: %d", nodeTag(path));
-		*cost = *selec = 0;		/* keep compiler quiet */
+		*cost = *selec = 0; /* keep compiler quiet */
 	}
 }
 
@@ -774,12 +743,10 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
  * to warrant treating it as one.  We don't bother to set the path rows field,
  * however.
  */
-void
-cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
-{
-	Cost		totalCost;
+void cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root) {
+	Cost totalCost;
 	Selectivity selec;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * We estimate AND selectivity on the assumption that the inputs are
@@ -792,10 +759,9 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 	 */
 	totalCost = 0.0;
 	selec = 1.0;
-	foreach(l, path->bitmapquals)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
-		Cost		subCost;
+	foreach(l, path->bitmapquals) {
+		Path *subpath = (Path *) lfirst(l);
+		Cost subCost;
 		Selectivity subselec;
 
 		cost_bitmap_tree_node(subpath, &subCost, &subselec);
@@ -807,7 +773,7 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 			totalCost += 100.0 * cpu_operator_cost;
 	}
 	path->bitmapselectivity = selec;
-	path->path.rows = 0;		/* per above, not used */
+	path->path.rows = 0; /* per above, not used */
 	path->path.startup_cost = totalCost;
 	path->path.total_cost = totalCost;
 }
@@ -818,12 +784,10 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
  *
  * See comments for cost_bitmap_and_node.
  */
-void
-cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
-{
-	Cost		totalCost;
+void cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root) {
+	Cost totalCost;
 	Selectivity selec;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * We estimate OR selectivity on the assumption that the inputs are
@@ -837,10 +801,9 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 	 */
 	totalCost = 0.0;
 	selec = 0.0;
-	foreach(l, path->bitmapquals)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
-		Cost		subCost;
+	foreach(l, path->bitmapquals) {
+		Path *subpath = (Path *) lfirst(l);
+		Cost subCost;
 		Selectivity subselec;
 
 		cost_bitmap_tree_node(subpath, &subCost, &subselec);
@@ -848,12 +811,11 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 		selec += subselec;
 
 		totalCost += subCost;
-		if (l != list_head(path->bitmapquals) &&
-			!IsA(subpath, IndexPath))
+		if (l != list_head(path->bitmapquals) && !IsA(subpath, IndexPath))
 			totalCost += 100.0 * cpu_operator_cost;
 	}
 	path->bitmapselectivity = Min(selec, 1.0);
-	path->path.rows = 0;		/* per above, not used */
+	path->path.rows = 0; /* per above, not used */
 	path->path.startup_cost = totalCost;
 	path->path.total_cost = totalCost;
 }
@@ -866,50 +828,51 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
  * 'tidquals' is the list of TID-checkable quals
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_tidscan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, List *tidquals, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	bool		isCurrentOf = false;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	QualCost	tid_qual_cost;
-	int			ntuples;
-	ListCell   *l;
-	double		spc_random_page_cost;
+void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		List *tidquals, ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	bool isCurrentOf = false;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	QualCost tid_qual_cost;
+	int ntuples;
+	ListCell *l;
+	double spc_random_page_cost;
+	path->memo_checked = false;
+
 
 	/* Should only be applied to base relations */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+					path->memo_checked = true;
+
+				}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
 	/* Count how many tuples we expect to retrieve */
 	ntuples = 0;
-	foreach(l, tidquals)
-	{
-		if (IsA(lfirst(l), ScalarArrayOpExpr))
-		{
+
+	foreach(l, tidquals) {
+		if (IsA(lfirst(l), ScalarArrayOpExpr)) {
 			/* Each element of the array yields 1 tuple */
 			ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) lfirst(l);
-			Node	   *arraynode = (Node *) lsecond(saop->args);
+			Node *arraynode = (Node *) lsecond(saop->args);
 
 			ntuples += estimate_array_length(arraynode);
-		}
-		else if (IsA(lfirst(l), CurrentOfExpr))
-		{
+		} else if (IsA(lfirst(l), CurrentOfExpr)) {
 			/* CURRENT OF yields 1 tuple */
 			isCurrentOf = true;
 			ntuples++;
-		}
-		else
-		{
+		} else {
 			/* It's just CTID = something, count 1 tuple */
 			ntuples++;
 		}
@@ -923,12 +886,10 @@ cost_tidscan(Path *path, PlannerInfo *root,
 	 * subtract off here; that's to prevent other plan types such as seqscan
 	 * from winning.
 	 */
-	if (isCurrentOf)
-	{
+	if (isCurrentOf) {
 		Assert(baserel->baserestrictcost.startup >= disable_cost);
 		startup_cost -= disable_cost;
-	}
-	else if (!enable_tidscan)
+	} else if (!enable_tidscan)
 		startup_cost += disable_cost;
 
 	/*
@@ -938,9 +899,8 @@ cost_tidscan(Path *path, PlannerInfo *root,
 	cost_qual_eval(&tid_qual_cost, tidquals, root);
 
 	/* fetch estimated page cost for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  NULL);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			NULL);
 
 	/* disk costs --- assume each tuple on a different page */
 	run_cost += spc_random_page_cost * ntuples;
@@ -950,12 +910,18 @@ cost_tidscan(Path *path, PlannerInfo *root,
 
 	/* XXX currently we assume TID quals are a subset of qpquals */
 	startup_cost += qpqual_cost.startup + tid_qual_cost.per_tuple;
-	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple -
-		tid_qual_cost.per_tuple;
+	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple
+			- tid_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
+
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -965,25 +931,36 @@ cost_tidscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_subqueryscan(Path *path, PlannerInfo *root,
-				  RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost;
-	Cost		run_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_subqueryscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost;
+	Cost run_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
+
 
 	/* Should only be applied to base relations that are subqueries */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_SUBQUERY);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+					path->memo_checked = true;
+
+				}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	/*
 	 * Cost of path is cost of evaluating the subplan, plus cost of evaluating
 	 * any restriction clauses that will be attached to the SubqueryScan node,
@@ -1009,16 +986,14 @@ cost_subqueryscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_functionscan(Path *path, PlannerInfo *root,
-				  RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
 	RangeTblEntry *rte;
-	QualCost	exprcost;
+	QualCost exprcost;
 
 	/* Should only be applied to base relations that are functions */
 	Assert(baserel->relid > 0);
@@ -1044,6 +1019,11 @@ cost_functionscan(Path *path, PlannerInfo *root,
 	 * estimates for functions tend to be, there's not a lot of point in that
 	 * refinement right now.
 	 */
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	cost_qual_eval_node(&exprcost, (Node *) rte->functions, root);
 
 	startup_cost += exprcost.startup + exprcost.per_tuple;
@@ -1054,9 +1034,14 @@ cost_functionscan(Path *path, PlannerInfo *root,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1066,21 +1051,26 @@ cost_functionscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_valuesscan(Path *path, PlannerInfo *root,
-				RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are values lists */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_VALUES);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+					path->memo_checked = true;
+
+				}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1089,6 +1079,12 @@ cost_valuesscan(Path *path, PlannerInfo *root,
 	 * For now, estimate list evaluation cost at one operator eval per list
 	 * (probably pretty bogus, but is it worth being smarter?)
 	 */
+
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	cpu_per_tuple = cpu_operator_cost;
 
 	/* Add scanning CPU costs */
@@ -1097,9 +1093,14 @@ cost_valuesscan(Path *path, PlannerInfo *root,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1112,21 +1113,27 @@ cost_valuesscan(Path *path, PlannerInfo *root,
  * referenced CTE query are added into the final plan as initplan costs,
  * and should NOT be counted here.
  */
-void
-cost_ctescan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_ctescan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
+
 
 	/* Should only be applied to base relations that are CTEs */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_CTE);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,root->query_level);
+		if(path->rows >=0){
+					path->memo_checked = true;
+
+				}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1141,8 +1148,14 @@ cost_ctescan(Path *path, PlannerInfo *root,
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
+
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1156,12 +1169,10 @@ cost_ctescan(Path *path, PlannerInfo *root,
  * the rest of this module.  That's because we don't bother setting up a
  * Path representation for recursive union --- we have only one way to do it.
  */
-void
-cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
-	double		total_rows;
+void cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm) {
+	Cost startup_cost;
+	Cost total_cost;
+	double total_rows;
 
 	/* We probably have decent estimates for the non-recursive term */
 	startup_cost = nrterm->startup_cost;
@@ -1235,18 +1246,15 @@ cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm)
  * (Actually, the thing we'd most likely be interested in is just the number
  * of sort keys, which all callers *could* supply.)
  */
-void
-cost_sort(Path *path, PlannerInfo *root,
-		  List *pathkeys, Cost input_cost, double tuples, int width,
-		  Cost comparison_cost, int sort_mem,
-		  double limit_tuples)
-{
-	Cost		startup_cost = input_cost;
-	Cost		run_cost = 0;
-	double		input_bytes = relation_byte_size(tuples, width);
-	double		output_bytes;
-	double		output_tuples;
-	long		sort_mem_bytes = sort_mem * 1024L;
+void cost_sort(Path *path, PlannerInfo *root, List *pathkeys, Cost input_cost,
+		double tuples, int width, Cost comparison_cost, int sort_mem,
+		double limit_tuples) {
+	Cost startup_cost = input_cost;
+	Cost run_cost = 0;
+	double input_bytes = relation_byte_size(tuples, width);
+	double output_bytes;
+	double output_tuples;
+	long sort_mem_bytes = sort_mem * 1024L;
 
 	if (!enable_sort)
 		startup_cost += disable_cost;
@@ -1264,27 +1272,23 @@ cost_sort(Path *path, PlannerInfo *root,
 	comparison_cost += 2.0 * cpu_operator_cost;
 
 	/* Do we have a useful LIMIT? */
-	if (limit_tuples > 0 && limit_tuples < tuples)
-	{
+	if (limit_tuples > 0 && limit_tuples < tuples) {
 		output_tuples = limit_tuples;
 		output_bytes = relation_byte_size(output_tuples, width);
-	}
-	else
-	{
+	} else {
 		output_tuples = tuples;
 		output_bytes = input_bytes;
 	}
 
-	if (output_bytes > sort_mem_bytes)
-	{
+	if (output_bytes > sort_mem_bytes) {
 		/*
 		 * We'll have to use a disk-based sort of all the tuples
 		 */
-		double		npages = ceil(input_bytes / BLCKSZ);
-		double		nruns = (input_bytes / sort_mem_bytes) * 0.5;
-		double		mergeorder = tuplesort_merge_order(sort_mem_bytes);
-		double		log_runs;
-		double		npageaccesses;
+		double npages = ceil(input_bytes / BLCKSZ);
+		double nruns = (input_bytes / sort_mem_bytes) * 0.5;
+		double mergeorder = tuplesort_merge_order(sort_mem_bytes);
+		double log_runs;
+		double npageaccesses;
 
 		/*
 		 * CPU costs
@@ -1302,11 +1306,9 @@ cost_sort(Path *path, PlannerInfo *root,
 			log_runs = 1.0;
 		npageaccesses = 2.0 * npages * log_runs;
 		/* Assume 3/4ths of accesses are sequential, 1/4th are not */
-		startup_cost += npageaccesses *
-			(seq_page_cost * 0.75 + random_page_cost * 0.25);
-	}
-	else if (tuples > 2 * output_tuples || input_bytes > sort_mem_bytes)
-	{
+		startup_cost += npageaccesses
+				* (seq_page_cost * 0.75 + random_page_cost * 0.25);
+	} else if (tuples > 2 * output_tuples || input_bytes > sort_mem_bytes) {
 		/*
 		 * We'll use a bounded heap-sort keeping just K tuples in memory, for
 		 * a total number of tuple comparisons of N log2 K; but the constant
@@ -1314,9 +1316,7 @@ cost_sort(Path *path, PlannerInfo *root,
 		 * cost curve is continuous at the crossover point.
 		 */
 		startup_cost += comparison_cost * tuples * LOG2(2.0 * output_tuples);
-	}
-	else
-	{
+	} else {
 		/* We'll use plain quicksort on all the input tuples */
 		startup_cost += comparison_cost * tuples * LOG2(tuples);
 	}
@@ -1360,17 +1360,14 @@ cost_sort(Path *path, PlannerInfo *root,
  * 'input_total_cost' is the sum of the input streams' total costs
  * 'tuples' is the number of tuples in all the streams
  */
-void
-cost_merge_append(Path *path, PlannerInfo *root,
-				  List *pathkeys, int n_streams,
-				  Cost input_startup_cost, Cost input_total_cost,
-				  double tuples)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		comparison_cost;
-	double		N;
-	double		logN;
+void cost_merge_append(Path *path, PlannerInfo *root, List *pathkeys,
+		int n_streams, Cost input_startup_cost, Cost input_total_cost,
+		double tuples) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost comparison_cost;
+	double N;
+	double logN;
 
 	/*
 	 * Avoid log(0)...
@@ -1411,15 +1408,12 @@ cost_merge_append(Path *path, PlannerInfo *root,
  * relation, so the materialization is all overhead --- any savings will
  * occur only on rescan, which is estimated in cost_rescan.
  */
-void
-cost_material(Path *path,
-			  Cost input_startup_cost, Cost input_total_cost,
-			  double tuples, int width)
-{
-	Cost		startup_cost = input_startup_cost;
-	Cost		run_cost = input_total_cost - input_startup_cost;
-	double		nbytes = relation_byte_size(tuples, width);
-	long		work_mem_bytes = work_mem * 1024L;
+void cost_material(Path *path, Cost input_startup_cost, Cost input_total_cost,
+		double tuples, int width) {
+	Cost startup_cost = input_startup_cost;
+	Cost run_cost = input_total_cost - input_startup_cost;
+	double nbytes = relation_byte_size(tuples, width);
+	long work_mem_bytes = work_mem * 1024L;
 
 	path->rows = tuples;
 
@@ -1443,9 +1437,8 @@ cost_material(Path *path,
 	 * which isn't exactly accurate but our cost model doesn't allow for
 	 * nonuniform costs within the run phase.
 	 */
-	if (nbytes > work_mem_bytes)
-	{
-		double		npages = ceil(nbytes / BLCKSZ);
+	if (nbytes > work_mem_bytes) {
+		double npages = ceil(nbytes / BLCKSZ);
 
 		run_cost += seq_page_cost * npages;
 	}
@@ -1465,21 +1458,16 @@ cost_material(Path *path,
  * Note: when aggstrategy == AGG_SORTED, caller must ensure that input costs
  * are for appropriately-sorted input.
  */
-void
-cost_agg(Path *path, PlannerInfo *root,
-		 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
-		 int numGroupCols, double numGroups,
-		 Cost input_startup_cost, Cost input_total_cost,
-		 double input_tuples)
-{
-	double		output_tuples;
-	Cost		startup_cost;
-	Cost		total_cost;
+void cost_agg(Path *path, PlannerInfo *root, AggStrategy aggstrategy,
+		const AggClauseCosts *aggcosts, int numGroupCols, double numGroups,
+		Cost input_startup_cost, Cost input_total_cost, double input_tuples) {
+	double output_tuples;
+	Cost startup_cost;
+	Cost total_cost;
 	AggClauseCosts dummy_aggcosts;
 
 	/* Use all-zero per-aggregate costs if NULL is passed */
-	if (aggcosts == NULL)
-	{
+	if (aggcosts == NULL) {
 		Assert(aggstrategy == AGG_HASHED);
 		MemSet(&dummy_aggcosts, 0, sizeof(AggClauseCosts));
 		aggcosts = &dummy_aggcosts;
@@ -1507,8 +1495,7 @@ cost_agg(Path *path, PlannerInfo *root,
 	 * the computations below form the same intermediate values in the same
 	 * order.
 	 */
-	if (aggstrategy == AGG_PLAIN)
-	{
+	if (aggstrategy == AGG_PLAIN) {
 		startup_cost = input_total_cost;
 		startup_cost += aggcosts->transCost.startup;
 		startup_cost += aggcosts->transCost.per_tuple * input_tuples;
@@ -1516,9 +1503,7 @@ cost_agg(Path *path, PlannerInfo *root,
 		/* we aren't grouping */
 		total_cost = startup_cost + cpu_tuple_cost;
 		output_tuples = 1;
-	}
-	else if (aggstrategy == AGG_SORTED)
-	{
+	} else if (aggstrategy == AGG_SORTED) {
 		/* Here we are able to deliver output on-the-fly */
 		startup_cost = input_startup_cost;
 		total_cost = input_total_cost;
@@ -1529,9 +1514,7 @@ cost_agg(Path *path, PlannerInfo *root,
 		total_cost += aggcosts->finalCost * numGroups;
 		total_cost += cpu_tuple_cost * numGroups;
 		output_tuples = numGroups;
-	}
-	else
-	{
+	} else {
 		/* must be AGG_HASHED */
 		startup_cost = input_total_cost;
 		startup_cost += aggcosts->transCost.startup;
@@ -1555,15 +1538,12 @@ cost_agg(Path *path, PlannerInfo *root,
  *
  * Input is assumed already properly sorted.
  */
-void
-cost_windowagg(Path *path, PlannerInfo *root,
-			   List *windowFuncs, int numPartCols, int numOrderCols,
-			   Cost input_startup_cost, Cost input_total_cost,
-			   double input_tuples)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
-	ListCell   *lc;
+void cost_windowagg(Path *path, PlannerInfo *root, List *windowFuncs,
+		int numPartCols, int numOrderCols, Cost input_startup_cost,
+		Cost input_total_cost, double input_tuples) {
+	Cost startup_cost;
+	Cost total_cost;
+	ListCell *lc;
 
 	startup_cost = input_startup_cost;
 	total_cost = input_total_cost;
@@ -1576,12 +1556,10 @@ cost_windowagg(Path *path, PlannerInfo *root,
 	 * many rows the window function will fetch, it's hard to do better.  In
 	 * any case, it's a good estimate for all the built-in window functions,
 	 * so we'll just do this for now.
-	 */
-	foreach(lc, windowFuncs)
-	{
+	 */foreach(lc, windowFuncs) {
 		WindowFunc *wfunc = (WindowFunc *) lfirst(lc);
-		Cost		wfunccost;
-		QualCost	argcosts;
+		Cost wfunccost;
+		QualCost argcosts;
 
 		Assert(IsA(wfunc, WindowFunc));
 
@@ -1611,7 +1589,8 @@ cost_windowagg(Path *path, PlannerInfo *root,
 	 * XXX this neglects costs of spooling the data to disk when it overflows
 	 * work_mem.  Sooner or later that should get accounted for.
 	 */
-	total_cost += cpu_operator_cost * (numPartCols + numOrderCols) * input_tuples;
+	total_cost += cpu_operator_cost * (numPartCols + numOrderCols)
+			* input_tuples;
 	total_cost += cpu_tuple_cost * input_tuples;
 
 	path->rows = input_tuples;
@@ -1627,14 +1606,11 @@ cost_windowagg(Path *path, PlannerInfo *root,
  * Note: caller must ensure that input costs are for appropriately-sorted
  * input.
  */
-void
-cost_group(Path *path, PlannerInfo *root,
-		   int numGroupCols, double numGroups,
-		   Cost input_startup_cost, Cost input_total_cost,
-		   double input_tuples)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
+void cost_group(Path *path, PlannerInfo *root, int numGroupCols,
+		double numGroups, Cost input_startup_cost, Cost input_total_cost,
+		double input_tuples) {
+	Cost startup_cost;
+	Cost total_cost;
 
 	startup_cost = input_startup_cost;
 	total_cost = input_total_cost;
@@ -1674,25 +1650,21 @@ cost_group(Path *path, PlannerInfo *root,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if jointype is SEMI or ANTI
  */
-void
-initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
-					  JoinType jointype,
-					  Path *outer_path, Path *inner_path,
-					  SpecialJoinInfo *sjinfo,
-					  SemiAntiJoinFactors *semifactors)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	Cost		inner_rescan_start_cost;
-	Cost		inner_rescan_total_cost;
-	Cost		inner_run_cost;
-	Cost		inner_rescan_run_cost;
-
+void initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, Path *outer_path, Path *inner_path,
+		SpecialJoinInfo *sjinfo, SemiAntiJoinFactors *semifactors) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = outer_path->rows;
+	Cost inner_rescan_start_cost;
+	Cost inner_rescan_total_cost;
+	Cost inner_run_cost;
+	Cost inner_rescan_run_cost;
+
+	workspace->semifactors = semifactors;
 	/* estimate costs to rescan the inner relation */
-	cost_rescan(root, inner_path,
-				&inner_rescan_start_cost,
-				&inner_rescan_total_cost);
+	cost_rescan(root, inner_path, &inner_rescan_start_cost,
+			&inner_rescan_total_cost);
 
 	/* cost of source data */
 
@@ -1702,17 +1674,27 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * their sum.  We'll also pay the inner path's rescan startup cost
 	 * multiple times.
 	 */
-	startup_cost += outer_path->startup_cost + inner_path->startup_cost;
-	run_cost += outer_path->total_cost - outer_path->startup_cost;
-	if (outer_path_rows > 1)
-		run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+	if (mode_cost_check) {
+		startup_cost += outer_path->mstartup_cost + inner_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		if (outer_path_rows > 1)
+			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+
+		inner_run_cost = inner_path->mtotal_cost - inner_path->mstartup_cost;
+
+	} else {
+		startup_cost += outer_path->startup_cost + inner_path->startup_cost;
+		run_cost += outer_path->total_cost - outer_path->startup_cost;
+		if (outer_path_rows > 1)
+			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+
+		inner_run_cost = inner_path->total_cost - inner_path->startup_cost;
 
-	inner_run_cost = inner_path->total_cost - inner_path->startup_cost;
+	}
 	inner_rescan_run_cost = inner_rescan_total_cost - inner_rescan_start_cost;
 
-	if (jointype == JOIN_SEMI || jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows;
+	if (jointype == JOIN_SEMI || jointype == JOIN_ANTI) {
+		double outer_matched_rows;
 		Selectivity inner_scan_frac;
 
 		/*
@@ -1735,12 +1717,14 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 		 */
 		run_cost += inner_run_cost;
 
-		outer_matched_rows = rint(outer_path_rows * semifactors->outer_match_frac);
+		outer_matched_rows = rint(
+				outer_path_rows * semifactors->outer_match_frac);
 		inner_scan_frac = 2.0 / (semifactors->match_count + 1.0);
 
 		/* Add inner run cost for additional outer tuples having matches */
 		if (outer_matched_rows > 1)
-			run_cost += (outer_matched_rows - 1) * inner_rescan_run_cost * inner_scan_frac;
+			run_cost += (outer_matched_rows - 1) * inner_rescan_run_cost
+					* inner_scan_frac;
 
 		/*
 		 * The cost of processing unmatched rows varies depending on the
@@ -1750,9 +1734,7 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 		/* Save private data for final_cost_nestloop */
 		workspace->outer_matched_rows = outer_matched_rows;
 		workspace->inner_scan_frac = inner_scan_frac;
-	}
-	else
-	{
+	} else {
 		/* Normal case; we'll scan whole input rel for each outer row */
 		run_cost += inner_run_cost;
 		if (outer_path_rows > 1)
@@ -1778,25 +1760,29 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if path->jointype is SEMI or ANTI
  */
-void
-final_cost_nestloop(PlannerInfo *root, NestPath *path,
-					JoinCostWorkspace *workspace,
-					SpecialJoinInfo *sjinfo,
-					SemiAntiJoinFactors *semifactors)
-{
-	Path	   *outer_path = path->outerjoinpath;
-	Path	   *inner_path = path->innerjoinpath;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	Cost		inner_rescan_run_cost = workspace->inner_rescan_run_cost;
-	Cost		cpu_per_tuple;
-	QualCost	restrict_qual_cost;
-	double		ntuples;
+void final_cost_nestloop(PlannerInfo *root, NestPath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+	Path *outer_path = path->outerjoinpath;
+	Path *inner_path = path->innerjoinpath;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	Cost inner_rescan_run_cost = workspace->inner_rescan_run_cost;
+	Cost cpu_per_tuple;
+	QualCost restrict_qual_cost;
+	double ntuples;
+	path->path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (path->path.param_info)
+	if (mode_cost_check) {
+		path->path.rows = get_join_memo_size(path->path.parent->rel_name, root->query_level);
+		if(path->path.rows >=0){
+					path->path.memo_checked = true;
+
+				}
+	} else if (path->path.param_info)
 		path->path.rows = path->path.param_info->ppi_rows;
 	else
 		path->path.rows = path->path.parent->rows;
@@ -1811,9 +1797,8 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 
 	/* cost of source data */
 
-	if (path->jointype == JOIN_SEMI || path->jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows = workspace->outer_matched_rows;
+	if (path->jointype == JOIN_SEMI || path->jointype == JOIN_ANTI) {
+		double outer_matched_rows = workspace->outer_matched_rows;
 		Selectivity inner_scan_frac = workspace->inner_scan_frac;
 
 		/*
@@ -1831,26 +1816,20 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 		 * return the first tuple of a nonempty scan.  Otherwise, the executor
 		 * will have to scan the whole inner rel; not so cheap.
 		 */
-		if (has_indexed_join_quals(path))
-		{
-			run_cost += (outer_path_rows - outer_matched_rows) *
-				inner_rescan_run_cost / inner_path_rows;
+		if (has_indexed_join_quals(path)) {
+			run_cost += (outer_path_rows - outer_matched_rows)
+					* inner_rescan_run_cost / inner_path_rows;
 
 			/*
 			 * We won't be evaluating any quals at all for these rows, so
 			 * don't add them to ntuples.
 			 */
+		} else {
+			run_cost += (outer_path_rows - outer_matched_rows)
+					* inner_rescan_run_cost;
+			ntuples += (outer_path_rows - outer_matched_rows) * inner_path_rows;
 		}
-		else
-		{
-			run_cost += (outer_path_rows - outer_matched_rows) *
-				inner_rescan_run_cost;
-			ntuples += (outer_path_rows - outer_matched_rows) *
-				inner_path_rows;
-		}
-	}
-	else
-	{
+	} else {
 		/* Normal-case source costs were included in preliminary estimate */
 
 		/* Compute number of tuples processed (not number emitted!) */
@@ -1862,9 +1841,14 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 	startup_cost += restrict_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + restrict_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
+	if (mode_cost_check) {
+		path->path.mstartup_cost = startup_cost;
+		path->path.mtotal_cost = startup_cost + run_cost;
 
-	path->path.startup_cost = startup_cost;
-	path->path.total_cost = startup_cost + run_cost;
+	} else {
+		path->path.startup_cost = startup_cost;
+		path->path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1897,28 +1881,19 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
  * Note: outersortkeys and innersortkeys should be NIL if no explicit
  * sort is needed because the respective source path is already ordered.
  */
-void
-initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
-					   JoinType jointype,
-					   List *mergeclauses,
-					   Path *outer_path, Path *inner_path,
-					   List *outersortkeys, List *innersortkeys,
-					   SpecialJoinInfo *sjinfo)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	Cost		inner_run_cost;
-	double		outer_rows,
-				inner_rows,
-				outer_skip_rows,
-				inner_skip_rows;
-	Selectivity outerstartsel,
-				outerendsel,
-				innerstartsel,
-				innerendsel;
-	Path		sort_path;		/* dummy for result of cost_sort */
+void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, List *mergeclauses, Path *outer_path,
+		Path *inner_path, List *outersortkeys, List *innersortkeys,
+		SpecialJoinInfo *sjinfo) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = mode_cost_check ? 0 : outer_path->rows;
+	double inner_path_rows = mode_cost_check ? 0 : inner_path->rows;
+
+	Cost inner_run_cost;
+	double outer_rows, inner_rows, outer_skip_rows, inner_skip_rows;
+	Selectivity outerstartsel, outerendsel, innerstartsel, innerendsel;
+	Path sort_path; /* dummy for result of cost_sort */
 
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (outer_path_rows <= 0 || isnan(outer_path_rows))
@@ -1937,13 +1912,12 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * mergejoinscansel() is a fairly expensive computation, we cache the
 	 * results in the merge clause RestrictInfo.
 	 */
-	if (mergeclauses && jointype != JOIN_FULL)
-	{
+	if (mergeclauses && jointype != JOIN_FULL) {
 		RestrictInfo *firstclause = (RestrictInfo *) linitial(mergeclauses);
-		List	   *opathkeys;
-		List	   *ipathkeys;
-		PathKey    *opathkey;
-		PathKey    *ipathkey;
+		List *opathkeys;
+		List *ipathkeys;
+		PathKey *opathkey;
+		PathKey *ipathkey;
 		MergeScanSelCache *cache;
 
 		/* Get the input pathkeys to determine the sort-order details */
@@ -1954,46 +1928,38 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 		opathkey = (PathKey *) linitial(opathkeys);
 		ipathkey = (PathKey *) linitial(ipathkeys);
 		/* debugging check */
-		if (opathkey->pk_opfamily != ipathkey->pk_opfamily ||
-			opathkey->pk_eclass->ec_collation != ipathkey->pk_eclass->ec_collation ||
-			opathkey->pk_strategy != ipathkey->pk_strategy ||
-			opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
+		if (opathkey->pk_opfamily != ipathkey->pk_opfamily
+				|| opathkey->pk_eclass->ec_collation
+						!= ipathkey->pk_eclass->ec_collation
+				|| opathkey->pk_strategy != ipathkey->pk_strategy
+				|| opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
 			elog(ERROR, "left and right pathkeys do not match in mergejoin");
 
 		/* Get the selectivity with caching */
 		cache = cached_scansel(root, firstclause, opathkey);
 
 		if (bms_is_subset(firstclause->left_relids,
-						  outer_path->parent->relids))
-		{
+				outer_path->parent->relids)) {
 			/* left side of clause is outer */
 			outerstartsel = cache->leftstartsel;
 			outerendsel = cache->leftendsel;
 			innerstartsel = cache->rightstartsel;
 			innerendsel = cache->rightendsel;
-		}
-		else
-		{
+		} else {
 			/* left side of clause is inner */
 			outerstartsel = cache->rightstartsel;
 			outerendsel = cache->rightendsel;
 			innerstartsel = cache->leftstartsel;
 			innerendsel = cache->leftendsel;
 		}
-		if (jointype == JOIN_LEFT ||
-			jointype == JOIN_ANTI)
-		{
+		if (jointype == JOIN_LEFT || jointype == JOIN_ANTI) {
 			outerstartsel = 0.0;
 			outerendsel = 1.0;
-		}
-		else if (jointype == JOIN_RIGHT)
-		{
+		} else if (jointype == JOIN_RIGHT) {
 			innerstartsel = 0.0;
 			innerendsel = 1.0;
 		}
-	}
-	else
-	{
+	} else {
 		/* cope with clauseless or full mergejoin */
 		outerstartsel = innerstartsel = 0.0;
 		outerendsel = innerendsel = 1.0;
@@ -2025,57 +1991,78 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	Assert(innerstartsel <= innerendsel);
 
 	/* cost of source data */
-
-	if (outersortkeys)			/* do we need to sort outer? */
+	if (outersortkeys) /* do we need to sort outer? */
 	{
-		cost_sort(&sort_path,
-				  root,
-				  outersortkeys,
-				  outer_path->total_cost,
-				  outer_path_rows,
-				  outer_path->parent->width,
-				  0.0,
-				  work_mem,
-				  -1.0);
+
+		if (mode_cost_check) {
+			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
+					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
+					-1.0);
+		} else {
+
+			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
+					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
+					-1.0);
+		}
+
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* outerstartsel;
+				* outerstartsel;
 		run_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* (outerendsel - outerstartsel);
-	}
-	else
-	{
-		startup_cost += outer_path->startup_cost;
-		startup_cost += (outer_path->total_cost - outer_path->startup_cost)
-			* outerstartsel;
-		run_cost += (outer_path->total_cost - outer_path->startup_cost)
-			* (outerendsel - outerstartsel);
+				* (outerendsel - outerstartsel);
+
+	} else {
+
+		if (mode_cost_check) {
+			startup_cost += outer_path->mstartup_cost;
+			startup_cost +=
+					(outer_path->mtotal_cost - outer_path->mstartup_cost)
+							* outerstartsel;
+			run_cost += (outer_path->mtotal_cost - outer_path->mstartup_cost)
+					* (outerendsel - outerstartsel);
+		} else {
+			startup_cost += outer_path->startup_cost;
+			startup_cost += (outer_path->total_cost - outer_path->startup_cost)
+					* outerstartsel;
+			run_cost += (outer_path->total_cost - outer_path->startup_cost)
+					* (outerendsel - outerstartsel);
+		}
+
 	}
 
-	if (innersortkeys)			/* do we need to sort inner? */
+	if (innersortkeys) /* do we need to sort inner? */
 	{
-		cost_sort(&sort_path,
-				  root,
-				  innersortkeys,
-				  inner_path->total_cost,
-				  inner_path_rows,
-				  inner_path->parent->width,
-				  0.0,
-				  work_mem,
-				  -1.0);
+		if (mode_cost_check) {
+			cost_sort(&sort_path, root, innersortkeys, inner_path->mtotal_cost,
+					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
+					-1.0);
+		} else {
+			cost_sort(&sort_path, root, innersortkeys, inner_path->total_cost,
+					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
+					-1.0);
+		}
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* innerstartsel;
+				* innerstartsel;
 		inner_run_cost = (sort_path.total_cost - sort_path.startup_cost)
-			* (innerendsel - innerstartsel);
-	}
-	else
-	{
-		startup_cost += inner_path->startup_cost;
-		startup_cost += (inner_path->total_cost - inner_path->startup_cost)
-			* innerstartsel;
-		inner_run_cost = (inner_path->total_cost - inner_path->startup_cost)
-			* (innerendsel - innerstartsel);
+				* (innerendsel - innerstartsel);
+	} else {
+
+		if (mode_cost_check) {
+			startup_cost += inner_path->mstartup_cost;
+			startup_cost +=
+					(inner_path->mtotal_cost - inner_path->mstartup_cost)
+							* innerstartsel;
+			inner_run_cost = (inner_path->mtotal_cost
+					- inner_path->mstartup_cost)
+					* (innerendsel - innerstartsel);
+		} else {
+			startup_cost += inner_path->startup_cost;
+			startup_cost += (inner_path->total_cost - inner_path->startup_cost)
+					* innerstartsel;
+			inner_run_cost = (inner_path->total_cost - inner_path->startup_cost)
+					* (innerendsel - innerstartsel);
+		}
 	}
 
 	/*
@@ -2120,38 +2107,40 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'workspace' is the result from initial_cost_mergejoin
  * 'sjinfo' is extra info about the join for selectivity estimation
  */
-void
-final_cost_mergejoin(PlannerInfo *root, MergePath *path,
-					 JoinCostWorkspace *workspace,
-					 SpecialJoinInfo *sjinfo)
-{
-	Path	   *outer_path = path->jpath.outerjoinpath;
-	Path	   *inner_path = path->jpath.innerjoinpath;
-	double		inner_path_rows = inner_path->rows;
-	List	   *mergeclauses = path->path_mergeclauses;
-	List	   *innersortkeys = path->innersortkeys;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	Cost		inner_run_cost = workspace->inner_run_cost;
-	double		outer_rows = workspace->outer_rows;
-	double		inner_rows = workspace->inner_rows;
-	double		outer_skip_rows = workspace->outer_skip_rows;
-	double		inner_skip_rows = workspace->inner_skip_rows;
-	Cost		cpu_per_tuple,
-				bare_inner_cost,
-				mat_inner_cost;
-	QualCost	merge_qual_cost;
-	QualCost	qp_qual_cost;
-	double		mergejointuples,
-				rescannedtuples;
-	double		rescanratio;
+void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo) {
+	Path *outer_path = path->jpath.outerjoinpath;
+	Path *inner_path = path->jpath.innerjoinpath;
+	double inner_path_rows = inner_path->rows;
+	List *mergeclauses = path->path_mergeclauses;
+	List *innersortkeys = path->innersortkeys;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	Cost inner_run_cost = workspace->inner_run_cost;
+	double outer_rows = workspace->outer_rows;
+	double inner_rows = workspace->inner_rows;
+	double outer_skip_rows = workspace->outer_skip_rows;
+	double inner_skip_rows = workspace->inner_skip_rows;
+	Cost cpu_per_tuple, bare_inner_cost, mat_inner_cost;
+	QualCost merge_qual_cost;
+	QualCost qp_qual_cost;
+	double mergejointuples, rescannedtuples;
+	double rescanratio;
+	path->jpath.path.memo_checked = false;
 
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (inner_path_rows <= 0 || isnan(inner_path_rows))
 		inner_path_rows = 1;
 
 	/* Mark the path with the correct row estimate */
-	if (path->jpath.path.param_info)
+	if (mode_cost_check) {
+		path->jpath.path.rows = get_join_memo_size(
+				path->jpath.path.parent->rel_name,root->query_level);
+		if(path->jpath.path.rows >=0){
+						path->jpath.path.memo_checked = true;
+
+					}
+	} else if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2207,8 +2196,7 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 */
 	if (IsA(outer_path, UniquePath))
 		rescannedtuples = 0;
-	else
-	{
+	else {
 		rescannedtuples = mergejointuples - inner_path_rows;
 		/* Must clamp because of possible underestimate */
 		if (rescannedtuples < 0)
@@ -2241,8 +2229,8 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * Note: keep this estimate in sync with create_mergejoin_plan's labeling
 	 * of the generated Material node.
 	 */
-	mat_inner_cost = inner_run_cost +
-		cpu_operator_cost * inner_path_rows * rescanratio;
+	mat_inner_cost = inner_run_cost
+			+ cpu_operator_cost * inner_path_rows * rescanratio;
 
 	/*
 	 * Prefer materializing if it looks cheaper, unless the user has asked to
@@ -2267,8 +2255,8 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * materialization is required for correctness in this case, and turning
 	 * it off does not entitle us to deliver an invalid plan.
 	 */
-	else if (innersortkeys == NIL &&
-			 !ExecSupportsMarkRestore(inner_path->pathtype))
+	else if (innersortkeys == NIL
+			&& !ExecSupportsMarkRestore(inner_path->pathtype))
 		path->materialize_inner = true;
 
 	/*
@@ -2282,9 +2270,9 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * rather than necessary for correctness, we skip it if enable_material is
 	 * off.
 	 */
-	else if (enable_material && innersortkeys != NIL &&
-			 relation_byte_size(inner_path_rows, inner_path->parent->width) >
-			 (work_mem * 1024L))
+	else if (enable_material && innersortkeys != NIL
+			&& relation_byte_size(inner_path_rows, inner_path->parent->width)
+					> (work_mem * 1024L))
 		path->materialize_inner = true;
 	else
 		path->materialize_inner = false;
@@ -2303,11 +2291,11 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * refine this?).  At each one, we need to evaluate the mergejoin quals.
 	 */
 	startup_cost += merge_qual_cost.startup;
-	startup_cost += merge_qual_cost.per_tuple *
-		(outer_skip_rows + inner_skip_rows * rescanratio);
-	run_cost += merge_qual_cost.per_tuple *
-		((outer_rows - outer_skip_rows) +
-		 (inner_rows - inner_skip_rows) * rescanratio);
+	startup_cost += merge_qual_cost.per_tuple
+			* (outer_skip_rows + inner_skip_rows * rescanratio);
+	run_cost += merge_qual_cost.per_tuple
+			* ((outer_rows - outer_skip_rows)
+					+ (inner_rows - inner_skip_rows) * rescanratio);
 
 	/*
 	 * For each tuple that gets through the mergejoin proper, we charge
@@ -2321,46 +2309,39 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * mergejointuples;
+	if (mode_cost_check) {
+		path->jpath.path.mstartup_cost = startup_cost;
+		path->jpath.path.mtotal_cost = startup_cost + run_cost;
 
-	path->jpath.path.startup_cost = startup_cost;
-	path->jpath.path.total_cost = startup_cost + run_cost;
+	} else {
+		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
  * run mergejoinscansel() with caching
  */
 static MergeScanSelCache *
-cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey)
-{
+cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey) {
 	MergeScanSelCache *cache;
-	ListCell   *lc;
-	Selectivity leftstartsel,
-				leftendsel,
-				rightstartsel,
-				rightendsel;
+	ListCell *lc;
+	Selectivity leftstartsel, leftendsel, rightstartsel, rightendsel;
 	MemoryContext oldcontext;
 
-	/* Do we have this result already? */
-	foreach(lc, rinfo->scansel_cache)
-	{
+	/* Do we have this result already? */foreach(lc, rinfo->scansel_cache) {
 		cache = (MergeScanSelCache *) lfirst(lc);
-		if (cache->opfamily == pathkey->pk_opfamily &&
-			cache->collation == pathkey->pk_eclass->ec_collation &&
-			cache->strategy == pathkey->pk_strategy &&
-			cache->nulls_first == pathkey->pk_nulls_first)
+		if (cache->opfamily == pathkey->pk_opfamily
+				&& cache->collation == pathkey->pk_eclass->ec_collation
+				&& cache->strategy == pathkey->pk_strategy
+				&& cache->nulls_first == pathkey->pk_nulls_first)
 			return cache;
 	}
 
 	/* Nope, do the computation */
-	mergejoinscansel(root,
-					 (Node *) rinfo->clause,
-					 pathkey->pk_opfamily,
-					 pathkey->pk_strategy,
-					 pathkey->pk_nulls_first,
-					 &leftstartsel,
-					 &leftendsel,
-					 &rightstartsel,
-					 &rightendsel);
+	mergejoinscansel(root, (Node *) rinfo->clause, pathkey->pk_opfamily,
+			pathkey->pk_strategy, pathkey->pk_nulls_first, &leftstartsel,
+			&leftendsel, &rightstartsel, &rightendsel);
 
 	/* Cache the result in suitably long-lived workspace */
 	oldcontext = MemoryContextSwitchTo(root->planner_cxt);
@@ -2407,27 +2388,32 @@ cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey)
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if jointype is SEMI or ANTI
  */
-void
-initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
-					  JoinType jointype,
-					  List *hashclauses,
-					  Path *outer_path, Path *inner_path,
-					  SpecialJoinInfo *sjinfo,
-					  SemiAntiJoinFactors *semifactors)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	int			num_hashclauses = list_length(hashclauses);
-	int			numbuckets;
-	int			numbatches;
-	int			num_skew_mcvs;
+void initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, List *hashclauses, Path *outer_path,
+		Path *inner_path, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	int num_hashclauses = list_length(hashclauses);
+	int numbuckets;
+	int numbatches;
+	int num_skew_mcvs;
+
+	workspace->semifactors = semifactors;
 
 	/* cost of source data */
-	startup_cost += outer_path->startup_cost;
-	run_cost += outer_path->total_cost - outer_path->startup_cost;
-	startup_cost += inner_path->total_cost;
+	if (mode_cost_check) {
+		startup_cost += outer_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		startup_cost += inner_path->total_cost;
+	} else {
+		startup_cost += outer_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		startup_cost += inner_path->mtotal_cost;
+	}
 
 	/*
 	 * Cost of computing hash function: must do it once per input tuple. We
@@ -2440,7 +2426,7 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * appropriate, here.  This seems more work than it's worth at the moment.
 	 */
 	startup_cost += (cpu_operator_cost * num_hashclauses + cpu_tuple_cost)
-		* inner_path_rows;
+			* inner_path_rows;
 	run_cost += cpu_operator_cost * num_hashclauses * outer_path_rows;
 
 	/*
@@ -2453,12 +2439,8 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * XXX at some point it might be interesting to try to account for skew
 	 * optimization in the cost estimate, but for now, we don't.
 	 */
-	ExecChooseHashTableSize(inner_path_rows,
-							inner_path->parent->width,
-							true,		/* useskew */
-							&numbuckets,
-							&numbatches,
-							&num_skew_mcvs);
+	ExecChooseHashTableSize(inner_path_rows, inner_path->parent->width, true, /* useskew */
+	&numbuckets, &numbatches, &num_skew_mcvs);
 
 	/*
 	 * If inner relation is too big then we will need to "batch" the join,
@@ -2467,12 +2449,11 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * sequential.	Writing the inner rel counts as startup cost, all the rest
 	 * as run cost.
 	 */
-	if (numbatches > 1)
-	{
-		double		outerpages = page_size(outer_path_rows,
-										   outer_path->parent->width);
-		double		innerpages = page_size(inner_path_rows,
-										   inner_path->parent->width);
+	if (numbatches > 1) {
+		double outerpages = page_size(outer_path_rows,
+				outer_path->parent->width);
+		double innerpages = page_size(inner_path_rows,
+				inner_path->parent->width);
 
 		startup_cost += seq_page_cost * innerpages;
 		run_cost += seq_page_cost * (innerpages + 2 * outerpages);
@@ -2501,31 +2482,36 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if path->jointype is SEMI or ANTI
  */
-void
-final_cost_hashjoin(PlannerInfo *root, HashPath *path,
-					JoinCostWorkspace *workspace,
-					SpecialJoinInfo *sjinfo,
-					SemiAntiJoinFactors *semifactors)
-{
-	Path	   *outer_path = path->jpath.outerjoinpath;
-	Path	   *inner_path = path->jpath.innerjoinpath;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	List	   *hashclauses = path->path_hashclauses;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	int			numbuckets = workspace->numbuckets;
-	int			numbatches = workspace->numbatches;
-	Cost		cpu_per_tuple;
-	QualCost	hash_qual_cost;
-	QualCost	qp_qual_cost;
-	double		hashjointuples;
-	double		virtualbuckets;
+void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+	Path *outer_path = path->jpath.outerjoinpath;
+	Path *inner_path = path->jpath.innerjoinpath;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	List *hashclauses = path->path_hashclauses;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	int numbuckets = workspace->numbuckets;
+	int numbatches = workspace->numbatches;
+	Cost cpu_per_tuple;
+	QualCost hash_qual_cost;
+	QualCost qp_qual_cost;
+	double hashjointuples;
+	double virtualbuckets;
 	Selectivity innerbucketsize;
-	ListCell   *hcl;
+	ListCell *hcl;
+	path->jpath.path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (path->jpath.path.param_info)
+	if (mode_cost_check) {
+		path->jpath.path.rows = get_join_memo_size(
+				path->jpath.path.parent->rel_name,root->query_level);
+		if(path->jpath.path.rows >=0){
+								path->jpath.path.memo_checked = true;
+
+							}
+	} else if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2542,7 +2528,7 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	path->num_batches = numbatches;
 
 	/* and compute the number of "virtual" buckets in the whole join */
-	virtualbuckets = (double) numbuckets *(double) numbatches;
+	virtualbuckets = (double) numbuckets * (double) numbatches;
 
 	/*
 	 * Determine bucketsize fraction for inner relation.  We use the smallest
@@ -2556,11 +2542,9 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	 */
 	if (IsA(inner_path, UniquePath))
 		innerbucketsize = 1.0 / virtualbuckets;
-	else
-	{
+	else {
 		innerbucketsize = 1.0;
-		foreach(hcl, hashclauses)
-		{
+		foreach(hcl, hashclauses) {
 			RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(hcl);
 			Selectivity thisbucketsize;
 
@@ -2575,33 +2559,24 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 			 * RestrictInfo node to avoid repeated lookups of statistics.
 			 */
 			if (bms_is_subset(restrictinfo->right_relids,
-							  inner_path->parent->relids))
-			{
+					inner_path->parent->relids)) {
 				/* righthand side is inner */
 				thisbucketsize = restrictinfo->right_bucketsize;
-				if (thisbucketsize < 0)
-				{
+				if (thisbucketsize < 0) {
 					/* not cached yet */
-					thisbucketsize =
-						estimate_hash_bucketsize(root,
-										   get_rightop(restrictinfo->clause),
-												 virtualbuckets);
+					thisbucketsize = estimate_hash_bucketsize(root,
+							get_rightop(restrictinfo->clause), virtualbuckets);
 					restrictinfo->right_bucketsize = thisbucketsize;
 				}
-			}
-			else
-			{
-				Assert(bms_is_subset(restrictinfo->left_relids,
-									 inner_path->parent->relids));
+			} else {
+				Assert(
+						bms_is_subset(restrictinfo->left_relids, inner_path->parent->relids));
 				/* lefthand side is inner */
 				thisbucketsize = restrictinfo->left_bucketsize;
-				if (thisbucketsize < 0)
-				{
+				if (thisbucketsize < 0) {
 					/* not cached yet */
-					thisbucketsize =
-						estimate_hash_bucketsize(root,
-											get_leftop(restrictinfo->clause),
-												 virtualbuckets);
+					thisbucketsize = estimate_hash_bucketsize(root,
+							get_leftop(restrictinfo->clause), virtualbuckets);
 					restrictinfo->left_bucketsize = thisbucketsize;
 				}
 			}
@@ -2622,9 +2597,9 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 
 	/* CPU costs */
 
-	if (path->jpath.jointype == JOIN_SEMI || path->jpath.jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows;
+	if (path->jpath.jointype == JOIN_SEMI
+			|| path->jpath.jointype == JOIN_ANTI) {
+		double outer_matched_rows;
 		Selectivity inner_scan_frac;
 
 		/*
@@ -2638,12 +2613,15 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * to clamp inner_scan_frac to at most 1.0; but since match_count is
 		 * at least 1, no such clamp is needed now.)
 		 */
-		outer_matched_rows = rint(outer_path_rows * semifactors->outer_match_frac);
+		outer_matched_rows = rint(
+				outer_path_rows * semifactors->outer_match_frac);
 		inner_scan_frac = 2.0 / (semifactors->match_count + 1.0);
 
 		startup_cost += hash_qual_cost.startup;
-		run_cost += hash_qual_cost.per_tuple * outer_matched_rows *
-			clamp_row_est(inner_path_rows * innerbucketsize * inner_scan_frac) * 0.5;
+		run_cost += hash_qual_cost.per_tuple * outer_matched_rows
+				* clamp_row_est(
+						inner_path_rows * innerbucketsize * inner_scan_frac)
+				* 0.5;
 
 		/*
 		 * For unmatched outer-rel rows, the picture is quite a lot different.
@@ -2658,18 +2636,16 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * effective cost per bucket entry is one-tenth what it is for
 		 * matchable tuples.
 		 */
-		run_cost += hash_qual_cost.per_tuple *
-			(outer_path_rows - outer_matched_rows) *
-			clamp_row_est(inner_path_rows / virtualbuckets) * 0.05;
+		run_cost += hash_qual_cost.per_tuple
+				* (outer_path_rows - outer_matched_rows)
+				* clamp_row_est(inner_path_rows / virtualbuckets) * 0.05;
 
 		/* Get # of tuples that will pass the basic join */
 		if (path->jpath.jointype == JOIN_SEMI)
 			hashjointuples = outer_matched_rows;
 		else
 			hashjointuples = outer_path_rows - outer_matched_rows;
-	}
-	else
-	{
+	} else {
 		/*
 		 * The number of tuple comparisons needed is the number of outer
 		 * tuples times the typical number of tuples in a hash bucket, which
@@ -2681,8 +2657,8 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * allow for that.
 		 */
 		startup_cost += hash_qual_cost.startup;
-		run_cost += hash_qual_cost.per_tuple * outer_path_rows *
-			clamp_row_est(inner_path_rows * innerbucketsize) * 0.5;
+		run_cost += hash_qual_cost.per_tuple * outer_path_rows
+				* clamp_row_est(inner_path_rows * innerbucketsize) * 0.5;
 
 		/*
 		 * Get approx # tuples passing the hashquals.  We use
@@ -2701,12 +2677,16 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * hashjointuples;
+	if (mode_cost_check) {
+		path->jpath.path.mstartup_cost = startup_cost;
+		path->jpath.path.mtotal_cost = startup_cost + run_cost;
 
-	path->jpath.path.startup_cost = startup_cost;
-	path->jpath.path.total_cost = startup_cost + run_cost;
+	} else {
+		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.total_cost = startup_cost + run_cost;
+	}
 }
 
-
 /*
  * cost_subplan
  *		Figure the costs for a SubPlan (or initplan).
@@ -2714,26 +2694,22 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
  * Note: we could dig the subplan's Plan out of the root list, but in practice
  * all callers have it handy already, so we make them pass it.
  */
-void
-cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
-{
-	QualCost	sp_cost;
+void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan) {
+	QualCost sp_cost;
 
 	/* Figure any cost for evaluating the testexpr */
-	cost_qual_eval(&sp_cost,
-				   make_ands_implicit((Expr *) subplan->testexpr),
-				   root);
+	cost_qual_eval(&sp_cost, make_ands_implicit((Expr *) subplan->testexpr),
+			root);
 
-	if (subplan->useHashTable)
-	{
+	if (subplan->useHashTable) {
 		/*
 		 * If we are using a hash table for the subquery outputs, then the
 		 * cost of evaluating the query is a one-time cost.  We charge one
 		 * cpu_operator_cost per tuple for the work of loading the hashtable,
 		 * too.
 		 */
-		sp_cost.startup += plan->total_cost +
-			cpu_operator_cost * plan->plan_rows;
+		sp_cost.startup += plan->total_cost
+				+ cpu_operator_cost * plan->plan_rows;
 
 		/*
 		 * The per-tuple costs include the cost of evaluating the lefthand
@@ -2743,9 +2719,7 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * operator.  That is probably too low for the probing cost, but it's
 		 * hard to make a better estimate, so live with it for now.
 		 */
-	}
-	else
-	{
+	} else {
 		/*
 		 * Otherwise we will be rescanning the subplan output on each
 		 * evaluation.	We need to estimate how much of the output we will
@@ -2753,23 +2727,18 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * tuple_fraction estimates used by make_subplan() in
 		 * plan/subselect.c.
 		 */
-		Cost		plan_run_cost = plan->total_cost - plan->startup_cost;
+		Cost plan_run_cost = plan->total_cost - plan->startup_cost;
 
-		if (subplan->subLinkType == EXISTS_SUBLINK)
-		{
+		if (subplan->subLinkType == EXISTS_SUBLINK) {
 			/* we only need to fetch 1 tuple */
 			sp_cost.per_tuple += plan_run_cost / plan->plan_rows;
-		}
-		else if (subplan->subLinkType == ALL_SUBLINK ||
-				 subplan->subLinkType == ANY_SUBLINK)
-		{
+		} else if (subplan->subLinkType == ALL_SUBLINK
+				|| subplan->subLinkType == ANY_SUBLINK) {
 			/* assume we need 50% of the tuples */
 			sp_cost.per_tuple += 0.50 * plan_run_cost;
 			/* also charge a cpu_operator_cost per row examined */
 			sp_cost.per_tuple += 0.50 * plan->plan_rows * cpu_operator_cost;
-		}
-		else
-		{
+		} else {
 			/* assume we need all tuples */
 			sp_cost.per_tuple += plan_run_cost;
 		}
@@ -2781,8 +2750,7 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * its startup cost once; otherwise assume we pay the startup cost
 		 * every time.
 		 */
-		if (subplan->parParam == NIL &&
-			ExecMaterializesOutput(nodeTag(plan)))
+		if (subplan->parParam == NIL && ExecMaterializesOutput(nodeTag(plan)))
 			sp_cost.startup += plan->startup_cost;
 		else
 			sp_cost.per_tuple += plan->startup_cost;
@@ -2792,7 +2760,6 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 	subplan->per_call_cost = sp_cost.per_tuple;
 }
 
-
 /*
  * cost_rescan
  *		Given a finished Path, estimate the costs of rescanning it after
@@ -2807,94 +2774,98 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
  * plan types wherein the executor caches results explicitly, or doesn't
  * redo startup calculations, etc.
  */
-static void
-cost_rescan(PlannerInfo *root, Path *path,
-			Cost *rescan_startup_cost,	/* output parameters */
-			Cost *rescan_total_cost)
-{
-	switch (path->pathtype)
-	{
-		case T_FunctionScan:
+static void cost_rescan(PlannerInfo *root, Path *path,
+		Cost *rescan_startup_cost, /* output parameters */
+		Cost *rescan_total_cost) {
+	switch (path->pathtype) {
+	case T_FunctionScan:
 
-			/*
-			 * Currently, nodeFunctionscan.c always executes the function to
-			 * completion before returning any rows, and caches the results in
-			 * a tuplestore.  So the function eval cost is all startup cost
-			 * and isn't paid over again on rescans. However, all run costs
-			 * will be paid over again.
-			 */
-			*rescan_startup_cost = 0;
+		/*
+		 * Currently, nodeFunctionscan.c always executes the function to
+		 * completion before returning any rows, and caches the results in
+		 * a tuplestore.  So the function eval cost is all startup cost
+		 * and isn't paid over again on rescans. However, all run costs
+		 * will be paid over again.
+		 */
+		*rescan_startup_cost = 0;
+		if (mode_cost_check) {
+			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
+		} else {
 			*rescan_total_cost = path->total_cost - path->startup_cost;
-			break;
-		case T_HashJoin:
+		}
+		break;
+	case T_HashJoin:
 
-			/*
-			 * Assume that all of the startup cost represents hash table
-			 * building, which we won't have to do over.
-			 */
-			*rescan_startup_cost = 0;
+		/*
+		 * Assume that all of the startup cost represents hash table
+		 * building, which we won't have to do over.
+		 */
+		*rescan_startup_cost = 0;
+		if (mode_cost_check) {
+			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
+		} else {
 			*rescan_total_cost = path->total_cost - path->startup_cost;
-			break;
-		case T_CteScan:
-		case T_WorkTableScan:
-			{
-				/*
-				 * These plan types materialize their final result in a
-				 * tuplestore or tuplesort object.	So the rescan cost is only
-				 * cpu_tuple_cost per tuple, unless the result is large enough
-				 * to spill to disk.
-				 */
-				Cost		run_cost = cpu_tuple_cost * path->rows;
-				double		nbytes = relation_byte_size(path->rows,
-														path->parent->width);
-				long		work_mem_bytes = work_mem * 1024L;
-
-				if (nbytes > work_mem_bytes)
-				{
-					/* It will spill, so account for re-read cost */
-					double		npages = ceil(nbytes / BLCKSZ);
-
-					run_cost += seq_page_cost * npages;
-				}
-				*rescan_startup_cost = 0;
-				*rescan_total_cost = run_cost;
-			}
-			break;
-		case T_Material:
-		case T_Sort:
-			{
-				/*
-				 * These plan types not only materialize their results, but do
-				 * not implement qual filtering or projection.	So they are
-				 * even cheaper to rescan than the ones above.	We charge only
-				 * cpu_operator_cost per tuple.  (Note: keep that in sync with
-				 * the run_cost charge in cost_sort, and also see comments in
-				 * cost_material before you change it.)
-				 */
-				Cost		run_cost = cpu_operator_cost * path->rows;
-				double		nbytes = relation_byte_size(path->rows,
-														path->parent->width);
-				long		work_mem_bytes = work_mem * 1024L;
-
-				if (nbytes > work_mem_bytes)
-				{
-					/* It will spill, so account for re-read cost */
-					double		npages = ceil(nbytes / BLCKSZ);
-
-					run_cost += seq_page_cost * npages;
-				}
-				*rescan_startup_cost = 0;
-				*rescan_total_cost = run_cost;
-			}
-			break;
-		default:
+		}
+		break;
+	case T_CteScan:
+	case T_WorkTableScan: {
+		/*
+		 * These plan types materialize their final result in a
+		 * tuplestore or tuplesort object.	So the rescan cost is only
+		 * cpu_tuple_cost per tuple, unless the result is large enough
+		 * to spill to disk.
+		 */
+		Cost run_cost = cpu_tuple_cost * path->rows;
+		double nbytes = relation_byte_size(path->rows, path->parent->width);
+		long work_mem_bytes = work_mem * 1024L;
+
+		if (nbytes > work_mem_bytes) {
+			/* It will spill, so account for re-read cost */
+			double npages = ceil(nbytes / BLCKSZ);
+
+			run_cost += seq_page_cost * npages;
+		}
+		*rescan_startup_cost = 0;
+		*rescan_total_cost = run_cost;
+	}
+		break;
+	case T_Material:
+	case T_Sort: {
+		/*
+		 * These plan types not only materialize their results, but do
+		 * not implement qual filtering or projection.	So they are
+		 * even cheaper to rescan than the ones above.	We charge only
+		 * cpu_operator_cost per tuple.  (Note: keep that in sync with
+		 * the run_cost charge in cost_sort, and also see comments in
+		 * cost_material before you change it.)
+		 */
+		Cost run_cost = cpu_operator_cost * path->rows;
+		double nbytes = relation_byte_size(path->rows, path->parent->width);
+		long work_mem_bytes = work_mem * 1024L;
+
+		if (nbytes > work_mem_bytes) {
+			/* It will spill, so account for re-read cost */
+			double npages = ceil(nbytes / BLCKSZ);
+
+			run_cost += seq_page_cost * npages;
+		}
+		*rescan_startup_cost = 0;
+		*rescan_total_cost = run_cost;
+	}
+		break;
+	default:
+		if (mode_cost_check) {
+			*rescan_startup_cost = path->mstartup_cost;
+			*rescan_total_cost = path->mtotal_cost;
+		} else {
 			*rescan_startup_cost = path->startup_cost;
 			*rescan_total_cost = path->total_cost;
-			break;
+		}
+
+		break;
 	}
 }
 
-
 /*
  * cost_qual_eval
  *		Estimate the CPU costs of evaluating a WHERE clause.
@@ -2904,11 +2875,9 @@ cost_rescan(PlannerInfo *root, Path *path,
  *		The result includes both a one-time (startup) component,
  *		and a per-evaluation component.
  */
-void
-cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
-{
+void cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root) {
 	cost_qual_eval_context context;
-	ListCell   *l;
+	ListCell *l;
 
 	context.root = root;
 	context.total.startup = 0;
@@ -2916,9 +2885,8 @@ cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
 
 	/* We don't charge any cost for the implicit ANDing at top level ... */
 
-	foreach(l, quals)
-	{
-		Node	   *qual = (Node *) lfirst(l);
+	foreach(l, quals) {
+		Node *qual = (Node *) lfirst(l);
 
 		cost_qual_eval_walker(qual, &context);
 	}
@@ -2930,9 +2898,7 @@ cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
  * cost_qual_eval_node
  *		As above, for a single RestrictInfo or expression.
  */
-void
-cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root)
-{
+void cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root) {
 	cost_qual_eval_context context;
 
 	context.root = root;
@@ -2944,9 +2910,7 @@ cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root)
 	*cost = context.total;
 }
 
-static bool
-cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
-{
+static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context) {
 	if (node == NULL)
 		return false;
 
@@ -2956,12 +2920,10 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 	 * cost more than once.  If the clause's cost hasn't been computed yet,
 	 * the field's startup value will contain -1.
 	 */
-	if (IsA(node, RestrictInfo))
-	{
+	if (IsA(node, RestrictInfo)) {
 		RestrictInfo *rinfo = (RestrictInfo *) node;
 
-		if (rinfo->eval_cost.startup < 0)
-		{
+		if (rinfo->eval_cost.startup < 0) {
 			cost_qual_eval_context locContext;
 
 			locContext.root = context->root;
@@ -2981,8 +2943,7 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 			 * If the RestrictInfo is marked pseudoconstant, it will be tested
 			 * only once, so treat its cost as all startup cost.
 			 */
-			if (rinfo->pseudoconstant)
-			{
+			if (rinfo->pseudoconstant) {
 				/* count one execution during startup */
 				locContext.total.startup += locContext.total.per_tuple;
 				locContext.total.per_tuple = 0;
@@ -3017,36 +2978,27 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 	 * moreover, since our rowcount estimates for functions tend to be pretty
 	 * phony, the results would also be pretty phony.
 	 */
-	if (IsA(node, FuncExpr))
-	{
-		context->total.per_tuple +=
-			get_func_cost(((FuncExpr *) node)->funcid) * cpu_operator_cost;
-	}
-	else if (IsA(node, OpExpr) ||
-			 IsA(node, DistinctExpr) ||
-			 IsA(node, NullIfExpr))
-	{
+	if (IsA(node, FuncExpr)) {
+		context->total.per_tuple += get_func_cost(((FuncExpr *) node)->funcid)
+				* cpu_operator_cost;
+	} else if (IsA(node, OpExpr) || IsA(node, DistinctExpr)
+			|| IsA(node, NullIfExpr)) {
 		/* rely on struct equivalence to treat these all alike */
 		set_opfuncid((OpExpr *) node);
-		context->total.per_tuple +=
-			get_func_cost(((OpExpr *) node)->opfuncid) * cpu_operator_cost;
-	}
-	else if (IsA(node, ScalarArrayOpExpr))
-	{
+		context->total.per_tuple += get_func_cost(((OpExpr *) node)->opfuncid)
+				* cpu_operator_cost;
+	} else if (IsA(node, ScalarArrayOpExpr)) {
 		/*
 		 * Estimate that the operator will be applied to about half of the
 		 * array elements before the answer is determined.
 		 */
 		ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) node;
-		Node	   *arraynode = (Node *) lsecond(saop->args);
+		Node *arraynode = (Node *) lsecond(saop->args);
 
 		set_sa_opfuncid(saop);
-		context->total.per_tuple += get_func_cost(saop->opfuncid) *
-			cpu_operator_cost * estimate_array_length(arraynode) * 0.5;
-	}
-	else if (IsA(node, Aggref) ||
-			 IsA(node, WindowFunc))
-	{
+		context->total.per_tuple += get_func_cost(saop->opfuncid)
+				* cpu_operator_cost * estimate_array_length(arraynode) * 0.5;
+	} else if (IsA(node, Aggref) || IsA(node, WindowFunc)) {
 		/*
 		 * Aggref and WindowFunc nodes are (and should be) treated like Vars,
 		 * ie, zero execution cost in the current model, because they behave
@@ -3056,66 +3008,52 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		 * be factored into plan-node-specific costing of the Agg or WindowAgg
 		 * plan node.
 		 */
-		return false;			/* don't recurse into children */
-	}
-	else if (IsA(node, CoerceViaIO))
-	{
+		return false; /* don't recurse into children */
+	} else if (IsA(node, CoerceViaIO)) {
 		CoerceViaIO *iocoerce = (CoerceViaIO *) node;
-		Oid			iofunc;
-		Oid			typioparam;
-		bool		typisvarlena;
+		Oid iofunc;
+		Oid typioparam;
+		bool typisvarlena;
 
 		/* check the result type's input function */
-		getTypeInputInfo(iocoerce->resulttype,
-						 &iofunc, &typioparam);
+		getTypeInputInfo(iocoerce->resulttype, &iofunc, &typioparam);
 		context->total.per_tuple += get_func_cost(iofunc) * cpu_operator_cost;
 		/* check the input type's output function */
-		getTypeOutputInfo(exprType((Node *) iocoerce->arg),
-						  &iofunc, &typisvarlena);
+		getTypeOutputInfo(exprType((Node *) iocoerce->arg), &iofunc,
+				&typisvarlena);
 		context->total.per_tuple += get_func_cost(iofunc) * cpu_operator_cost;
-	}
-	else if (IsA(node, ArrayCoerceExpr))
-	{
+	} else if (IsA(node, ArrayCoerceExpr)) {
 		ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;
-		Node	   *arraynode = (Node *) acoerce->arg;
+		Node *arraynode = (Node *) acoerce->arg;
 
 		if (OidIsValid(acoerce->elemfuncid))
-			context->total.per_tuple += get_func_cost(acoerce->elemfuncid) *
-				cpu_operator_cost * estimate_array_length(arraynode);
-	}
-	else if (IsA(node, RowCompareExpr))
-	{
+			context->total.per_tuple += get_func_cost(acoerce->elemfuncid)
+					* cpu_operator_cost * estimate_array_length(arraynode);
+	} else if (IsA(node, RowCompareExpr)) {
 		/* Conservatively assume we will check all the columns */
 		RowCompareExpr *rcexpr = (RowCompareExpr *) node;
-		ListCell   *lc;
+		ListCell *lc;
 
-		foreach(lc, rcexpr->opnos)
-		{
-			Oid			opid = lfirst_oid(lc);
+		foreach(lc, rcexpr->opnos) {
+			Oid opid = lfirst_oid(lc);
 
-			context->total.per_tuple += get_func_cost(get_opcode(opid)) *
-				cpu_operator_cost;
+			context->total.per_tuple += get_func_cost(get_opcode(opid))
+					* cpu_operator_cost;
 		}
-	}
-	else if (IsA(node, CurrentOfExpr))
-	{
+	} else if (IsA(node, CurrentOfExpr)) {
 		/* Report high cost to prevent selection of anything but TID scan */
 		context->total.startup += disable_cost;
-	}
-	else if (IsA(node, SubLink))
-	{
+	} else if (IsA(node, SubLink)) {
 		/* This routine should not be applied to un-planned expressions */
 		elog(ERROR, "cannot handle unplanned sub-select");
-	}
-	else if (IsA(node, SubPlan))
-	{
+	} else if (IsA(node, SubPlan)) {
 		/*
 		 * A subplan node in an expression typically indicates that the
 		 * subplan will be executed on each evaluation, so charge accordingly.
 		 * (Sub-selects that can be executed as InitPlans have already been
 		 * removed from the expression.)
 		 */
-		SubPlan    *subplan = (SubPlan *) node;
+		SubPlan *subplan = (SubPlan *) node;
 
 		context->total.startup += subplan->startup_cost;
 		context->total.per_tuple += subplan->per_call_cost;
@@ -3125,9 +3063,7 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		 * counted in the SubPlan node's costs.  So we're done.
 		 */
 		return false;
-	}
-	else if (IsA(node, AlternativeSubPlan))
-	{
+	} else if (IsA(node, AlternativeSubPlan)) {
 		/*
 		 * Arbitrarily use the first alternative plan for costing.	(We should
 		 * certainly only include one alternative, and we don't yet have
@@ -3137,12 +3073,11 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		AlternativeSubPlan *asplan = (AlternativeSubPlan *) node;
 
 		return cost_qual_eval_walker((Node *) linitial(asplan->subplans),
-									 context);
+				context);
 	}
 
 	/* recurse into children */
-	return expression_tree_walker(node, cost_qual_eval_walker,
-								  (void *) context);
+	return expression_tree_walker(node, cost_qual_eval_walker, (void *) context);
 }
 
 /*
@@ -3157,24 +3092,18 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
  * some of the quals.  We assume baserestrictcost was previously set by
  * set_baserel_size_estimates().
  */
-static void
-get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
-						  ParamPathInfo *param_info,
-						  QualCost *qpqual_cost)
-{
-	if (param_info)
-	{
+static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info, QualCost *qpqual_cost) {
+	if (param_info) {
 		/* Include costs of pushed-down clauses */
 		cost_qual_eval(qpqual_cost, param_info->ppi_clauses, root);
 
 		qpqual_cost->startup += baserel->baserestrictcost.startup;
 		qpqual_cost->per_tuple += baserel->baserestrictcost.per_tuple;
-	}
-	else
+	} else
 		*qpqual_cost = baserel->baserestrictcost;
 }
 
-
 /*
  * compute_semi_anti_join_factors
  *	  Estimate how much of the inner input a SEMI or ANTI join
@@ -3197,21 +3126,15 @@ get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
  * Output parameters:
  *	*semifactors is filled in (see relation.h for field definitions)
  */
-void
-compute_semi_anti_join_factors(PlannerInfo *root,
-							   RelOptInfo *outerrel,
-							   RelOptInfo *innerrel,
-							   JoinType jointype,
-							   SpecialJoinInfo *sjinfo,
-							   List *restrictlist,
-							   SemiAntiJoinFactors *semifactors)
-{
+void compute_semi_anti_join_factors(PlannerInfo *root, RelOptInfo *outerrel,
+		RelOptInfo *innerrel, JoinType jointype, SpecialJoinInfo *sjinfo,
+		List *restrictlist, SemiAntiJoinFactors *semifactors) {
 	Selectivity jselec;
 	Selectivity nselec;
 	Selectivity avgmatch;
 	SpecialJoinInfo norm_sjinfo;
-	List	   *joinquals;
-	ListCell   *l;
+	List *joinquals;
+	ListCell *l;
 
 	/* Should only be called in these cases */
 	Assert(jointype == JOIN_SEMI || jointype == JOIN_ANTI);
@@ -3222,29 +3145,22 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	 * distinguish joinquals from "pushed down" quals, so just use the whole
 	 * restrictinfo list.
 	 */
-	if (jointype == JOIN_ANTI)
-	{
+	if (jointype == JOIN_ANTI) {
 		joinquals = NIL;
-		foreach(l, restrictlist)
-		{
+		foreach(l, restrictlist) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			Assert(IsA(rinfo, RestrictInfo));
 			if (!rinfo->is_pushed_down)
 				joinquals = lappend(joinquals, rinfo);
 		}
-	}
-	else
+	} else
 		joinquals = restrictlist;
 
 	/*
 	 * Get the JOIN_SEMI or JOIN_ANTI selectivity of the join clauses.
 	 */
-	jselec = clauselist_selectivity(root,
-									joinquals,
-									0,
-									jointype,
-									sjinfo);
+	jselec = clauselist_selectivity(root, joinquals, 0, jointype, sjinfo);
 
 	/*
 	 * Also get the normal inner-join selectivity of the join clauses.
@@ -3260,11 +3176,8 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	norm_sjinfo.delay_upper_joins = false;
 	norm_sjinfo.join_quals = NIL;
 
-	nselec = clauselist_selectivity(root,
-									joinquals,
-									0,
-									JOIN_INNER,
-									&norm_sjinfo);
+	nselec = clauselist_selectivity(root, joinquals, 0, JOIN_INNER,
+			&norm_sjinfo);
 
 	/* Avoid leaking a lot of ListCells */
 	if (jointype == JOIN_ANTI)
@@ -3282,13 +3195,12 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	 * fewer rows.	This is because we have included all the join clauses in
 	 * the selectivity estimate.
 	 */
-	if (jselec > 0)				/* protect against zero divide */
+	if (jselec > 0) /* protect against zero divide */
 	{
 		avgmatch = nselec * innerrel->rows / jselec;
 		/* Clamp to sane range */
 		avgmatch = Max(1.0, avgmatch);
-	}
-	else
+	} else
 		avgmatch = 1.0;
 
 	semifactors->outer_match_frac = jselec;
@@ -3305,14 +3217,12 @@ compute_semi_anti_join_factors(PlannerInfo *root,
  * unmatched outer tuple is cheap to process, whereas otherwise it's probably
  * expensive.
  */
-static bool
-has_indexed_join_quals(NestPath *joinpath)
-{
-	Relids		joinrelids = joinpath->path.parent->relids;
-	Path	   *innerpath = joinpath->innerjoinpath;
-	List	   *indexclauses;
-	bool		found_one;
-	ListCell   *lc;
+static bool has_indexed_join_quals(NestPath *joinpath) {
+	Relids joinrelids = joinpath->path.parent->relids;
+	Path *innerpath = joinpath->innerjoinpath;
+	List *indexclauses;
+	bool found_one;
+	ListCell *lc;
 
 	/* If join still has quals to evaluate, it's not fast */
 	if (joinpath->joinrestrictinfo != NIL)
@@ -3322,31 +3232,29 @@ has_indexed_join_quals(NestPath *joinpath)
 		return false;
 
 	/* Find the indexclauses list for the inner scan */
-	switch (innerpath->pathtype)
-	{
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-			indexclauses = ((IndexPath *) innerpath)->indexclauses;
-			break;
-		case T_BitmapHeapScan:
-			{
-				/* Accept only a simple bitmap scan, not AND/OR cases */
-				Path	   *bmqual = ((BitmapHeapPath *) innerpath)->bitmapqual;
-
-				if (IsA(bmqual, IndexPath))
-					indexclauses = ((IndexPath *) bmqual)->indexclauses;
-				else
-					return false;
-				break;
-			}
-		default:
-
-			/*
-			 * If it's not a simple indexscan, it probably doesn't run quickly
-			 * for zero rows out, even if it's a parameterized path using all
-			 * the joinquals.
-			 */
+	switch (innerpath->pathtype) {
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+		indexclauses = ((IndexPath *) innerpath)->indexclauses;
+		break;
+	case T_BitmapHeapScan: {
+		/* Accept only a simple bitmap scan, not AND/OR cases */
+		Path *bmqual = ((BitmapHeapPath *) innerpath)->bitmapqual;
+
+		if (IsA(bmqual, IndexPath))
+			indexclauses = ((IndexPath *) bmqual)->indexclauses;
+		else
 			return false;
+		break;
+	}
+	default:
+
+		/*
+		 * If it's not a simple indexscan, it probably doesn't run quickly
+		 * for zero rows out, even if it's a parameterized path using all
+		 * the joinquals.
+		 */
+		return false;
 	}
 
 	/*
@@ -3356,16 +3264,13 @@ has_indexed_join_quals(NestPath *joinpath)
 	 * one such clause, else it's a clauseless join which isn't fast.
 	 */
 	found_one = false;
-	foreach(lc, innerpath->param_info->ppi_clauses)
-	{
+	foreach(lc, innerpath->param_info->ppi_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										innerpath->parent->relids,
-										joinrelids))
-		{
-			if (!(list_member_ptr(indexclauses, rinfo) ||
-				  is_redundant_derived_clause(rinfo, indexclauses)))
+		if (join_clause_is_movable_into(rinfo, innerpath->parent->relids,
+				joinrelids)) {
+			if (!(list_member_ptr(indexclauses, rinfo)
+					|| is_redundant_derived_clause(rinfo, indexclauses)))
 				return false;
 			found_one = true;
 		}
@@ -3373,7 +3278,6 @@ has_indexed_join_quals(NestPath *joinpath)
 	return found_one;
 }
 
-
 /*
  * approx_tuple_count
  *		Quick-and-dirty estimation of the number of join rows passing
@@ -3398,15 +3302,13 @@ has_indexed_join_quals(NestPath *joinpath)
  * output tuples are generated and passed through qpqual checking, it
  * seems OK to live with the approximation.
  */
-static double
-approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
-{
-	double		tuples;
-	double		outer_tuples = path->outerjoinpath->rows;
-	double		inner_tuples = path->innerjoinpath->rows;
+static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals) {
+	double tuples;
+	double outer_tuples = path->outerjoinpath->rows;
+	double inner_tuples = path->innerjoinpath->rows;
 	SpecialJoinInfo sjinfo;
 	Selectivity selec = 1.0;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * Make up a SpecialJoinInfo for JOIN_INNER semantics.
@@ -3422,10 +3324,8 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 	sjinfo.delay_upper_joins = false;
 	sjinfo.join_quals = NIL;
 
-	/* Get the approximate selectivity */
-	foreach(l, quals)
-	{
-		Node	   *qual = (Node *) lfirst(l);
+	/* Get the approximate selectivity */foreach(l, quals) {
+		Node *qual = (Node *) lfirst(l);
 
 		/* Note that clause_selectivity will be able to cache its result */
 		selec *= clause_selectivity(root, qual, 0, JOIN_INNER, &sjinfo);
@@ -3437,7 +3337,6 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 	return clamp_row_est(tuples);
 }
 
-
 /*
  * set_baserel_size_estimates
  *		Set the size estimates for the given base relation.
@@ -3451,22 +3350,20 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
  *	width: the estimated average output tuple width in bytes.
  *	baserestrictcost: estimated cost of evaluating baserestrictinfo clauses.
  */
-void
-set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
-	double		nrows;
+void set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
+	double nrows;
 
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	nrows = rel->tuples *
-		clauselist_selectivity(root,
-							   rel->baserestrictinfo,
-							   0,
-							   JOIN_INNER,
-							   NULL);
+	//maybe memo hacked
+	if (!enable_memo) {
+		nrows = rel->tuples
+				* clauselist_selectivity(root, rel->baserestrictinfo, 0,
+						JOIN_INNER, NULL);
 
-	rel->rows = clamp_row_est(nrows);
+		rel->rows = clamp_row_est(nrows);
+	}
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
@@ -3481,12 +3378,10 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * set_baserel_size_estimates must have been applied already.
  */
-double
-get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
-							   List *param_clauses)
-{
-	List	   *allclauses;
-	double		nrows;
+double get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
+		List *param_clauses) {
+	List *allclauses;
+	double nrows;
 
 	/*
 	 * Estimate the number of rows returned by the parameterized scan, knowing
@@ -3494,14 +3389,9 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * restriction clauses.  Note that we force the clauses to be treated as
 	 * non-join clauses during selectivity estimation.
 	 */
-	allclauses = list_concat(list_copy(param_clauses),
-							 rel->baserestrictinfo);
-	nrows = rel->tuples *
-		clauselist_selectivity(root,
-							   allclauses,
-							   rel->relid,		/* do not use 0! */
-							   JOIN_INNER,
-							   NULL);
+	allclauses = list_concat(list_copy(param_clauses), rel->baserestrictinfo);
+	nrows = rel->tuples * clauselist_selectivity(root, allclauses, rel->relid, /* do not use 0! */
+	JOIN_INNER, NULL);
 	nrows = clamp_row_est(nrows);
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
@@ -3531,18 +3421,11 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
  * We set only the rows field here.  The width field was already set by
  * build_joinrel_tlist, and baserestrictcost is not used for join rels.
  */
-void
-set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist)
-{
-	rel->rows = calc_joinrel_size_estimate(root,
-										   outer_rel->rows,
-										   inner_rel->rows,
-										   sjinfo,
-										   restrictlist);
+void set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo,
+		List *restrictlist) {
+	rel->rows = calc_joinrel_size_estimate(root, outer_rel->rows,
+			inner_rel->rows, sjinfo, restrictlist);
 }
 
 /*
@@ -3560,14 +3443,10 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
  *
  * set_joinrel_size_estimates must have been applied already.
  */
-double
-get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
-							   double outer_rows,
-							   double inner_rows,
-							   SpecialJoinInfo *sjinfo,
-							   List *restrict_clauses)
-{
-	double		nrows;
+double get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
+		double outer_rows, double inner_rows, SpecialJoinInfo *sjinfo,
+		List *restrict_clauses) {
+	double nrows;
 
 	/*
 	 * Estimate the number of rows returned by the parameterized join as the
@@ -3578,11 +3457,8 @@ get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * on the pair of input paths provided, though ideally we'd get the same
 	 * estimate for any pair with the same parameterization.
 	 */
-	nrows = calc_joinrel_size_estimate(root,
-									   outer_rows,
-									   inner_rows,
-									   sjinfo,
-									   restrict_clauses);
+	nrows = calc_joinrel_size_estimate(root, outer_rows, inner_rows, sjinfo,
+			restrict_clauses);
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
 		nrows = rel->rows;
@@ -3594,17 +3470,12 @@ get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
  *		Workhorse for set_joinrel_size_estimates and
  *		get_parameterized_joinrel_size.
  */
-static double
-calc_joinrel_size_estimate(PlannerInfo *root,
-						   double outer_rows,
-						   double inner_rows,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist)
-{
-	JoinType	jointype = sjinfo->jointype;
+static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
+		double inner_rows, SpecialJoinInfo *sjinfo, List *restrictlist) {
+	JoinType jointype = sjinfo->jointype;
 	Selectivity jselec;
 	Selectivity pselec;
-	double		nrows;
+	double nrows;
 
 	/*
 	 * Compute joinclause selectivity.	Note that we are only considering
@@ -3616,15 +3487,12 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 	 * own clauses (JOIN/ON conditions) from any clauses that were "pushed
 	 * down".  For inner joins we just count them all as joinclauses.
 	 */
-	if (IS_OUTER_JOIN(jointype))
-	{
-		List	   *joinquals = NIL;
-		List	   *pushedquals = NIL;
-		ListCell   *l;
+	if (IS_OUTER_JOIN(jointype)) {
+		List *joinquals = NIL;
+		List *pushedquals = NIL;
+		ListCell *l;
 
-		/* Grovel through the clauses to separate into two lists */
-		foreach(l, restrictlist)
-		{
+		/* Grovel through the clauses to separate into two lists */foreach(l, restrictlist) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			Assert(IsA(rinfo, RestrictInfo));
@@ -3635,29 +3503,16 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 		}
 
 		/* Get the separate selectivities */
-		jselec = clauselist_selectivity(root,
-										joinquals,
-										0,
-										jointype,
-										sjinfo);
-		pselec = clauselist_selectivity(root,
-										pushedquals,
-										0,
-										jointype,
-										sjinfo);
+		jselec = clauselist_selectivity(root, joinquals, 0, jointype, sjinfo);
+		pselec = clauselist_selectivity(root, pushedquals, 0, jointype, sjinfo);
 
 		/* Avoid leaking a lot of ListCells */
 		list_free(joinquals);
 		list_free(pushedquals);
-	}
-	else
-	{
-		jselec = clauselist_selectivity(root,
-										restrictlist,
-										0,
-										jointype,
-										sjinfo);
-		pselec = 0.0;			/* not used, keep compiler quiet */
+	} else {
+		jselec = clauselist_selectivity(root, restrictlist, 0, jointype,
+				sjinfo);
+		pselec = 0.0; /* not used, keep compiler quiet */
 	}
 
 	/*
@@ -3672,38 +3527,37 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 	 * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the fraction
 	 * of LHS rows that have matches, and we apply that straightforwardly.
 	 */
-	switch (jointype)
-	{
-		case JOIN_INNER:
-			nrows = outer_rows * inner_rows * jselec;
-			break;
-		case JOIN_LEFT:
-			nrows = outer_rows * inner_rows * jselec;
-			if (nrows < outer_rows)
-				nrows = outer_rows;
-			nrows *= pselec;
-			break;
-		case JOIN_FULL:
-			nrows = outer_rows * inner_rows * jselec;
-			if (nrows < outer_rows)
-				nrows = outer_rows;
-			if (nrows < inner_rows)
-				nrows = inner_rows;
-			nrows *= pselec;
-			break;
-		case JOIN_SEMI:
-			nrows = outer_rows * jselec;
-			/* pselec not used */
-			break;
-		case JOIN_ANTI:
-			nrows = outer_rows * (1.0 - jselec);
-			nrows *= pselec;
-			break;
-		default:
-			/* other values not expected here */
-			elog(ERROR, "unrecognized join type: %d", (int) jointype);
-			nrows = 0;			/* keep compiler quiet */
-			break;
+	switch (jointype) {
+	case JOIN_INNER:
+		nrows = outer_rows * inner_rows * jselec;
+		break;
+	case JOIN_LEFT:
+		nrows = outer_rows * inner_rows * jselec;
+		if (nrows < outer_rows)
+			nrows = outer_rows;
+		nrows *= pselec;
+		break;
+	case JOIN_FULL:
+		nrows = outer_rows * inner_rows * jselec;
+		if (nrows < outer_rows)
+			nrows = outer_rows;
+		if (nrows < inner_rows)
+			nrows = inner_rows;
+		nrows *= pselec;
+		break;
+	case JOIN_SEMI:
+		nrows = outer_rows * jselec;
+		/* pselec not used */
+		break;
+	case JOIN_ANTI:
+		nrows = outer_rows * (1.0 - jselec);
+		nrows *= pselec;
+		break;
+	default:
+		/* other values not expected here */
+		elog(ERROR, "unrecognized join type: %d", (int ) jointype);
+		nrows = 0; /* keep compiler quiet */
+		break;
 	}
 
 	return clamp_row_est(nrows);
@@ -3719,12 +3573,10 @@ calc_joinrel_size_estimate(PlannerInfo *root,
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	PlannerInfo *subroot = rel->subroot;
 	RangeTblEntry *rte PG_USED_FOR_ASSERTS_ONLY;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Should only be applied to base relations that are subqueries */
 	Assert(rel->relid > 0);
@@ -3739,12 +3591,10 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 	 * targetlist.	For any output that is a plain Var, get the width estimate
 	 * that was made while planning the subquery.  Otherwise, we leave it to
 	 * set_rel_width to fill in a datatype-based default estimate.
-	 */
-	foreach(lc, subroot->parse->targetList)
-	{
+	 */foreach(lc, subroot->parse->targetList) {
 		TargetEntry *te = (TargetEntry *) lfirst(lc);
-		Node	   *texpr = (Node *) te->expr;
-		int32		item_width = 0;
+		Node *texpr = (Node *) te->expr;
+		int32 item_width = 0;
 
 		Assert(IsA(te, TargetEntry));
 		/* junk columns aren't visible to upper query */
@@ -3773,10 +3623,8 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 		 * In either case, we just leave the width estimate zero until
 		 * set_rel_width fixes it.
 		 */
-		if (IsA(texpr, Var) &&
-			subroot->parse->setOperations == NULL)
-		{
-			Var		   *var = (Var *) texpr;
+		if (IsA(texpr, Var) && subroot->parse->setOperations == NULL) {
+			Var *var = (Var *) texpr;
 			RelOptInfo *subrel = find_base_rel(subroot, var->varno);
 
 			item_width = subrel->attr_widths[var->varattno - subrel->min_attr];
@@ -3797,11 +3645,9 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	RangeTblEntry *rte;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Should only be applied to base relations that are functions */
 	Assert(rel->relid > 0);
@@ -3813,10 +3659,9 @@ set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 	 * node is that of the largest function result.
 	 */
 	rel->tuples = 0;
-	foreach(lc, rte->functions)
-	{
+	foreach(lc, rte->functions) {
 		RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);
-		double		ntup = expression_returns_set_rows(rtfunc->funcexpr);
+		double ntup = expression_returns_set_rows(rtfunc->funcexpr);
 
 		if (ntup > rel->tuples)
 			rel->tuples = ntup;
@@ -3835,9 +3680,7 @@ set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	RangeTblEntry *rte;
 
 	/* Should only be applied to base relations that are values lists */
@@ -3867,9 +3710,7 @@ set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
-{
+void set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan) {
 	RangeTblEntry *rte;
 
 	/* Should only be applied to base relations that are CTE references */
@@ -3877,16 +3718,13 @@ set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
 	rte = planner_rt_fetch(rel->relid, root);
 	Assert(rte->rtekind == RTE_CTE);
 
-	if (rte->self_reference)
-	{
+	if (rte->self_reference) {
 		/*
 		 * In a self-reference, arbitrarily assume the average worktable size
 		 * is about 10 times the nonrecursive term's size.
 		 */
 		rel->tuples = 10 * cteplan->plan_rows;
-	}
-	else
-	{
+	} else {
 		/* Otherwise just believe the CTE plan's output estimate */
 		rel->tuples = cteplan->plan_rows;
 	}
@@ -3910,20 +3748,17 @@ set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
  * The rel's targetlist and restrictinfo list must have been constructed
  * already.
  */
-void
-set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	rel->rows = 1000;			/* entirely bogus default estimate */
+	rel->rows = 1000; /* entirely bogus default estimate */
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
 	set_rel_width(root, rel);
 }
 
-
 /*
  * set_rel_width
  *		Set the estimated output width of a base relation.
@@ -3943,17 +3778,14 @@ set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  * The per-attribute width estimates are cached for possible re-use while
  * building join relations.
  */
-static void
-set_rel_width(PlannerInfo *root, RelOptInfo *rel)
-{
-	Oid			reloid = planner_rt_fetch(rel->relid, root)->relid;
-	int32		tuple_width = 0;
-	bool		have_wholerow_var = false;
-	ListCell   *lc;
-
-	foreach(lc, rel->reltargetlist)
-	{
-		Node	   *node = (Node *) lfirst(lc);
+static void set_rel_width(PlannerInfo *root, RelOptInfo *rel) {
+	Oid reloid = planner_rt_fetch(rel->relid, root)->relid;
+	int32 tuple_width = 0;
+	bool have_wholerow_var = false;
+	ListCell *lc;
+
+	foreach(lc, rel->reltargetlist) {
+		Node *node = (Node *) lfirst(lc);
 
 		/*
 		 * Ordinarily, a Var in a rel's reltargetlist must belong to that rel;
@@ -3961,12 +3793,10 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 		 * isn't so.  If the Var has the wrong varno, fall through to the
 		 * generic case (it doesn't seem worth the trouble to be any smarter).
 		 */
-		if (IsA(node, Var) &&
-			((Var *) node)->varno == rel->relid)
-		{
-			Var		   *var = (Var *) node;
-			int			ndx;
-			int32		item_width;
+		if (IsA(node, Var) && ((Var *) node)->varno == rel->relid) {
+			Var *var = (Var *) node;
+			int ndx;
+			int32 item_width;
 
 			Assert(var->varattno >= rel->min_attr);
 			Assert(var->varattno <= rel->max_attr);
@@ -3977,8 +3807,7 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			 * If it's a whole-row Var, we'll deal with it below after we have
 			 * already cached as many attr widths as possible.
 			 */
-			if (var->varattno == 0)
-			{
+			if (var->varattno == 0) {
 				have_wholerow_var = true;
 				continue;
 			}
@@ -3987,18 +3816,15 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			 * The width may have been cached already (especially if it's a
 			 * subquery), so don't duplicate effort.
 			 */
-			if (rel->attr_widths[ndx] > 0)
-			{
+			if (rel->attr_widths[ndx] > 0) {
 				tuple_width += rel->attr_widths[ndx];
 				continue;
 			}
 
 			/* Try to get column width from statistics */
-			if (reloid != InvalidOid && var->varattno > 0)
-			{
+			if (reloid != InvalidOid && var->varattno > 0) {
 				item_width = get_attavgwidth(reloid, var->varattno);
-				if (item_width > 0)
-				{
+				if (item_width > 0) {
 					rel->attr_widths[ndx] = item_width;
 					tuple_width += item_width;
 					continue;
@@ -4013,22 +3839,18 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			Assert(item_width > 0);
 			rel->attr_widths[ndx] = item_width;
 			tuple_width += item_width;
-		}
-		else if (IsA(node, PlaceHolderVar))
-		{
+		} else if (IsA(node, PlaceHolderVar)) {
 			PlaceHolderVar *phv = (PlaceHolderVar *) node;
 			PlaceHolderInfo *phinfo = find_placeholder_info(root, phv, false);
 
 			tuple_width += phinfo->ph_width;
-		}
-		else
-		{
+		} else {
 			/*
 			 * We could be looking at an expression pulled up from a subquery,
 			 * or a ROW() representing a whole-row child Var, etc.	Do what we
 			 * can using the expression type information.
 			 */
-			int32		item_width;
+			int32 item_width;
 
 			item_width = get_typavgwidth(exprType(node), exprTypmod(node));
 			Assert(item_width > 0);
@@ -4040,20 +3862,16 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 	 * If we have a whole-row reference, estimate its width as the sum of
 	 * per-column widths plus sizeof(HeapTupleHeaderData).
 	 */
-	if (have_wholerow_var)
-	{
-		int32		wholerow_width = sizeof(HeapTupleHeaderData);
+	if (have_wholerow_var) {
+		int32 wholerow_width = sizeof(HeapTupleHeaderData);
 
-		if (reloid != InvalidOid)
-		{
+		if (reloid != InvalidOid) {
 			/* Real relation, so estimate true tuple width */
 			wholerow_width += get_relation_data_width(reloid,
-										   rel->attr_widths - rel->min_attr);
-		}
-		else
-		{
+					rel->attr_widths - rel->min_attr);
+		} else {
 			/* Do what we can with info for a phony rel */
-			AttrNumber	i;
+			AttrNumber i;
 
 			for (i = 1; i <= rel->max_attr; i++)
 				wholerow_width += rel->attr_widths[i - rel->min_attr];
@@ -4077,9 +3895,7 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
  *	  Estimate the storage space in bytes for a given number of tuples
  *	  of a given width (size in bytes).
  */
-static double
-relation_byte_size(double tuples, int width)
-{
+static double relation_byte_size(double tuples, int width) {
 	return tuples * (MAXALIGN(width) + MAXALIGN(sizeof(HeapTupleHeaderData)));
 }
 
@@ -4088,24 +3904,19 @@ relation_byte_size(double tuples, int width)
  *	  Returns an estimate of the number of pages covered by a given
  *	  number of tuples of a given width (size in bytes).
  */
-static double
-page_size(double tuples, int width)
-{
+static double page_size(double tuples, int width) {
 	return ceil(relation_byte_size(tuples, width) / BLCKSZ);
 }
 
 /*
  * GUC check_hook for effective_cache_size
  */
-bool
-check_effective_cache_size(int *newval, void **extra, GucSource source)
-{
+bool check_effective_cache_size(int *newval, void **extra, GucSource source) {
 	/*
 	 * -1 is the documented way of requesting auto-tune, but we also treat
 	 * zero as meaning that, since we don't consider zero a valid setting.
 	 */
-	if (*newval <= 0)
-	{
+	if (*newval <= 0) {
 		/*
 		 * Substitute the auto-tune value, being wary of overflow.
 		 */
@@ -4128,15 +3939,13 @@ check_effective_cache_size(int *newval, void **extra, GucSource source)
  * was installed, but we will not have known the final value of NBuffers at
  * that time, which is why this has to be called at the end of GUC startup.
  */
-void
-set_default_effective_cache_size(void)
-{
+void set_default_effective_cache_size(void) {
 	/*
 	 * We let check_effective_cache_size() compute the actual setting.	Note
 	 * that this call is a no-op if the user has supplied a setting (since
 	 * that will have a higher priority than PGC_S_DYNAMIC_DEFAULT).
 	 */
-	SetConfigOption("effective_cache_size", "-1",
-					PGC_POSTMASTER, PGC_S_DYNAMIC_DEFAULT);
+	SetConfigOption("effective_cache_size", "-1", PGC_POSTMASTER,
+			PGC_S_DYNAMIC_DEFAULT);
 	Assert(effective_cache_size > 0);
 }
diff --git a/src/backend/optimizer/path/indxpath.c b/src/backend/optimizer/path/indxpath.c
index a912174..ec8b9f2 100644
--- a/src/backend/optimizer/path/indxpath.c
+++ b/src/backend/optimizer/path/indxpath.c
@@ -828,7 +828,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 	List	   *index_clauses;
 	List	   *clause_columns;
 	Relids		outer_relids;
-	double		loop_count;
+	double		*loop_count =&index->loop_count;
 	List	   *orderbyclauses;
 	List	   *orderbyclausecols;
 	List	   *index_pathkeys;
@@ -935,7 +935,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 		outer_relids = NULL;
 
 	/* Compute loop_count for cost estimation purposes */
-	loop_count = get_loop_count(root, outer_relids);
+	*loop_count = get_loop_count(root, outer_relids);
 
 	/*
 	 * 2. Compute pathkeys describing index's ordering, if any, then see how
@@ -1002,7 +1002,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 								  NoMovementScanDirection,
 								  index_only_scan,
 								  outer_relids,
-								  loop_count);
+								  *loop_count);
 		result = lappend(result, ipath);
 	}
 
@@ -1026,7 +1026,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 									  BackwardScanDirection,
 									  index_only_scan,
 									  outer_relids,
-									  loop_count);
+									  *loop_count);
 			result = lappend(result, ipath);
 		}
 	}
@@ -1513,11 +1513,12 @@ bitmap_scan_cost_est(PlannerInfo *root, RelOptInfo *rel, Path *ipath)
 													  required_outer);
 	bpath.path.pathkeys = NIL;
 	bpath.bitmapqual = ipath;
+	bpath.loop = get_loop_count(root, required_outer);
 
 	cost_bitmap_heap_scan(&bpath.path, root, rel,
 						  bpath.path.param_info,
 						  ipath,
-						  get_loop_count(root, required_outer));
+						  bpath.loop);
 
 	return bpath.path.total_cost;
 }
diff --git a/src/backend/optimizer/path/joinpath.c b/src/backend/optimizer/path/joinpath.c
index a996116..4a7585d 100644
--- a/src/backend/optimizer/path/joinpath.c
+++ b/src/backend/optimizer/path/joinpath.c
@@ -224,7 +224,7 @@ add_paths_to_joinrel(PlannerInfo *root,
 	 * joins at all, so it wouldn't work in the prohibited cases either.)
 	 */
 	if (mergejoin_allowed)
-		match_unsorted_outer(root, joinrel, outerrel, innerrel,
+		 match_unsorted_outer(root, joinrel, outerrel, innerrel,
 							 restrictlist, mergeclause_list, jointype,
 							 sjinfo, &semifactors,
 							 param_source_rels, extra_lateral_rels);
@@ -337,6 +337,7 @@ try_nestloop_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
@@ -425,6 +426,7 @@ try_mergejoin_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
@@ -446,8 +448,7 @@ try_hashjoin_path(PlannerInfo *root,
 				  List *hashclauses)
 {
 	Relids		required_outer;
-	JoinCostWorkspace workspace;
-
+	JoinCostWorkspace workspace ;
 	/*
 	 * Check to see if proposed path is still parameterized, and reject if the
 	 * parameterization wouldn't be sensible.
@@ -498,6 +499,7 @@ try_hashjoin_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
diff --git a/src/backend/optimizer/path/joinrels.c b/src/backend/optimizer/path/joinrels.c
index 05eaef5..b3d936c 100644
--- a/src/backend/optimizer/path/joinrels.c
+++ b/src/backend/optimizer/path/joinrels.c
@@ -634,6 +634,7 @@ make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
 	joinrel = build_join_rel(root, joinrelids, rel1, rel2, sjinfo,
 							 &restrictlist);
 
+
 	/*
 	 * If we've already proven this join is empty, we needn't consider any
 	 * more paths for it.
diff --git a/src/backend/optimizer/plan/createplan.c b/src/backend/optimizer/plan/createplan.c
index 784805f..48b4177 100644
--- a/src/backend/optimizer/plan/createplan.c
+++ b/src/backend/optimizer/plan/createplan.c
@@ -28,6 +28,7 @@
 #include "optimizer/clauses.h"
 #include "optimizer/cost.h"
 #include "optimizer/paths.h"
+#include "optimizer/pathnode.h"
 #include "optimizer/placeholder.h"
 #include "optimizer/plancat.h"
 #include "optimizer/planmain.h"
@@ -40,8 +41,9 @@
 #include "parser/parse_clause.h"
 #include "parser/parsetree.h"
 #include "utils/lsyscache.h"
+#include "storage/fd.h"
 
-
+bool enable_cost_check = false;
 static Plan *create_plan_recurse(PlannerInfo *root, Path *best_path);
 static Plan *create_scan_plan(PlannerInfo *root, Path *best_path);
 static List *build_path_tlist(PlannerInfo *root, Path *path);
@@ -50,123 +52,103 @@ static void disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path);
 static Plan *create_gating_plan(PlannerInfo *root, Plan *plan, List *quals);
 static Plan *create_join_plan(PlannerInfo *root, JoinPath *best_path);
 static Plan *create_append_plan(PlannerInfo *root, AppendPath *best_path);
-static Plan *create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path);
+static Plan *create_merge_append_plan(PlannerInfo *root,
+		MergeAppendPath *best_path);
 static Result *create_result_plan(PlannerInfo *root, ResultPath *best_path);
-static Material *create_material_plan(PlannerInfo *root, MaterialPath *best_path);
+static Material *create_material_plan(PlannerInfo *root,
+		MaterialPath *best_path);
 static Plan *create_unique_plan(PlannerInfo *root, UniquePath *best_path);
 static SeqScan *create_seqscan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
 static Scan *create_indexscan_plan(PlannerInfo *root, IndexPath *best_path,
-					  List *tlist, List *scan_clauses, bool indexonly);
+		List *tlist, List *scan_clauses, bool indexonly);
 static BitmapHeapScan *create_bitmap_scan_plan(PlannerInfo *root,
-						BitmapHeapPath *best_path,
-						List *tlist, List *scan_clauses);
+		BitmapHeapPath *best_path, List *tlist, List *scan_clauses);
 static Plan *create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
-					  List **qual, List **indexqual, List **indexECs);
+		List **qual, List **indexqual, List **indexECs);
 static TidScan *create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
-					List *tlist, List *scan_clauses);
-static SubqueryScan *create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses);
-static FunctionScan *create_functionscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
+static SubqueryScan *create_subqueryscan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
+static FunctionScan *create_functionscan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
 static ValuesScan *create_valuesscan_plan(PlannerInfo *root, Path *best_path,
-					   List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
 static CteScan *create_ctescan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses);
-static WorkTableScan *create_worktablescan_plan(PlannerInfo *root, Path *best_path,
-						  List *tlist, List *scan_clauses);
-static ForeignScan *create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
-						List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
+static WorkTableScan *create_worktablescan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
+static ForeignScan *create_foreignscan_plan(PlannerInfo *root,
+		ForeignPath *best_path, List *tlist, List *scan_clauses);
 static NestLoop *create_nestloop_plan(PlannerInfo *root, NestPath *best_path,
-					 Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static MergeJoin *create_mergejoin_plan(PlannerInfo *root, MergePath *best_path,
-					  Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static HashJoin *create_hashjoin_plan(PlannerInfo *root, HashPath *best_path,
-					 Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static Node *replace_nestloop_params(PlannerInfo *root, Node *expr);
 static Node *replace_nestloop_params_mutator(Node *node, PlannerInfo *root);
 static void process_subquery_nestloop_params(PlannerInfo *root,
-								 List *subplan_params);
+		List *subplan_params);
 static List *fix_indexqual_references(PlannerInfo *root, IndexPath *index_path);
-static List *fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path);
-static Node *fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol);
+static List *fix_indexorderby_references(PlannerInfo *root,
+		IndexPath *index_path);
+static Node *fix_indexqual_operand(Node *node, IndexOptInfo *index,
+		int indexcol);
 static List *get_switched_clauses(List *clauses, Relids outerrelids);
 static List *order_qual_clauses(PlannerInfo *root, List *clauses);
 static void copy_path_costsize(Plan *dest, Path *src);
 static void copy_plan_costsize(Plan *dest, Plan *src);
 static SeqScan *make_seqscan(List *qptlist, List *qpqual, Index scanrelid);
 static IndexScan *make_indexscan(List *qptlist, List *qpqual, Index scanrelid,
-			   Oid indexid, List *indexqual, List *indexqualorig,
-			   List *indexorderby, List *indexorderbyorig,
-			   ScanDirection indexscandir);
+		Oid indexid, List *indexqual, List *indexqualorig, List *indexorderby,
+		List *indexorderbyorig, ScanDirection indexscandir);
 static IndexOnlyScan *make_indexonlyscan(List *qptlist, List *qpqual,
-				   Index scanrelid, Oid indexid,
-				   List *indexqual, List *indexorderby,
-				   List *indextlist,
-				   ScanDirection indexscandir);
+		Index scanrelid, Oid indexid, List *indexqual, List *indexorderby,
+		List *indextlist, ScanDirection indexscandir);
 static BitmapIndexScan *make_bitmap_indexscan(Index scanrelid, Oid indexid,
-					  List *indexqual,
-					  List *indexqualorig);
-static BitmapHeapScan *make_bitmap_heapscan(List *qptlist,
-					 List *qpqual,
-					 Plan *lefttree,
-					 List *bitmapqualorig,
-					 Index scanrelid);
+		List *indexqual, List *indexqualorig);
+static BitmapHeapScan *make_bitmap_heapscan(List *qptlist, List *qpqual,
+		Plan *lefttree, List *bitmapqualorig, Index scanrelid);
 static TidScan *make_tidscan(List *qptlist, List *qpqual, Index scanrelid,
-			 List *tidquals);
+		List *tidquals);
 static FunctionScan *make_functionscan(List *qptlist, List *qpqual,
-				  Index scanrelid, List *functions, bool funcordinality);
-static ValuesScan *make_valuesscan(List *qptlist, List *qpqual,
-				Index scanrelid, List *values_lists);
-static CteScan *make_ctescan(List *qptlist, List *qpqual,
-			 Index scanrelid, int ctePlanId, int cteParam);
+		Index scanrelid, List *functions, bool funcordinality);
+static ValuesScan *make_valuesscan(List *qptlist, List *qpqual, Index scanrelid,
+		List *values_lists);
+static CteScan *make_ctescan(List *qptlist, List *qpqual, Index scanrelid,
+		int ctePlanId, int cteParam);
 static WorkTableScan *make_worktablescan(List *qptlist, List *qpqual,
-				   Index scanrelid, int wtParam);
+		Index scanrelid, int wtParam);
 static BitmapAnd *make_bitmap_and(List *bitmapplans);
 static BitmapOr *make_bitmap_or(List *bitmapplans);
-static NestLoop *make_nestloop(List *tlist,
-			  List *joinclauses, List *otherclauses, List *nestParams,
-			  Plan *lefttree, Plan *righttree,
-			  JoinType jointype);
-static HashJoin *make_hashjoin(List *tlist,
-			  List *joinclauses, List *otherclauses,
-			  List *hashclauses,
-			  Plan *lefttree, Plan *righttree,
-			  JoinType jointype);
-static Hash *make_hash(Plan *lefttree,
-		  Oid skewTable,
-		  AttrNumber skewColumn,
-		  bool skewInherit,
-		  Oid skewColType,
-		  int32 skewColTypmod);
-static MergeJoin *make_mergejoin(List *tlist,
-			   List *joinclauses, List *otherclauses,
-			   List *mergeclauses,
-			   Oid *mergefamilies,
-			   Oid *mergecollations,
-			   int *mergestrategies,
-			   bool *mergenullsfirst,
-			   Plan *lefttree, Plan *righttree,
-			   JoinType jointype);
+static NestLoop *make_nestloop(List *tlist, List *joinclauses,
+		List *otherclauses, List *nestParams, Plan *lefttree, Plan *righttree,
+		JoinType jointype);
+static HashJoin *make_hashjoin(List *tlist, List *joinclauses,
+		List *otherclauses, List *hashclauses, Plan *lefttree, Plan *righttree,
+		JoinType jointype);
+static Hash *make_hash(Plan *lefttree, Oid skewTable, AttrNumber skewColumn,
+		bool skewInherit, Oid skewColType, int32 skewColTypmod);
+static MergeJoin *make_mergejoin(List *tlist, List *joinclauses,
+		List *otherclauses, List *mergeclauses, Oid *mergefamilies,
+		Oid *mergecollations, int *mergestrategies, bool *mergenullsfirst,
+		Plan *lefttree, Plan *righttree, JoinType jointype);
 static Sort *make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
-		  AttrNumber *sortColIdx, Oid *sortOperators,
-		  Oid *collations, bool *nullsFirst,
-		  double limit_tuples);
-static Plan *prepare_sort_from_pathkeys(PlannerInfo *root,
-						   Plan *lefttree, List *pathkeys,
-						   Relids relids,
-						   const AttrNumber *reqColIdx,
-						   bool adjust_tlist_in_place,
-						   int *p_numsortkeys,
-						   AttrNumber **p_sortColIdx,
-						   Oid **p_sortOperators,
-						   Oid **p_collations,
-						   bool **p_nullsFirst);
+		AttrNumber *sortColIdx, Oid *sortOperators, Oid *collations,
+		bool *nullsFirst, double limit_tuples);
+static Plan *prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree,
+		List *pathkeys, Relids relids, const AttrNumber *reqColIdx,
+		bool adjust_tlist_in_place, int *p_numsortkeys,
+		AttrNumber **p_sortColIdx, Oid **p_sortOperators, Oid **p_collations,
+		bool **p_nullsFirst);
 static EquivalenceMember *find_ec_member_for_tle(EquivalenceClass *ec,
-					   TargetEntry *tle,
-					   Relids relids);
+		TargetEntry *tle, Relids relids);
 static Material *make_material(Plan *lefttree);
-
+static void print_injected_cost(const char *rel, int rows,double old_cost,  double cost_result);
+static int get_base_rows_from_memo(char *name, int level);
+static int get_join_rows_from_memo(char *name, int level);
+FILE *file;
 
 /*
  * create_plan
@@ -184,9 +166,8 @@ static Material *make_material(Plan *lefttree);
  *	  Returns a Plan tree.
  */
 Plan *
-create_plan(PlannerInfo *root, Path *best_path)
-{
-	Plan	   *plan;
+create_plan(PlannerInfo *root, Path *best_path) {
+	Plan *plan;
 
 	/* plan_params should not be in use in current query level */
 	Assert(root->plan_params == NIL);
@@ -195,9 +176,14 @@ create_plan(PlannerInfo *root, Path *best_path)
 	root->curOuterRels = NULL;
 	root->curOuterParams = NIL;
 
+	mode_cost_check = enable_cost_check;
+	if (enable_cost_check)
+
+		file = AllocateFile("injected_durations.txt", "ab");
+
 	/* Recursively process the path tree */
 	plan = create_plan_recurse(root, best_path);
-
+	mode_cost_check = false; // reset cost var
 	/* Check we successfully assigned all NestLoopParams to plan nodes */
 	if (root->curOuterParams != NIL)
 		elog(ERROR, "failed to assign all NestLoopParams to plan nodes");
@@ -206,6 +192,7 @@ create_plan(PlannerInfo *root, Path *best_path)
 	 * Reset plan_params to ensure param IDs used for nestloop params are not
 	 * re-used later
 	 */
+
 	root->plan_params = NIL;
 
 	return plan;
@@ -216,56 +203,47 @@ create_plan(PlannerInfo *root, Path *best_path)
  *	  Recursive guts of create_plan().
  */
 static Plan *
-create_plan_recurse(PlannerInfo *root, Path *best_path)
-{
-	Plan	   *plan;
-
-	switch (best_path->pathtype)
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			plan = create_scan_plan(root, best_path);
-			break;
-		case T_HashJoin:
-		case T_MergeJoin:
-		case T_NestLoop:
-			plan = create_join_plan(root,
-									(JoinPath *) best_path);
-			break;
-		case T_Append:
-			plan = create_append_plan(root,
-									  (AppendPath *) best_path);
-			break;
-		case T_MergeAppend:
-			plan = create_merge_append_plan(root,
-											(MergeAppendPath *) best_path);
-			break;
-		case T_Result:
-			plan = (Plan *) create_result_plan(root,
-											   (ResultPath *) best_path);
-			break;
-		case T_Material:
-			plan = (Plan *) create_material_plan(root,
-												 (MaterialPath *) best_path);
-			break;
-		case T_Unique:
-			plan = create_unique_plan(root,
-									  (UniquePath *) best_path);
-			break;
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
+create_plan_recurse(PlannerInfo *root, Path *best_path) {
+	Plan *plan;
+
+	switch (best_path->pathtype) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		plan = create_scan_plan(root, best_path);
+		break;
+	case T_HashJoin:
+	case T_MergeJoin:
+	case T_NestLoop:
+		plan = create_join_plan(root, (JoinPath *) best_path);
+		break;
+	case T_Append:
+		plan = create_append_plan(root, (AppendPath *) best_path);
+		break;
+	case T_MergeAppend:
+		plan = create_merge_append_plan(root, (MergeAppendPath *) best_path);
+		break;
+	case T_Result:
+		plan = (Plan *) create_result_plan(root, (ResultPath *) best_path);
+		break;
+	case T_Material:
+		plan = (Plan *) create_material_plan(root, (MaterialPath *) best_path);
+		break;
+	case T_Unique:
+		plan = create_unique_plan(root, (UniquePath *) best_path);
+		break;
+	default:
+		elog(ERROR, "unrecognized node type: %d", (int) best_path->pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 	}
 
 	return plan;
@@ -276,12 +254,15 @@ create_plan_recurse(PlannerInfo *root, Path *best_path)
  *	 Create a scan plan for the parent relation of 'best_path'.
  */
 static Plan *
-create_scan_plan(PlannerInfo *root, Path *best_path)
-{
+create_scan_plan(PlannerInfo *root, Path *best_path) {
+
+	List *tlist;
+	List *scan_clauses;
+	Plan *plan;
 	RelOptInfo *rel = best_path->parent;
-	List	   *tlist;
-	List	   *scan_clauses;
-	Plan	   *plan;
+	int nrows;
+	double mcost = -1;
+
 
 	/*
 	 * For table scans, rather than using the relation targetlist (which is
@@ -291,23 +272,18 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 * planner.c may replace the tlist we generate here, forcing projection to
 	 * occur.)
 	 */
-	if (use_physical_tlist(root, rel))
-	{
-		if (best_path->pathtype == T_IndexOnlyScan)
-		{
+	if (use_physical_tlist(root, rel)) {
+		if (best_path->pathtype == T_IndexOnlyScan) {
 			/* For index-only scan, the preferred tlist is the index's */
-			tlist = copyObject(((IndexPath *) best_path)->indexinfo->indextlist);
-		}
-		else
-		{
+			tlist = copyObject(
+					((IndexPath *) best_path)->indexinfo->indextlist);
+		} else {
 			tlist = build_physical_tlist(root, rel);
 			/* if fail because of dropped cols, use regular method */
 			if (tlist == NIL)
 				tlist = build_path_tlist(root, best_path);
 		}
-	}
-	else
-	{
+	} else {
 		tlist = build_path_tlist(root, best_path);
 	}
 
@@ -326,94 +302,123 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 */
 	if (best_path->param_info)
 		scan_clauses = list_concat(list_copy(scan_clauses),
-								   best_path->param_info->ppi_clauses);
-
-	switch (best_path->pathtype)
-	{
-		case T_SeqScan:
-			plan = (Plan *) create_seqscan_plan(root,
-												best_path,
-												tlist,
-												scan_clauses);
-			break;
-
-		case T_IndexScan:
-			plan = (Plan *) create_indexscan_plan(root,
-												  (IndexPath *) best_path,
-												  tlist,
-												  scan_clauses,
-												  false);
-			break;
-
-		case T_IndexOnlyScan:
-			plan = (Plan *) create_indexscan_plan(root,
-												  (IndexPath *) best_path,
-												  tlist,
-												  scan_clauses,
-												  true);
-			break;
+				best_path->param_info->ppi_clauses);
+	if (enable_cost_check) {
+		nrows = get_base_rows_from_memo(rel->rel_name, root->query_level);
+	}
 
-		case T_BitmapHeapScan:
-			plan = (Plan *) create_bitmap_scan_plan(root,
-												(BitmapHeapPath *) best_path,
-													tlist,
-													scan_clauses);
-			break;
+	switch (best_path->pathtype) {
+	case T_SeqScan:
+		plan = (Plan *) create_seqscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_seqscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
 
-		case T_TidScan:
-			plan = (Plan *) create_tidscan_plan(root,
-												(TidPath *) best_path,
-												tlist,
-												scan_clauses);
-			break;
+		}
+		break;
+
+	case T_IndexScan:
+		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
+				tlist, scan_clauses, false);
+		if (enable_cost_check) {
+			cost_index((IndexPath *) best_path, root,
+					((IndexPath *) best_path)->indexinfo->loop_count);
+			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
+		}
+		break;
+
+	case T_IndexOnlyScan:
+		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
+				tlist, scan_clauses, true);
+		if (enable_cost_check) {
+			cost_index((IndexPath *) best_path, root,
+					((IndexPath *) best_path)->indexinfo->loop_count);
+			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
+		}
+		break;
+
+	case T_BitmapHeapScan:
+		plan = (Plan *) create_bitmap_scan_plan(root,
+				(BitmapHeapPath *) best_path, tlist, scan_clauses);
+		if (enable_cost_check) {
+			cost_bitmap_heap_scan(best_path, root, rel,
+					((BitmapHeapPath *) best_path)->path.param_info,
+					((BitmapHeapPath *) best_path)->bitmapqual,
+					((BitmapHeapPath *) best_path)->loop);
+			mcost = best_path->mtotal_cost;
+		}
 
-		case T_SubqueryScan:
-			plan = (Plan *) create_subqueryscan_plan(root,
-													 best_path,
-													 tlist,
-													 scan_clauses);
-			break;
+		break;
 
-		case T_FunctionScan:
-			plan = (Plan *) create_functionscan_plan(root,
-													 best_path,
-													 tlist,
-													 scan_clauses);
-			break;
+	case T_TidScan:
+		plan = (Plan *) create_tidscan_plan(root, (TidPath *) best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_tidscan(best_path, root, rel,
+					((TidPath *) best_path)->tidquals,
+					((TidPath *) best_path)->path.param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_SubqueryScan:
+		plan = (Plan *) create_subqueryscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_subqueryscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_FunctionScan:
+		plan = (Plan *) create_functionscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_functionscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
 
-		case T_ValuesScan:
-			plan = (Plan *) create_valuesscan_plan(root,
-												   best_path,
-												   tlist,
-												   scan_clauses);
-			break;
+	case T_ValuesScan:
+		plan = (Plan *) create_valuesscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_valuesscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
 
-		case T_CteScan:
-			plan = (Plan *) create_ctescan_plan(root,
-												best_path,
-												tlist,
-												scan_clauses);
-			break;
+		}
+		break;
+
+	case T_CteScan:
+		plan = (Plan *) create_ctescan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_ctescan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_WorkTableScan:
+		plan = (Plan *) create_worktablescan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_ctescan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
 
-		case T_WorkTableScan:
-			plan = (Plan *) create_worktablescan_plan(root,
-													  best_path,
-													  tlist,
-													  scan_clauses);
-			break;
+	case T_ForeignScan:
+		plan = (Plan *) create_foreignscan_plan(root, (ForeignPath *) best_path,
+				tlist, scan_clauses);
+		//costs ???
+		break;
 
-		case T_ForeignScan:
-			plan = (Plan *) create_foreignscan_plan(root,
-													(ForeignPath *) best_path,
-													tlist,
-													scan_clauses);
-			break;
+	default:
+		elog(ERROR, "unrecognized node type: %d", (int) best_path->pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
 	}
 
 	/*
@@ -423,7 +428,9 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 */
 	if (root->hasPseudoConstantQuals)
 		plan = create_gating_plan(root, plan, scan_clauses);
-
+	if (enable_cost_check) {
+		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+	}
 	return plan;
 }
 
@@ -431,17 +438,15 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
  * Build a target list (ie, a list of TargetEntry) for the Path's output.
  */
 static List *
-build_path_tlist(PlannerInfo *root, Path *path)
-{
+build_path_tlist(PlannerInfo *root, Path *path) {
 	RelOptInfo *rel = path->parent;
-	List	   *tlist = NIL;
-	int			resno = 1;
-	ListCell   *v;
+	List *tlist = NIL;
+	int resno = 1;
+	ListCell *v;
 
-	foreach(v, rel->reltargetlist)
-	{
+	foreach(v, rel->reltargetlist) {
 		/* Do we really need to copy here?	Not sure */
-		Node	   *node = (Node *) copyObject(lfirst(v));
+		Node *node = (Node *) copyObject(lfirst(v));
 
 		/*
 		 * If it's a parameterized path, there might be lateral references in
@@ -452,10 +457,8 @@ build_path_tlist(PlannerInfo *root, Path *path)
 		if (path->param_info)
 			node = replace_nestloop_params(root, node);
 
-		tlist = lappend(tlist, makeTargetEntry((Expr *) node,
-											   resno,
-											   NULL,
-											   false));
+		tlist = lappend(tlist,
+				makeTargetEntry((Expr *) node, resno, NULL, false));
 		resno++;
 	}
 	return tlist;
@@ -466,21 +469,17 @@ build_path_tlist(PlannerInfo *root, Path *path)
  *		Decide whether to use a tlist matching relation structure,
  *		rather than only those Vars actually referenced.
  */
-static bool
-use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
-{
-	int			i;
-	ListCell   *lc;
+static bool use_physical_tlist(PlannerInfo *root, RelOptInfo *rel) {
+	int i;
+	ListCell *lc;
 
 	/*
 	 * We can do this for real relation scans, subquery scans, function scans,
 	 * values scans, and CTE scans (but not for, eg, joins).
 	 */
-	if (rel->rtekind != RTE_RELATION &&
-		rel->rtekind != RTE_SUBQUERY &&
-		rel->rtekind != RTE_FUNCTION &&
-		rel->rtekind != RTE_VALUES &&
-		rel->rtekind != RTE_CTE)
+	if (rel->rtekind != RTE_RELATION && rel->rtekind != RTE_SUBQUERY
+			&& rel->rtekind != RTE_FUNCTION && rel->rtekind != RTE_VALUES
+			&& rel->rtekind != RTE_CTE)
 		return false;
 
 	/*
@@ -495,8 +494,7 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
 	 * (This could possibly be fixed but would take some fragile assumptions
 	 * in setrefs.c, I think.)
 	 */
-	for (i = rel->min_attr; i <= 0; i++)
-	{
+	for (i = rel->min_attr; i <= 0; i++) {
 		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr]))
 			return false;
 	}
@@ -504,13 +502,11 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
 	/*
 	 * Can't do it if the rel is required to emit any placeholder expressions,
 	 * either.
-	 */
-	foreach(lc, root->placeholder_list)
-	{
+	 */foreach(lc, root->placeholder_list) {
 		PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);
 
-		if (bms_nonempty_difference(phinfo->ph_needed, rel->relids) &&
-			bms_is_subset(phinfo->ph_eval_at, rel->relids))
+		if (bms_nonempty_difference(phinfo->ph_needed, rel->relids)
+				&& bms_is_subset(phinfo->ph_eval_at, rel->relids))
 			return false;
 	}
 
@@ -526,27 +522,24 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
  * undo the decision made by use_physical_tlist().	Currently, Hash, Sort,
  * and Material nodes want this, so they don't have to store useless columns.
  */
-static void
-disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path)
-{
+static void disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path) {
 	/* Only need to undo it for path types handled by create_scan_plan() */
-	switch (path->pathtype)
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			plan->targetlist = build_path_tlist(root, path);
-			break;
-		default:
-			break;
+	switch (path->pathtype) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		plan->targetlist = build_path_tlist(root, path);
+		break;
+	default:
+		break;
 	}
 }
 
@@ -570,9 +563,8 @@ disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path)
  * qual being true.
  */
 static Plan *
-create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
-{
-	List	   *pseudoconstants;
+create_gating_plan(PlannerInfo *root, Plan *plan, List *quals) {
+	List *pseudoconstants;
 
 	/* Sort into desirable execution order while still in RestrictInfo form */
 	quals = order_qual_clauses(root, quals);
@@ -583,10 +575,8 @@ create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
 	if (!pseudoconstants)
 		return plan;
 
-	return (Plan *) make_result(root,
-								plan->targetlist,
-								(Node *) pseudoconstants,
-								plan);
+	return (Plan *) make_result(root, plan->targetlist,
+			(Node *) pseudoconstants, plan);
 }
 
 /*
@@ -595,51 +585,82 @@ create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
  *	  inner and outer paths.
  */
 static Plan *
-create_join_plan(PlannerInfo *root, JoinPath *best_path)
-{
-	Plan	   *outer_plan;
-	Plan	   *inner_plan;
-	Plan	   *plan;
-	Relids		saveOuterRels = root->curOuterRels;
+create_join_plan(PlannerInfo *root, JoinPath *best_path) {
+	Plan *outer_plan;
+	Plan *inner_plan;
+	Plan *plan;
+	Relids saveOuterRels = root->curOuterRels;
+	RelOptInfo *rel = best_path->path.parent;
+	int nrows;
+	double mcost = -1;
 
 	outer_plan = create_plan_recurse(root, best_path->outerjoinpath);
 
 	/* For a nestloop, include outer relids in curOuterRels for inner side */
 	if (best_path->path.pathtype == T_NestLoop)
 		root->curOuterRels = bms_union(root->curOuterRels,
-								   best_path->outerjoinpath->parent->relids);
+				best_path->outerjoinpath->parent->relids);
 
 	inner_plan = create_plan_recurse(root, best_path->innerjoinpath);
+	if (enable_cost_check) {
+		nrows = get_join_rows_from_memo(rel->rel_name, root->query_level);
+	}
+	switch (best_path->path.pathtype) {
+	case T_MergeJoin:
+		plan = (Plan *) create_mergejoin_plan(root, (MergePath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check) {
+			initial_cost_mergejoin(root, rel->workspace,
+					((MergePath *) best_path)->jpath.jointype,
+					((MergePath *) best_path)->path_mergeclauses,
+					((MergePath *) best_path)->jpath.outerjoinpath,
+					((MergePath *) best_path)->jpath.innerjoinpath,
+					((MergePath *) best_path)->outersortkeys,
+					((MergePath *) best_path)->innersortkeys, NULL);
+			final_cost_mergejoin(root, (MergePath *) best_path, rel->workspace,
+					NULL);
+			mcost = ((MergePath *) best_path)->jpath.path.mtotal_cost;
 
-	switch (best_path->path.pathtype)
-	{
-		case T_MergeJoin:
-			plan = (Plan *) create_mergejoin_plan(root,
-												  (MergePath *) best_path,
-												  outer_plan,
-												  inner_plan);
-			break;
-		case T_HashJoin:
-			plan = (Plan *) create_hashjoin_plan(root,
-												 (HashPath *) best_path,
-												 outer_plan,
-												 inner_plan);
-			break;
-		case T_NestLoop:
-			/* Restore curOuterRels */
-			bms_free(root->curOuterRels);
-			root->curOuterRels = saveOuterRels;
-
-			plan = (Plan *) create_nestloop_plan(root,
-												 (NestPath *) best_path,
-												 outer_plan,
-												 inner_plan);
-			break;
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->path.pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
+		}
+		break;
+	case T_HashJoin:
+		plan = (Plan *) create_hashjoin_plan(root, (HashPath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check ) {
+			initial_cost_hashjoin(root, rel->workspace,
+					((HashPath *) best_path)->jpath.jointype,
+					((HashPath *) best_path)->path_hashclauses,
+					((HashPath *) best_path)->jpath.outerjoinpath,
+					((HashPath *) best_path)->jpath.innerjoinpath, NULL,
+					rel->workspace->semifactors);
+			final_cost_hashjoin(root, (HashPath *) best_path, rel->workspace,
+					NULL, rel->workspace->semifactors);
+
+			mcost = ((HashPath *) best_path)->jpath.path.mtotal_cost;
+		}
+		break;
+	case T_NestLoop:
+		/* Restore curOuterRels */
+		bms_free(root->curOuterRels);
+		root->curOuterRels = saveOuterRels;
+
+		plan = (Plan *) create_nestloop_plan(root, (NestPath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check ) {
+			initial_cost_nestloop(root, rel->workspace, best_path->jointype,
+					best_path->outerjoinpath, best_path->innerjoinpath, NULL,
+					rel->workspace->semifactors);
+			final_cost_nestloop(root, best_path, rel->workspace, NULL,
+					rel->workspace->semifactors);
+
+			mcost = best_path->path.mtotal_cost;
+		}
+		break;
+	default:
+		elog(ERROR,
+				"unrecognized node type: %d", (int) best_path->path.pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 	}
 
 	/*
@@ -658,11 +679,14 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path)
 	 * 6/15/92
 	 */
 	if (get_loc_restrictinfo(best_path) != NIL)
-		set_qpqual((Plan) plan,
-				   list_concat(get_qpqual((Plan) plan),
-					   get_actual_clauses(get_loc_restrictinfo(best_path))));
+	set_qpqual((Plan) plan,
+			list_concat(get_qpqual((Plan) plan),
+					get_actual_clauses(get_loc_restrictinfo(best_path))));
 #endif
 
+	if (enable_cost_check) {
+		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+	}
 	return plan;
 }
 
@@ -674,12 +698,12 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_append_plan(PlannerInfo *root, AppendPath *best_path)
-{
-	Append	   *plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *subplans = NIL;
-	ListCell   *subpaths;
+create_append_plan(PlannerInfo *root, AppendPath *best_path) {
+	Append *plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *subplans = NIL;
+	ListCell *subpaths;
+//	RelOptInfo *rel = best_path->path.parent;
 
 	/*
 	 * The subpaths list could be empty, if every child was proven empty by
@@ -690,20 +714,15 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
 	 * cases where there was no appending construct at all, but we know the
 	 * relation is empty (see set_dummy_rel_pathlist).
 	 */
-	if (best_path->subpaths == NIL)
-	{
+	if (best_path->subpaths == NIL) {
 		/* Generate a Result plan with constant-FALSE gating qual */
-		return (Plan *) make_result(root,
-									tlist,
-									(Node *) list_make1(makeBoolConst(false,
-																	  false)),
-									NULL);
+		return (Plan *) make_result(root, tlist,
+				(Node *) list_make1(makeBoolConst(false,
+								false)), NULL);
 	}
 
-	/* Build the plan for each child */
-	foreach(subpaths, best_path->subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(subpaths);
+	/* Build the plan for each child */foreach(subpaths, best_path->subpaths) {
+		Path *subpath = (Path *) lfirst(subpaths);
 
 		subplans = lappend(subplans, create_plan_recurse(root, subpath));
 	}
@@ -717,6 +736,7 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
 
 	plan = make_append(subplans, tlist);
 
+
 	return (Plan *) plan;
 }
 
@@ -728,14 +748,13 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
-{
+create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path) {
 	MergeAppend *node = makeNode(MergeAppend);
-	Plan	   *plan = &node->plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *pathkeys = best_path->path.pathkeys;
-	List	   *subplans = NIL;
-	ListCell   *subpaths;
+	Plan *plan = &node->plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *pathkeys = best_path->path.pathkeys;
+	List *subplans = NIL;
+	ListCell *subpaths;
 
 	/*
 	 * We don't have the actual creation of the MergeAppend node split out
@@ -751,43 +770,30 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
 
 	/* Compute sort column info, and adjust MergeAppend's tlist as needed */
 	(void) prepare_sort_from_pathkeys(root, plan, pathkeys,
-									  best_path->path.parent->relids,
-									  NULL,
-									  true,
-									  &node->numCols,
-									  &node->sortColIdx,
-									  &node->sortOperators,
-									  &node->collations,
-									  &node->nullsFirst);
+			best_path->path.parent->relids, NULL, true, &node->numCols,
+			&node->sortColIdx, &node->sortOperators, &node->collations,
+			&node->nullsFirst);
 
 	/*
 	 * Now prepare the child plans.  We must apply prepare_sort_from_pathkeys
 	 * even to subplans that don't need an explicit sort, to make sure they
 	 * are returning the same sort key columns the MergeAppend expects.
-	 */
-	foreach(subpaths, best_path->subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(subpaths);
-		Plan	   *subplan;
-		int			numsortkeys;
+	 */foreach(subpaths, best_path->subpaths) {
+		Path *subpath = (Path *) lfirst(subpaths);
+		Plan *subplan;
+		int numsortkeys;
 		AttrNumber *sortColIdx;
-		Oid		   *sortOperators;
-		Oid		   *collations;
-		bool	   *nullsFirst;
+		Oid *sortOperators;
+		Oid *collations;
+		bool *nullsFirst;
 
 		/* Build the child plan */
 		subplan = create_plan_recurse(root, subpath);
 
 		/* Compute sort column info, and adjust subplan's tlist as needed */
 		subplan = prepare_sort_from_pathkeys(root, subplan, pathkeys,
-											 subpath->parent->relids,
-											 node->sortColIdx,
-											 false,
-											 &numsortkeys,
-											 &sortColIdx,
-											 &sortOperators,
-											 &collations,
-											 &nullsFirst);
+				subpath->parent->relids, node->sortColIdx, false, &numsortkeys,
+				&sortColIdx, &sortOperators, &collations, &nullsFirst);
 
 		/*
 		 * Check that we got the same sort key information.  We just Assert
@@ -797,27 +803,28 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
 		 */
 		Assert(numsortkeys == node->numCols);
 		if (memcmp(sortColIdx, node->sortColIdx,
-				   numsortkeys * sizeof(AttrNumber)) != 0)
-			elog(ERROR, "MergeAppend child's targetlist doesn't match MergeAppend");
-		Assert(memcmp(sortOperators, node->sortOperators,
-					  numsortkeys * sizeof(Oid)) == 0);
-		Assert(memcmp(collations, node->collations,
-					  numsortkeys * sizeof(Oid)) == 0);
-		Assert(memcmp(nullsFirst, node->nullsFirst,
-					  numsortkeys * sizeof(bool)) == 0);
+				numsortkeys * sizeof(AttrNumber)) != 0)
+			elog(ERROR,
+					"MergeAppend child's targetlist doesn't match MergeAppend");
+		Assert(
+				memcmp(sortOperators, node->sortOperators, numsortkeys * sizeof(Oid)) == 0);
+		Assert(
+				memcmp(collations, node->collations, numsortkeys * sizeof(Oid)) == 0);
+		Assert(
+				memcmp(nullsFirst, node->nullsFirst, numsortkeys * sizeof(bool)) == 0);
 
 		/* Now, insert a Sort node if subplan isn't sufficiently ordered */
 		if (!pathkeys_contained_in(pathkeys, subpath->pathkeys))
-			subplan = (Plan *) make_sort(root, subplan, numsortkeys,
-										 sortColIdx, sortOperators,
-										 collations, nullsFirst,
-										 best_path->limit_tuples);
+			subplan = (Plan *) make_sort(root, subplan, numsortkeys, sortColIdx,
+					sortOperators, collations, nullsFirst,
+					best_path->limit_tuples);
 
 		subplans = lappend(subplans, subplan);
 	}
 
 	node->mergeplans = subplans;
 
+
 	return (Plan *) node;
 }
 
@@ -829,10 +836,9 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
  *	  Returns a Plan node.
  */
 static Result *
-create_result_plan(PlannerInfo *root, ResultPath *best_path)
-{
-	List	   *tlist;
-	List	   *quals;
+create_result_plan(PlannerInfo *root, ResultPath *best_path) {
+	List *tlist;
+	List *quals;
 
 	/* The tlist will be installed later, since we have no RelOptInfo */
 	Assert(best_path->path.parent == NULL);
@@ -842,6 +848,7 @@ create_result_plan(PlannerInfo *root, ResultPath *best_path)
 
 	quals = order_qual_clauses(root, best_path->quals);
 
+
 	return make_result(root, tlist, (Node *) quals, NULL);
 }
 
@@ -853,10 +860,9 @@ create_result_plan(PlannerInfo *root, ResultPath *best_path)
  *	  Returns a Plan node.
  */
 static Material *
-create_material_plan(PlannerInfo *root, MaterialPath *best_path)
-{
-	Material   *plan;
-	Plan	   *subplan;
+create_material_plan(PlannerInfo *root, MaterialPath *best_path) {
+	Material *plan;
+	Plan *subplan;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
 
@@ -878,19 +884,18 @@ create_material_plan(PlannerInfo *root, MaterialPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_unique_plan(PlannerInfo *root, UniquePath *best_path)
-{
-	Plan	   *plan;
-	Plan	   *subplan;
-	List	   *in_operators;
-	List	   *uniq_exprs;
-	List	   *newtlist;
-	int			nextresno;
-	bool		newitems;
-	int			numGroupCols;
+create_unique_plan(PlannerInfo *root, UniquePath *best_path) {
+	Plan *plan;
+	Plan *subplan;
+	List *in_operators;
+	List *uniq_exprs;
+	List *newtlist;
+	int nextresno;
+	bool newitems;
+	int numGroupCols;
 	AttrNumber *groupColIdx;
-	int			groupColPos;
-	ListCell   *l;
+	int groupColPos;
+	ListCell *l;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
 
@@ -922,33 +927,27 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	nextresno = list_length(newtlist) + 1;
 	newitems = false;
 
-	foreach(l, uniq_exprs)
-	{
-		Node	   *uniqexpr = lfirst(l);
+	foreach(l, uniq_exprs) {
+		Node *uniqexpr = lfirst(l);
 		TargetEntry *tle;
 
 		tle = tlist_member(uniqexpr, newtlist);
-		if (!tle)
-		{
-			tle = makeTargetEntry((Expr *) uniqexpr,
-								  nextresno,
-								  NULL,
-								  false);
+		if (!tle) {
+			tle = makeTargetEntry((Expr *) uniqexpr, nextresno, NULL, false);
 			newtlist = lappend(newtlist, tle);
 			nextresno++;
 			newitems = true;
 		}
 	}
 
-	if (newitems || best_path->umethod == UNIQUE_PATH_SORT)
-	{
+	if (newitems || best_path->umethod == UNIQUE_PATH_SORT) {
 		/*
 		 * If the top plan node can't do projections and its existing target
 		 * list isn't already what we need, we need to add a Result node to
 		 * help it along.
 		 */
-		if (!is_projection_capable_plan(subplan) &&
-			!tlist_same_exprs(newtlist, subplan->targetlist))
+		if (!is_projection_capable_plan(subplan)
+				&& !tlist_same_exprs(newtlist, subplan->targetlist))
 			subplan = (Plan *) make_result(root, newtlist, NULL, subplan);
 		else
 			subplan->targetlist = newtlist;
@@ -965,21 +964,19 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	groupColIdx = (AttrNumber *) palloc(numGroupCols * sizeof(AttrNumber));
 
 	groupColPos = 0;
-	foreach(l, uniq_exprs)
-	{
-		Node	   *uniqexpr = lfirst(l);
+	foreach(l, uniq_exprs) {
+		Node *uniqexpr = lfirst(l);
 		TargetEntry *tle;
 
 		tle = tlist_member(uniqexpr, newtlist);
-		if (!tle)				/* shouldn't happen */
+		if (!tle) /* shouldn't happen */
 			elog(ERROR, "failed to find unique expression in subplan tlist");
 		groupColIdx[groupColPos++] = tle->resno;
 	}
 
-	if (best_path->umethod == UNIQUE_PATH_HASH)
-	{
-		long		numGroups;
-		Oid		   *groupOperators;
+	if (best_path->umethod == UNIQUE_PATH_HASH) {
+		long numGroups;
+		Oid *groupOperators;
 
 		numGroups = (long) Min(best_path->path.rows, (double) LONG_MAX);
 
@@ -991,14 +988,13 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 		 */
 		groupOperators = (Oid *) palloc(numGroupCols * sizeof(Oid));
 		groupColPos = 0;
-		foreach(l, in_operators)
-		{
-			Oid			in_oper = lfirst_oid(l);
-			Oid			eq_oper;
+		foreach(l, in_operators) {
+			Oid in_oper = lfirst_oid(l);
+			Oid eq_oper;
 
 			if (!get_compatible_hash_operators(in_oper, NULL, &eq_oper))
-				elog(ERROR, "could not find compatible hash operator for operator %u",
-					 in_oper);
+				elog(ERROR,
+						"could not find compatible hash operator for operator %u", in_oper);
 			groupOperators[groupColPos++] = eq_oper;
 		}
 
@@ -1007,35 +1003,25 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 		 * minimum output tlist, without any stuff we might have added to the
 		 * subplan tlist.
 		 */
-		plan = (Plan *) make_agg(root,
-								 build_path_tlist(root, &best_path->path),
-								 NIL,
-								 AGG_HASHED,
-								 NULL,
-								 numGroupCols,
-								 groupColIdx,
-								 groupOperators,
-								 numGroups,
-								 subplan);
-	}
-	else
-	{
-		List	   *sortList = NIL;
+		plan = (Plan *) make_agg(root, build_path_tlist(root, &best_path->path),
+				NIL, AGG_HASHED, NULL, numGroupCols, groupColIdx,
+				groupOperators, numGroups, subplan);
+	} else {
+		List *sortList = NIL;
 
 		/* Create an ORDER BY list to sort the input compatibly */
 		groupColPos = 0;
-		foreach(l, in_operators)
-		{
-			Oid			in_oper = lfirst_oid(l);
-			Oid			sortop;
-			Oid			eqop;
+		foreach(l, in_operators) {
+			Oid in_oper = lfirst_oid(l);
+			Oid sortop;
+			Oid eqop;
 			TargetEntry *tle;
 			SortGroupClause *sortcl;
 
 			sortop = get_ordering_op_for_equality_op(in_oper, false);
-			if (!OidIsValid(sortop))	/* shouldn't happen */
-				elog(ERROR, "could not find ordering operator for equality operator %u",
-					 in_oper);
+			if (!OidIsValid(sortop)) /* shouldn't happen */
+				elog(ERROR,
+						"could not find ordering operator for equality operator %u", in_oper);
 
 			/*
 			 * The Unique node will need equality operators.  Normally these
@@ -1044,21 +1030,21 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 			 * for the IN clause operators' RHS datatype.
 			 */
 			eqop = get_equality_op_for_ordering_op(sortop, NULL);
-			if (!OidIsValid(eqop))		/* shouldn't happen */
-				elog(ERROR, "could not find equality operator for ordering operator %u",
-					 sortop);
+			if (!OidIsValid(eqop)) /* shouldn't happen */
+				elog(ERROR,
+						"could not find equality operator for ordering operator %u", sortop);
 
 			tle = get_tle_by_resno(subplan->targetlist,
-								   groupColIdx[groupColPos]);
+					groupColIdx[groupColPos]);
 			Assert(tle != NULL);
 
 			sortcl = makeNode(SortGroupClause);
 			sortcl->tleSortGroupRef = assignSortGroupRef(tle,
-														 subplan->targetlist);
+					subplan->targetlist);
 			sortcl->eqop = eqop;
 			sortcl->sortop = sortop;
 			sortcl->nulls_first = false;
-			sortcl->hashable = false;	/* no need to make this accurate */
+			sortcl->hashable = false; /* no need to make this accurate */
 			sortList = lappend(sortList, sortcl);
 			groupColPos++;
 		}
@@ -1072,25 +1058,23 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	return plan;
 }
 
-
 /*****************************************************************************
  *
  *	BASE-RELATION SCAN METHODS
  *
  *****************************************************************************/
 
-
 /*
  * create_seqscan_plan
  *	 Returns a seqscan plan for the base relation scanned by 'best_path'
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static SeqScan *
-create_seqscan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses)
-{
-	SeqScan    *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+create_seqscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
+	SeqScan *scan_plan;
+	Index scan_relid = best_path->parent->relid;
+	RelOptInfo *rel = best_path->parent;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1103,15 +1087,13 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
-	scan_plan = make_seqscan(tlist,
-							 scan_clauses,
-							 scan_relid);
+	scan_plan = make_seqscan(tlist, scan_clauses, scan_relid);
+	cost_seqscan(best_path, root, rel, best_path->param_info);
 
 	copy_path_costsize(&scan_plan->plan, best_path);
 
@@ -1129,22 +1111,18 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
  * create_bitmap_subplan needs to be able to override the prior decision.
  */
 static Scan *
-create_indexscan_plan(PlannerInfo *root,
-					  IndexPath *best_path,
-					  List *tlist,
-					  List *scan_clauses,
-					  bool indexonly)
-{
-	Scan	   *scan_plan;
-	List	   *indexquals = best_path->indexquals;
-	List	   *indexorderbys = best_path->indexorderbys;
-	Index		baserelid = best_path->path.parent->relid;
-	Oid			indexoid = best_path->indexinfo->indexoid;
-	List	   *qpqual;
-	List	   *stripped_indexquals;
-	List	   *fixed_indexquals;
-	List	   *fixed_indexorderbys;
-	ListCell   *l;
+create_indexscan_plan(PlannerInfo *root, IndexPath *best_path, List *tlist,
+		List *scan_clauses, bool indexonly) {
+	Scan *scan_plan;
+	List *indexquals = best_path->indexquals;
+	List *indexorderbys = best_path->indexorderbys;
+	Index baserelid = best_path->path.parent->relid;
+	Oid indexoid = best_path->indexinfo->indexoid;
+	List *qpqual;
+	List *stripped_indexquals;
+	List *fixed_indexquals;
+	List *fixed_indexorderbys;
+	ListCell *l;
 
 	/* it should be a base rel... */
 	Assert(baserelid > 0);
@@ -1198,30 +1176,26 @@ create_indexscan_plan(PlannerInfo *root,
 	 * plan so that they'll be properly rechecked by EvalPlanQual testing.
 	 */
 	qpqual = NIL;
-	foreach(l, scan_clauses)
-	{
+	foreach(l, scan_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 		Assert(IsA(rinfo, RestrictInfo));
 		if (rinfo->pseudoconstant)
-			continue;			/* we may drop pseudoconstants here */
+			continue; /* we may drop pseudoconstants here */
 		if (list_member_ptr(indexquals, rinfo))
-			continue;			/* simple duplicate */
+			continue; /* simple duplicate */
 		if (is_redundant_derived_clause(rinfo, indexquals))
-			continue;			/* derived from same EquivalenceClass */
-		if (!contain_mutable_functions((Node *) rinfo->clause))
-		{
-			List	   *clausel = list_make1(rinfo->clause);
+			continue; /* derived from same EquivalenceClass */
+		if (!contain_mutable_functions((Node *) rinfo->clause)) {
+			List *clausel = list_make1(rinfo->clause);
 
 			if (predicate_implied_by(clausel, indexquals))
-				continue;		/* provably implied by indexquals */
-			if (best_path->indexinfo->indpred)
-			{
-				if (baserelid != root->parse->resultRelation &&
-					get_parse_rowmark(root->parse, baserelid) == NULL)
-					if (predicate_implied_by(clausel,
-											 best_path->indexinfo->indpred))
-						continue;		/* implied by index predicate */
+				continue; /* provably implied by indexquals */
+			if (best_path->indexinfo->indpred) {
+				if (baserelid != root->parse->resultRelation&&
+				get_parse_rowmark(root->parse, baserelid) == NULL)if (predicate_implied_by(clausel,
+								best_path->indexinfo->indpred))
+				continue; /* implied by index predicate */
 			}
 		}
 		qpqual = lappend(qpqual, rinfo);
@@ -1242,37 +1216,25 @@ create_indexscan_plan(PlannerInfo *root,
 	 * it'd break the comparisons to predicates above ... (or would it?  Those
 	 * wouldn't have outer refs)
 	 */
-	if (best_path->path.param_info)
-	{
-		stripped_indexquals = (List *)
-			replace_nestloop_params(root, (Node *) stripped_indexquals);
-		qpqual = (List *)
-			replace_nestloop_params(root, (Node *) qpqual);
-		indexorderbys = (List *)
-			replace_nestloop_params(root, (Node *) indexorderbys);
+	if (best_path->path.param_info) {
+		stripped_indexquals = (List *) replace_nestloop_params(root,
+				(Node *) stripped_indexquals);
+		qpqual = (List *) replace_nestloop_params(root, (Node *) qpqual);
+		indexorderbys = (List *) replace_nestloop_params(root,
+				(Node *) indexorderbys);
 	}
 
 	/* Finally ready to build the plan node */
 	if (indexonly)
-		scan_plan = (Scan *) make_indexonlyscan(tlist,
-												qpqual,
-												baserelid,
-												indexoid,
-												fixed_indexquals,
-												fixed_indexorderbys,
-											best_path->indexinfo->indextlist,
-												best_path->indexscandir);
+		scan_plan = (Scan *) make_indexonlyscan(tlist, qpqual, baserelid,
+				indexoid, fixed_indexquals, fixed_indexorderbys,
+				best_path->indexinfo->indextlist, best_path->indexscandir);
 	else
-		scan_plan = (Scan *) make_indexscan(tlist,
-											qpqual,
-											baserelid,
-											indexoid,
-											fixed_indexquals,
-											stripped_indexquals,
-											fixed_indexorderbys,
-											indexorderbys,
-											best_path->indexscandir);
+		scan_plan = (Scan *) make_indexscan(tlist, qpqual, baserelid, indexoid,
+				fixed_indexquals, stripped_indexquals, fixed_indexorderbys,
+				indexorderbys, best_path->indexscandir);
 
+	cost_index(best_path, root, best_path->indexinfo->loop_count);
 	copy_path_costsize(&scan_plan->plan, &best_path->path);
 
 	return scan_plan;
@@ -1284,18 +1246,15 @@ create_indexscan_plan(PlannerInfo *root,
  *	  with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static BitmapHeapScan *
-create_bitmap_scan_plan(PlannerInfo *root,
-						BitmapHeapPath *best_path,
-						List *tlist,
-						List *scan_clauses)
-{
-	Index		baserelid = best_path->path.parent->relid;
-	Plan	   *bitmapqualplan;
-	List	   *bitmapqualorig;
-	List	   *indexquals;
-	List	   *indexECs;
-	List	   *qpqual;
-	ListCell   *l;
+create_bitmap_scan_plan(PlannerInfo *root, BitmapHeapPath *best_path,
+		List *tlist, List *scan_clauses) {
+	Index baserelid = best_path->path.parent->relid;
+	Plan *bitmapqualplan;
+	List *bitmapqualorig;
+	List *indexquals;
+	List *indexECs;
+	List *qpqual;
+	ListCell *l;
 	BitmapHeapScan *scan_plan;
 
 	/* it should be a base rel... */
@@ -1304,8 +1263,7 @@ create_bitmap_scan_plan(PlannerInfo *root,
 
 	/* Process the bitmapqual tree into a Plan tree and qual lists */
 	bitmapqualplan = create_bitmap_subplan(root, best_path->bitmapqual,
-										   &bitmapqualorig, &indexquals,
-										   &indexECs);
+			&bitmapqualorig, &indexquals, &indexECs);
 
 	/*
 	 * The qpqual list must contain all restrictions not automatically handled
@@ -1333,24 +1291,22 @@ create_bitmap_scan_plan(PlannerInfo *root,
 	 * the scan becomes lossy, so they have to be included in bitmapqualorig.
 	 */
 	qpqual = NIL;
-	foreach(l, scan_clauses)
-	{
+	foreach(l, scan_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
-		Node	   *clause = (Node *) rinfo->clause;
+		Node *clause = (Node *) rinfo->clause;
 
 		Assert(IsA(rinfo, RestrictInfo));
 		if (rinfo->pseudoconstant)
-			continue;			/* we may drop pseudoconstants here */
+			continue; /* we may drop pseudoconstants here */
 		if (list_member(indexquals, clause))
-			continue;			/* simple duplicate */
+			continue; /* simple duplicate */
 		if (rinfo->parent_ec && list_member_ptr(indexECs, rinfo->parent_ec))
-			continue;			/* derived from same EquivalenceClass */
-		if (!contain_mutable_functions(clause))
-		{
-			List	   *clausel = list_make1(clause);
+			continue; /* derived from same EquivalenceClass */
+		if (!contain_mutable_functions(clause)) {
+			List *clausel = list_make1(clause);
 
 			if (predicate_implied_by(clausel, indexquals))
-				continue;		/* provably implied by indexquals */
+				continue; /* provably implied by indexquals */
 		}
 		qpqual = lappend(qpqual, rinfo);
 	}
@@ -1374,20 +1330,15 @@ create_bitmap_scan_plan(PlannerInfo *root,
 	 * the qpqual and bitmapqualorig expressions.  (This was already done for
 	 * expressions attached to plan nodes in the bitmapqualplan tree.)
 	 */
-	if (best_path->path.param_info)
-	{
-		qpqual = (List *)
-			replace_nestloop_params(root, (Node *) qpqual);
-		bitmapqualorig = (List *)
-			replace_nestloop_params(root, (Node *) bitmapqualorig);
+	if (best_path->path.param_info) {
+		qpqual = (List *) replace_nestloop_params(root, (Node *) qpqual);
+		bitmapqualorig = (List *) replace_nestloop_params(root,
+				(Node *) bitmapqualorig);
 	}
 
 	/* Finally ready to build the plan node */
-	scan_plan = make_bitmap_heapscan(tlist,
-									 qpqual,
-									 bitmapqualplan,
-									 bitmapqualorig,
-									 baserelid);
+	scan_plan = make_bitmap_heapscan(tlist, qpqual, bitmapqualplan,
+			bitmapqualorig, baserelid);
 
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
 
@@ -1415,19 +1366,17 @@ create_bitmap_scan_plan(PlannerInfo *root,
  * messy, since we'd have to build new RestrictInfos in many cases.)
  */
 static Plan *
-create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
-					  List **qual, List **indexqual, List **indexECs)
-{
-	Plan	   *plan;
+create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual, List **qual,
+		List **indexqual, List **indexECs) {
+	Plan *plan;
 
-	if (IsA(bitmapqual, BitmapAndPath))
-	{
+	if (IsA(bitmapqual, BitmapAndPath)) {
 		BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;
-		List	   *subplans = NIL;
-		List	   *subquals = NIL;
-		List	   *subindexquals = NIL;
-		List	   *subindexECs = NIL;
-		ListCell   *l;
+		List *subplans = NIL;
+		List *subquals = NIL;
+		List *subindexquals = NIL;
+		List *subindexECs = NIL;
+		ListCell *l;
 
 		/*
 		 * There may well be redundant quals among the subplans, since a
@@ -1435,17 +1384,14 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		 * different index quals.  We don't try exceedingly hard to eliminate
 		 * redundancies, but we do eliminate obvious duplicates by using
 		 * list_concat_unique.
-		 */
-		foreach(l, apath->bitmapquals)
-		{
-			Plan	   *subplan;
-			List	   *subqual;
-			List	   *subindexqual;
-			List	   *subindexEC;
-
-			subplan = create_bitmap_subplan(root, (Path *) lfirst(l),
-											&subqual, &subindexqual,
-											&subindexEC);
+		 */foreach(l, apath->bitmapquals) {
+			Plan *subplan;
+			List *subqual;
+			List *subindexqual;
+			List *subindexEC;
+
+			subplan = create_bitmap_subplan(root, (Path *) lfirst(l), &subqual,
+					&subindexqual, &subindexEC);
 			subplans = lappend(subplans, subplan);
 			subquals = list_concat_unique(subquals, subqual);
 			subindexquals = list_concat_unique(subindexquals, subindexqual);
@@ -1455,22 +1401,20 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		plan = (Plan *) make_bitmap_and(subplans);
 		plan->startup_cost = apath->path.startup_cost;
 		plan->total_cost = apath->path.total_cost;
-		plan->plan_rows =
-			clamp_row_est(apath->bitmapselectivity * apath->path.parent->tuples);
-		plan->plan_width = 0;	/* meaningless */
+		plan->plan_rows = clamp_row_est(
+				apath->bitmapselectivity * apath->path.parent->tuples);
+		plan->plan_width = 0; /* meaningless */
 		*qual = subquals;
 		*indexqual = subindexquals;
 		*indexECs = subindexECs;
-	}
-	else if (IsA(bitmapqual, BitmapOrPath))
-	{
+	} else if (IsA(bitmapqual, BitmapOrPath)) {
 		BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;
-		List	   *subplans = NIL;
-		List	   *subquals = NIL;
-		List	   *subindexquals = NIL;
-		bool		const_true_subqual = false;
-		bool		const_true_subindexqual = false;
-		ListCell   *l;
+		List *subplans = NIL;
+		List *subquals = NIL;
+		List *subindexquals = NIL;
+		bool const_true_subqual = false;
+		bool const_true_subindexqual = false;
+		ListCell *l;
 
 		/*
 		 * Here, we only detect qual-free subplans.  A qual-free subplan would
@@ -1480,46 +1424,39 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		 * well be working with hundreds or even thousands of OR conditions,
 		 * perhaps from a long IN list.  The performance of list_append_unique
 		 * would be unacceptable.
-		 */
-		foreach(l, opath->bitmapquals)
-		{
-			Plan	   *subplan;
-			List	   *subqual;
-			List	   *subindexqual;
-			List	   *subindexEC;
-
-			subplan = create_bitmap_subplan(root, (Path *) lfirst(l),
-											&subqual, &subindexqual,
-											&subindexEC);
+		 */foreach(l, opath->bitmapquals) {
+			Plan *subplan;
+			List *subqual;
+			List *subindexqual;
+			List *subindexEC;
+
+			subplan = create_bitmap_subplan(root, (Path *) lfirst(l), &subqual,
+					&subindexqual, &subindexEC);
 			subplans = lappend(subplans, subplan);
 			if (subqual == NIL)
 				const_true_subqual = true;
 			else if (!const_true_subqual)
-				subquals = lappend(subquals,
-								   make_ands_explicit(subqual));
+				subquals = lappend(subquals, make_ands_explicit(subqual));
 			if (subindexqual == NIL)
 				const_true_subindexqual = true;
 			else if (!const_true_subindexqual)
 				subindexquals = lappend(subindexquals,
-										make_ands_explicit(subindexqual));
+						make_ands_explicit(subindexqual));
 		}
 
 		/*
 		 * In the presence of ScalarArrayOpExpr quals, we might have built
 		 * BitmapOrPaths with just one subpath; don't add an OR step.
 		 */
-		if (list_length(subplans) == 1)
-		{
+		if (list_length(subplans) == 1) {
 			plan = (Plan *) linitial(subplans);
-		}
-		else
-		{
+		} else {
 			plan = (Plan *) make_bitmap_or(subplans);
 			plan->startup_cost = opath->path.startup_cost;
 			plan->total_cost = opath->path.total_cost;
-			plan->plan_rows =
-				clamp_row_est(opath->bitmapselectivity * opath->path.parent->tuples);
-			plan->plan_width = 0;		/* meaningless */
+			plan->plan_rows = clamp_row_est(
+					opath->bitmapselectivity * opath->path.parent->tuples);
+			plan->plan_width = 0; /* meaningless */
 		}
 
 		/*
@@ -1540,33 +1477,28 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		else
 			*indexqual = list_make1(make_orclause(subindexquals));
 		*indexECs = NIL;
-	}
-	else if (IsA(bitmapqual, IndexPath))
-	{
-		IndexPath  *ipath = (IndexPath *) bitmapqual;
-		IndexScan  *iscan;
-		List	   *subindexECs;
-		ListCell   *l;
+	} else if (IsA(bitmapqual, IndexPath)) {
+		IndexPath *ipath = (IndexPath *) bitmapqual;
+		IndexScan *iscan;
+		List *subindexECs;
+		ListCell *l;
 
 		/* Use the regular indexscan plan build machinery... */
-		iscan = (IndexScan *) create_indexscan_plan(root, ipath,
-													NIL, NIL, false);
+		iscan = (IndexScan *) create_indexscan_plan(root, ipath, NIL, NIL,
+				false);
 		Assert(IsA(iscan, IndexScan));
 		/* then convert to a bitmap indexscan */
 		plan = (Plan *) make_bitmap_indexscan(iscan->scan.scanrelid,
-											  iscan->indexid,
-											  iscan->indexqual,
-											  iscan->indexqualorig);
+				iscan->indexid, iscan->indexqual, iscan->indexqualorig);
 		plan->startup_cost = 0.0;
 		plan->total_cost = ipath->indextotalcost;
-		plan->plan_rows =
-			clamp_row_est(ipath->indexselectivity * ipath->path.parent->tuples);
-		plan->plan_width = 0;	/* meaningless */
+		plan->plan_rows = clamp_row_est(
+				ipath->indexselectivity * ipath->path.parent->tuples);
+		plan->plan_width = 0; /* meaningless */
 		*qual = get_actual_clauses(ipath->indexclauses);
 		*indexqual = get_actual_clauses(ipath->indexquals);
-		foreach(l, ipath->indexinfo->indpred)
-		{
-			Expr	   *pred = (Expr *) lfirst(l);
+		foreach(l, ipath->indexinfo->indpred) {
+			Expr *pred = (Expr *) lfirst(l);
 
 			/*
 			 * We know that the index predicate must have been implied by the
@@ -1574,26 +1506,22 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 			 * the conditions that got pushed into the bitmapqual.	Avoid
 			 * generating redundant conditions.
 			 */
-			if (!predicate_implied_by(list_make1(pred), ipath->indexclauses))
-			{
+			if (!predicate_implied_by(list_make1(pred), ipath->indexclauses)) {
 				*qual = lappend(*qual, pred);
 				*indexqual = lappend(*indexqual, pred);
 			}
 		}
 		subindexECs = NIL;
-		foreach(l, ipath->indexquals)
-		{
+		foreach(l, ipath->indexquals) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			if (rinfo->parent_ec)
 				subindexECs = lappend(subindexECs, rinfo->parent_ec);
 		}
 		*indexECs = subindexECs;
-	}
-	else
-	{
+	} else {
 		elog(ERROR, "unrecognized node type: %d", nodeTag(bitmapqual));
-		plan = NULL;			/* keep compiler quiet */
+		plan = NULL; /* keep compiler quiet */
 	}
 
 	return plan;
@@ -1605,13 +1533,13 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static TidScan *
-create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
-					List *tlist, List *scan_clauses)
-{
-	TidScan    *scan_plan;
-	Index		scan_relid = best_path->path.parent->relid;
-	List	   *tidquals = best_path->tidquals;
-	List	   *ortidquals;
+create_tidscan_plan(PlannerInfo *root, TidPath *best_path, List *tlist,
+		List *scan_clauses) {
+	TidScan *scan_plan;
+	Index scan_relid = best_path->path.parent->relid;
+	List *tidquals = best_path->tidquals;
+	List *ortidquals;
+	;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1624,12 +1552,10 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->path.param_info)
-	{
-		tidquals = (List *)
-			replace_nestloop_params(root, (Node *) tidquals);
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->path.param_info) {
+		tidquals = (List *) replace_nestloop_params(root, (Node *) tidquals);
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
 	/*
@@ -1641,10 +1567,7 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
 		ortidquals = list_make1(make_orclause(ortidquals));
 	scan_clauses = list_difference(scan_clauses, ortidquals);
 
-	scan_plan = make_tidscan(tlist,
-							 scan_clauses,
-							 scan_relid,
-							 tidquals);
+	scan_plan = make_tidscan(tlist, scan_clauses, scan_relid, tidquals);
 
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
 
@@ -1657,11 +1580,10 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static SubqueryScan *
-create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses)
-{
+create_subqueryscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	SubqueryScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 
 	/* it should be a subquery base rel... */
 	Assert(scan_relid > 0);
@@ -1674,18 +1596,15 @@ create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		process_subquery_nestloop_params(root,
-										 best_path->parent->subplan_params);
+				best_path->parent->subplan_params);
 	}
 
-	scan_plan = make_subqueryscan(tlist,
-								  scan_clauses,
-								  scan_relid,
-								  best_path->parent->subplan);
+	scan_plan = make_subqueryscan(tlist, scan_clauses, scan_relid,
+			best_path->parent->subplan);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1698,13 +1617,12 @@ create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static FunctionScan *
-create_functionscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses)
-{
+create_functionscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	FunctionScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	List	   *functions;
+	List *functions;
 
 	/* it should be a function base rel... */
 	Assert(scan_relid > 0);
@@ -1719,16 +1637,15 @@ create_functionscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		/* The function expressions could contain nestloop params, too */
 		functions = (List *) replace_nestloop_params(root, (Node *) functions);
 	}
 
-	scan_plan = make_functionscan(tlist, scan_clauses, scan_relid,
-								  functions, rte->funcordinality);
+	scan_plan = make_functionscan(tlist, scan_clauses, scan_relid, functions,
+			rte->funcordinality);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1741,13 +1658,12 @@ create_functionscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static ValuesScan *
-create_valuesscan_plan(PlannerInfo *root, Path *best_path,
-					   List *tlist, List *scan_clauses)
-{
+create_valuesscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	ValuesScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	List	   *values_lists;
+	List *values_lists;
 
 	/* it should be a values base rel... */
 	Assert(scan_relid > 0);
@@ -1762,17 +1678,15 @@ create_valuesscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		/* The values lists could contain nestloop params, too */
-		values_lists = (List *)
-			replace_nestloop_params(root, (Node *) values_lists);
+		values_lists = (List *) replace_nestloop_params(root,
+				(Node *) values_lists);
 	}
 
-	scan_plan = make_valuesscan(tlist, scan_clauses, scan_relid,
-								values_lists);
+	scan_plan = make_valuesscan(tlist, scan_clauses, scan_relid, values_lists);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1785,19 +1699,18 @@ create_valuesscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static CteScan *
-create_ctescan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses)
-{
-	CteScan    *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+create_ctescan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
+	CteScan *scan_plan;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	SubPlan    *ctesplan = NULL;
-	int			plan_id;
-	int			cte_param_id;
+	SubPlan *ctesplan = NULL;
+	int plan_id;
+	int cte_param_id;
 	PlannerInfo *cteroot;
-	Index		levelsup;
-	int			ndx;
-	ListCell   *lc;
+	Index levelsup;
+	int ndx;
+	ListCell *lc;
 
 	Assert(scan_relid > 0);
 	rte = planner_rt_fetch(scan_relid, root);
@@ -1809,10 +1722,9 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	 */
 	levelsup = rte->ctelevelsup;
 	cteroot = root;
-	while (levelsup-- > 0)
-	{
+	while (levelsup-- > 0) {
 		cteroot = cteroot->parent_root;
-		if (!cteroot)			/* shouldn't happen */
+		if (!cteroot) /* shouldn't happen */
 			elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	}
 
@@ -1822,27 +1734,25 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	 * So we mustn't use forboth here.
 	 */
 	ndx = 0;
-	foreach(lc, cteroot->parse->cteList)
-	{
+	foreach(lc, cteroot->parse->cteList) {
 		CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);
 
 		if (strcmp(cte->ctename, rte->ctename) == 0)
 			break;
 		ndx++;
 	}
-	if (lc == NULL)				/* shouldn't happen */
+	if (lc == NULL) /* shouldn't happen */
 		elog(ERROR, "could not find CTE \"%s\"", rte->ctename);
 	if (ndx >= list_length(cteroot->cte_plan_ids))
 		elog(ERROR, "could not find plan for CTE \"%s\"", rte->ctename);
 	plan_id = list_nth_int(cteroot->cte_plan_ids, ndx);
 	Assert(plan_id > 0);
-	foreach(lc, cteroot->init_plans)
-	{
+	foreach(lc, cteroot->init_plans) {
 		ctesplan = (SubPlan *) lfirst(lc);
 		if (ctesplan->plan_id == plan_id)
 			break;
 	}
-	if (lc == NULL)				/* shouldn't happen */
+	if (lc == NULL) /* shouldn't happen */
 		elog(ERROR, "could not find plan for CTE \"%s\"", rte->ctename);
 
 	/*
@@ -1858,15 +1768,14 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
-	scan_plan = make_ctescan(tlist, scan_clauses, scan_relid,
-							 plan_id, cte_param_id);
-
+	scan_plan = make_ctescan(tlist, scan_clauses, scan_relid, plan_id,
+			cte_param_id);
+	cost_ctescan(best_path, root, best_path->parent, best_path->param_info);
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
 	return scan_plan;
@@ -1878,13 +1787,12 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static WorkTableScan *
-create_worktablescan_plan(PlannerInfo *root, Path *best_path,
-						  List *tlist, List *scan_clauses)
-{
+create_worktablescan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	WorkTableScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	Index		levelsup;
+	Index levelsup;
 	PlannerInfo *cteroot;
 
 	Assert(scan_relid > 0);
@@ -1898,17 +1806,16 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
 	 * the CTE comes from.
 	 */
 	levelsup = rte->ctelevelsup;
-	if (levelsup == 0)			/* shouldn't happen */
+	if (levelsup == 0) /* shouldn't happen */
 		elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	levelsup--;
 	cteroot = root;
-	while (levelsup-- > 0)
-	{
+	while (levelsup-- > 0) {
 		cteroot = cteroot->parent_root;
-		if (!cteroot)			/* shouldn't happen */
+		if (!cteroot) /* shouldn't happen */
 			elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	}
-	if (cteroot->wt_param_id < 0)		/* shouldn't happen */
+	if (cteroot->wt_param_id < 0) /* shouldn't happen */
 		elog(ERROR, "could not find param ID for CTE \"%s\"", rte->ctename);
 
 	/* Sort clauses into best execution order */
@@ -1918,14 +1825,13 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
 	scan_plan = make_worktablescan(tlist, scan_clauses, scan_relid,
-								   cteroot->wt_param_id);
+			cteroot->wt_param_id);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1938,14 +1844,13 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static ForeignScan *
-create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
-						List *tlist, List *scan_clauses)
-{
+create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path, List *tlist,
+		List *scan_clauses) {
 	ForeignScan *scan_plan;
 	RelOptInfo *rel = best_path->path.parent;
-	Index		scan_relid = rel->relid;
+	Index scan_relid = rel->relid;
 	RangeTblEntry *rte;
-	int			i;
+	int i;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1967,8 +1872,7 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * rechecked locally).
 	 */
 	scan_plan = rel->fdwroutine->GetForeignPlan(root, rel, rte->relid,
-												best_path,
-												tlist, scan_clauses);
+			best_path, tlist, scan_clauses);
 
 	/* Copy cost data from Path to Plan; no need to make FDW do this */
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
@@ -1980,12 +1884,11 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * from join clauses, so doing this beforehand on the scan_clauses
 	 * wouldn't work.)
 	 */
-	if (best_path->path.param_info)
-	{
-		scan_plan->scan.plan.qual = (List *)
-			replace_nestloop_params(root, (Node *) scan_plan->scan.plan.qual);
-		scan_plan->fdw_exprs = (List *)
-			replace_nestloop_params(root, (Node *) scan_plan->fdw_exprs);
+	if (best_path->path.param_info) {
+		scan_plan->scan.plan.qual = (List *) replace_nestloop_params(root,
+				(Node *) scan_plan->scan.plan.qual);
+		scan_plan->fdw_exprs = (List *) replace_nestloop_params(root,
+				(Node *) scan_plan->fdw_exprs);
 	}
 
 	/*
@@ -1994,10 +1897,8 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * out of the API presented to FDWs.
 	 */
 	scan_plan->fsSystemCol = false;
-	for (i = rel->min_attr; i < 0; i++)
-	{
-		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr]))
-		{
+	for (i = rel->min_attr; i < 0; i++) {
+		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr])) {
 			scan_plan->fsSystemCol = true;
 			break;
 		}
@@ -2006,7 +1907,6 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	return scan_plan;
 }
 
-
 /*****************************************************************************
  *
  *	JOIN METHODS
@@ -2014,46 +1914,39 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
  *****************************************************************************/
 
 static NestLoop *
-create_nestloop_plan(PlannerInfo *root,
-					 NestPath *best_path,
-					 Plan *outer_plan,
-					 Plan *inner_plan)
-{
-	NestLoop   *join_plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *joinrestrictclauses = best_path->joinrestrictinfo;
-	List	   *joinclauses;
-	List	   *otherclauses;
-	Relids		outerrelids;
-	List	   *nestParams;
-	ListCell   *cell;
-	ListCell   *prev;
-	ListCell   *next;
+create_nestloop_plan(PlannerInfo *root, NestPath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	NestLoop *join_plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *joinrestrictclauses = best_path->joinrestrictinfo;
+	List *joinclauses;
+	List *otherclauses;
+	Relids outerrelids;
+	List *nestParams;
+	ListCell *cell;
+	ListCell *prev;
+	ListCell *next;
 
 	/* Sort join qual clauses into best execution order */
 	joinrestrictclauses = order_qual_clauses(root, joinrestrictclauses);
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jointype))
-	{
-		extract_actual_join_clauses(joinrestrictclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jointype)) {
+		extract_actual_join_clauses(joinrestrictclauses, &joinclauses,
+				&otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinrestrictclauses, false);
 		otherclauses = NIL;
 	}
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2063,41 +1956,31 @@ create_nestloop_plan(PlannerInfo *root,
 	outerrelids = best_path->outerjoinpath->parent->relids;
 	nestParams = NIL;
 	prev = NULL;
-	for (cell = list_head(root->curOuterParams); cell; cell = next)
-	{
+	for (cell = list_head(root->curOuterParams); cell; cell = next) {
 		NestLoopParam *nlp = (NestLoopParam *) lfirst(cell);
 
 		next = lnext(cell);
-		if (IsA(nlp->paramval, Var) &&
-			bms_is_member(nlp->paramval->varno, outerrelids))
-		{
-			root->curOuterParams = list_delete_cell(root->curOuterParams,
-													cell, prev);
+		if (IsA(nlp->paramval, Var)
+				&& bms_is_member(nlp->paramval->varno, outerrelids)) {
+			root->curOuterParams = list_delete_cell(root->curOuterParams, cell,
+					prev);
 			nestParams = lappend(nestParams, nlp);
-		}
-		else if (IsA(nlp->paramval, PlaceHolderVar) &&
-				 bms_overlap(((PlaceHolderVar *) nlp->paramval)->phrels,
-							 outerrelids) &&
-				 bms_is_subset(find_placeholder_info(root,
-											(PlaceHolderVar *) nlp->paramval,
-													 false)->ph_eval_at,
-							   outerrelids))
-		{
-			root->curOuterParams = list_delete_cell(root->curOuterParams,
-													cell, prev);
+		} else if (IsA(nlp->paramval, PlaceHolderVar)
+				&& bms_overlap(((PlaceHolderVar *) nlp->paramval)->phrels,
+						outerrelids)
+				&& bms_is_subset(
+						find_placeholder_info(root,
+								(PlaceHolderVar *) nlp->paramval, false)->ph_eval_at,
+						outerrelids)) {
+			root->curOuterParams = list_delete_cell(root->curOuterParams, cell,
+					prev);
 			nestParams = lappend(nestParams, nlp);
-		}
-		else
+		} else
 			prev = cell;
 	}
 
-	join_plan = make_nestloop(tlist,
-							  joinclauses,
-							  otherclauses,
-							  nestParams,
-							  outer_plan,
-							  inner_plan,
-							  best_path->jointype);
+	join_plan = make_nestloop(tlist, joinclauses, otherclauses, nestParams,
+			outer_plan, inner_plan, best_path->jointype);
 
 	copy_path_costsize(&join_plan->join.plan, &best_path->path);
 
@@ -2105,27 +1988,27 @@ create_nestloop_plan(PlannerInfo *root,
 }
 
 static MergeJoin *
-create_mergejoin_plan(PlannerInfo *root,
-					  MergePath *best_path,
-					  Plan *outer_plan,
-					  Plan *inner_plan)
-{
-	List	   *tlist = build_path_tlist(root, &best_path->jpath.path);
-	List	   *joinclauses;
-	List	   *otherclauses;
-	List	   *mergeclauses;
-	List	   *outerpathkeys;
-	List	   *innerpathkeys;
-	int			nClauses;
-	Oid		   *mergefamilies;
-	Oid		   *mergecollations;
-	int		   *mergestrategies;
-	bool	   *mergenullsfirst;
-	MergeJoin  *join_plan;
-	int			i;
-	ListCell   *lc;
-	ListCell   *lop;
-	ListCell   *lip;
+create_mergejoin_plan(PlannerInfo *root, MergePath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	List *tlist = build_path_tlist(root, &best_path->jpath.path);
+	List *joinclauses;
+	List *otherclauses;
+	List *mergeclauses;
+	List *outerpathkeys;
+	List *innerpathkeys;
+//JoinCostWorkspace *workspace =best_path->jpath->path->parent->workspace;
+	int nClauses;
+	Oid *mergefamilies;
+	Oid *mergecollations;
+	int *mergestrategies;
+	bool *mergenullsfirst;
+	MergeJoin *join_plan;
+	int i;
+	ListCell *lc;
+	ListCell *lop;
+	ListCell *lip;
+
+	/* Inject cardinalities for path*/
 
 	/* Sort join qual clauses into best execution order */
 	/* NB: do NOT reorder the mergeclauses */
@@ -2133,13 +2016,9 @@ create_mergejoin_plan(PlannerInfo *root,
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jpath.jointype))
-	{
-		extract_actual_join_clauses(joinclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jpath.jointype)) {
+		extract_actual_join_clauses(joinclauses, &joinclauses, &otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinclauses, false);
 		otherclauses = NIL;
@@ -2156,12 +2035,11 @@ create_mergejoin_plan(PlannerInfo *root,
 	 * Replace any outer-relation variables with nestloop params.  There
 	 * should not be any in the mergeclauses.
 	 */
-	if (best_path->jpath.path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->jpath.path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2170,45 +2048,42 @@ create_mergejoin_plan(PlannerInfo *root,
 	 * outer_is_left status.
 	 */
 	mergeclauses = get_switched_clauses(best_path->path_mergeclauses,
-							 best_path->jpath.outerjoinpath->parent->relids);
+			best_path->jpath.outerjoinpath->parent->relids);
 
 	/*
 	 * Create explicit sort nodes for the outer and inner paths if necessary.
 	 * Make sure there are no excess columns in the inputs if sorting.
 	 */
-	if (best_path->outersortkeys)
-	{
+	if (best_path->outersortkeys) {
 		disuse_physical_tlist(root, outer_plan, best_path->jpath.outerjoinpath);
-		outer_plan = (Plan *)
-			make_sort_from_pathkeys(root,
-									outer_plan,
-									best_path->outersortkeys,
-									-1.0);
+		outer_plan = (Plan *) make_sort_from_pathkeys(root, outer_plan,
+				best_path->outersortkeys, -1.0);
 		outerpathkeys = best_path->outersortkeys;
-	}
-	else
+	} else
 		outerpathkeys = best_path->jpath.outerjoinpath->pathkeys;
 
-	if (best_path->innersortkeys)
-	{
+	if (best_path->innersortkeys) {
 		disuse_physical_tlist(root, inner_plan, best_path->jpath.innerjoinpath);
-		inner_plan = (Plan *)
-			make_sort_from_pathkeys(root,
-									inner_plan,
-									best_path->innersortkeys,
-									-1.0);
+		inner_plan = (Plan *) make_sort_from_pathkeys(root, inner_plan,
+				best_path->innersortkeys, -1.0);
 		innerpathkeys = best_path->innersortkeys;
-	}
-	else
+	} else
 		innerpathkeys = best_path->jpath.innerjoinpath->pathkeys;
 
 	/*
 	 * If specified, add a materialize node to shield the inner plan from the
 	 * need to handle mark/restore.
 	 */
-	if (best_path->materialize_inner)
-	{
-		Plan	   *matplan = (Plan *) make_material(inner_plan);
+	/*
+	 * We recalculate the cost with injection
+	 *
+	 *
+	 * */
+//old_statup_cost = best_path->jpath->path->startup_cost;
+//	old_total_cost= best_path->jpath->path->total_cost;
+// final_cost_mergejoin(root,best_path,workspace,NULL);
+	if (best_path->materialize_inner) {
+		Plan *matplan = (Plan *) make_material(inner_plan);
 
 		/*
 		 * We assume the materialize will not spill to disk, and therefore
@@ -2216,6 +2091,7 @@ create_mergejoin_plan(PlannerInfo *root,
 		 * sync with final_cost_mergejoin.)
 		 */
 		copy_plan_costsize(matplan, inner_plan);
+
 		matplan->total_cost += cpu_operator_cost * matplan->plan_rows;
 
 		inner_plan = matplan;
@@ -2237,26 +2113,22 @@ create_mergejoin_plan(PlannerInfo *root,
 	lop = list_head(outerpathkeys);
 	lip = list_head(innerpathkeys);
 	i = 0;
-	foreach(lc, best_path->path_mergeclauses)
-	{
+	foreach(lc, best_path->path_mergeclauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 		EquivalenceClass *oeclass;
 		EquivalenceClass *ieclass;
-		PathKey    *opathkey;
-		PathKey    *ipathkey;
+		PathKey *opathkey;
+		PathKey *ipathkey;
 		EquivalenceClass *opeclass;
 		EquivalenceClass *ipeclass;
-		ListCell   *l2;
+		ListCell *l2;
 
 		/* fetch outer/inner eclass from mergeclause */
 		Assert(IsA(rinfo, RestrictInfo));
-		if (rinfo->outer_is_left)
-		{
+		if (rinfo->outer_is_left) {
 			oeclass = rinfo->left_ec;
 			ieclass = rinfo->right_ec;
-		}
-		else
-		{
+		} else {
 			oeclass = rinfo->right_ec;
 			ieclass = rinfo->left_ec;
 		}
@@ -2275,20 +2147,15 @@ create_mergejoin_plan(PlannerInfo *root,
 		 * it's okay to match them, or any element before them.  If they're
 		 * NULL then we have found all pathkey elements to be used.
 		 */
-		if (lop)
-		{
+		if (lop) {
 			opathkey = (PathKey *) lfirst(lop);
 			opeclass = opathkey->pk_eclass;
-			if (oeclass == opeclass)
-			{
+			if (oeclass == opeclass) {
 				/* fast path for typical case */
 				lop = lnext(lop);
-			}
-			else
-			{
+			} else {
 				/* redundant clauses ... must match something before lop */
-				foreach(l2, outerpathkeys)
-				{
+				foreach(l2, outerpathkeys) {
 					if (l2 == lop)
 						break;
 					opathkey = (PathKey *) lfirst(l2);
@@ -2299,14 +2166,11 @@ create_mergejoin_plan(PlannerInfo *root,
 				if (oeclass != opeclass)
 					elog(ERROR, "outer pathkeys do not match mergeclauses");
 			}
-		}
-		else
-		{
+		} else {
 			/* redundant clauses ... must match some already-used pathkey */
 			opathkey = NULL;
 			opeclass = NULL;
-			foreach(l2, outerpathkeys)
-			{
+			foreach(l2, outerpathkeys) {
 				opathkey = (PathKey *) lfirst(l2);
 				opeclass = opathkey->pk_eclass;
 				if (oeclass == opeclass)
@@ -2316,20 +2180,15 @@ create_mergejoin_plan(PlannerInfo *root,
 				elog(ERROR, "outer pathkeys do not match mergeclauses");
 		}
 
-		if (lip)
-		{
+		if (lip) {
 			ipathkey = (PathKey *) lfirst(lip);
 			ipeclass = ipathkey->pk_eclass;
-			if (ieclass == ipeclass)
-			{
+			if (ieclass == ipeclass) {
 				/* fast path for typical case */
 				lip = lnext(lip);
-			}
-			else
-			{
+			} else {
 				/* redundant clauses ... must match something before lip */
-				foreach(l2, innerpathkeys)
-				{
+				foreach(l2, innerpathkeys) {
 					if (l2 == lip)
 						break;
 					ipathkey = (PathKey *) lfirst(l2);
@@ -2340,14 +2199,11 @@ create_mergejoin_plan(PlannerInfo *root,
 				if (ieclass != ipeclass)
 					elog(ERROR, "inner pathkeys do not match mergeclauses");
 			}
-		}
-		else
-		{
+		} else {
 			/* redundant clauses ... must match some already-used pathkey */
 			ipathkey = NULL;
 			ipeclass = NULL;
-			foreach(l2, innerpathkeys)
-			{
+			foreach(l2, innerpathkeys) {
 				ipathkey = (PathKey *) lfirst(l2);
 				ipeclass = ipathkey->pk_eclass;
 				if (ieclass == ipeclass)
@@ -2358,10 +2214,11 @@ create_mergejoin_plan(PlannerInfo *root,
 		}
 
 		/* pathkeys should match each other too (more debugging) */
-		if (opathkey->pk_opfamily != ipathkey->pk_opfamily ||
-			opathkey->pk_eclass->ec_collation != ipathkey->pk_eclass->ec_collation ||
-			opathkey->pk_strategy != ipathkey->pk_strategy ||
-			opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
+		if (opathkey->pk_opfamily != ipathkey->pk_opfamily
+				|| opathkey->pk_eclass->ec_collation
+						!= ipathkey->pk_eclass->ec_collation
+				|| opathkey->pk_strategy != ipathkey->pk_strategy
+				|| opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
 			elog(ERROR, "left and right pathkeys do not match in mergejoin");
 
 		/* OK, save info for executor */
@@ -2381,17 +2238,9 @@ create_mergejoin_plan(PlannerInfo *root,
 	/*
 	 * Now we can build the mergejoin node.
 	 */
-	join_plan = make_mergejoin(tlist,
-							   joinclauses,
-							   otherclauses,
-							   mergeclauses,
-							   mergefamilies,
-							   mergecollations,
-							   mergestrategies,
-							   mergenullsfirst,
-							   outer_plan,
-							   inner_plan,
-							   best_path->jpath.jointype);
+	join_plan = make_mergejoin(tlist, joinclauses, otherclauses, mergeclauses,
+			mergefamilies, mergecollations, mergestrategies, mergenullsfirst,
+			outer_plan, inner_plan, best_path->jpath.jointype);
 
 	/* Costs of sort and material steps are included in path cost already */
 	copy_path_costsize(&join_plan->join.plan, &best_path->jpath.path);
@@ -2400,22 +2249,19 @@ create_mergejoin_plan(PlannerInfo *root,
 }
 
 static HashJoin *
-create_hashjoin_plan(PlannerInfo *root,
-					 HashPath *best_path,
-					 Plan *outer_plan,
-					 Plan *inner_plan)
-{
-	List	   *tlist = build_path_tlist(root, &best_path->jpath.path);
-	List	   *joinclauses;
-	List	   *otherclauses;
-	List	   *hashclauses;
-	Oid			skewTable = InvalidOid;
-	AttrNumber	skewColumn = InvalidAttrNumber;
-	bool		skewInherit = false;
-	Oid			skewColType = InvalidOid;
-	int32		skewColTypmod = -1;
-	HashJoin   *join_plan;
-	Hash	   *hash_plan;
+create_hashjoin_plan(PlannerInfo *root, HashPath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	List *tlist = build_path_tlist(root, &best_path->jpath.path);
+	List *joinclauses;
+	List *otherclauses;
+	List *hashclauses;
+	Oid skewTable = InvalidOid;
+	AttrNumber skewColumn = InvalidAttrNumber;
+	bool skewInherit = false;
+	Oid skewColType = InvalidOid;
+	int32 skewColTypmod = -1;
+	HashJoin *join_plan;
+	Hash *hash_plan;
 
 	/* Sort join qual clauses into best execution order */
 	joinclauses = order_qual_clauses(root, best_path->jpath.joinrestrictinfo);
@@ -2423,13 +2269,9 @@ create_hashjoin_plan(PlannerInfo *root,
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jpath.jointype))
-	{
-		extract_actual_join_clauses(joinclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jpath.jointype)) {
+		extract_actual_join_clauses(joinclauses, &joinclauses, &otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinclauses, false);
 		otherclauses = NIL;
@@ -2446,12 +2288,11 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * Replace any outer-relation variables with nestloop params.  There
 	 * should not be any in the hashclauses.
 	 */
-	if (best_path->jpath.path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->jpath.path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2459,7 +2300,7 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * on the left.
 	 */
 	hashclauses = get_switched_clauses(best_path->path_hashclauses,
-							 best_path->jpath.outerjoinpath->parent->relids);
+			best_path->jpath.outerjoinpath->parent->relids);
 
 	/* We don't want any excess columns in the hashed tuples */
 	disuse_physical_tlist(root, inner_plan, best_path->jpath.innerjoinpath);
@@ -2476,23 +2317,20 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * most common combinations of outer values, which we don't currently have
 	 * enough stats for.)
 	 */
-	if (list_length(hashclauses) == 1)
-	{
-		OpExpr	   *clause = (OpExpr *) linitial(hashclauses);
-		Node	   *node;
+	if (list_length(hashclauses) == 1) {
+		OpExpr *clause = (OpExpr *) linitial(hashclauses);
+		Node *node;
 
 		Assert(is_opclause(clause));
 		node = (Node *) linitial(clause->args);
 		if (IsA(node, RelabelType))
 			node = (Node *) ((RelabelType *) node)->arg;
-		if (IsA(node, Var))
-		{
-			Var		   *var = (Var *) node;
+		if (IsA(node, Var)) {
+			Var *var = (Var *) node;
 			RangeTblEntry *rte;
 
 			rte = root->simple_rte_array[var->varno];
-			if (rte->rtekind == RTE_RELATION)
-			{
+			if (rte->rtekind == RTE_RELATION) {
 				skewTable = rte->relid;
 				skewColumn = var->varattno;
 				skewInherit = rte->inh;
@@ -2505,26 +2343,16 @@ create_hashjoin_plan(PlannerInfo *root,
 	/*
 	 * Build the hash node and hash join node.
 	 */
-	hash_plan = make_hash(inner_plan,
-						  skewTable,
-						  skewColumn,
-						  skewInherit,
-						  skewColType,
-						  skewColTypmod);
-	join_plan = make_hashjoin(tlist,
-							  joinclauses,
-							  otherclauses,
-							  hashclauses,
-							  outer_plan,
-							  (Plan *) hash_plan,
-							  best_path->jpath.jointype);
+	hash_plan = make_hash(inner_plan, skewTable, skewColumn, skewInherit,
+			skewColType, skewColTypmod);
+	join_plan = make_hashjoin(tlist, joinclauses, otherclauses, hashclauses,
+			outer_plan, (Plan *) hash_plan, best_path->jpath.jointype);
 
 	copy_path_costsize(&join_plan->join.plan, &best_path->jpath.path);
 
 	return join_plan;
 }
 
-
 /*****************************************************************************
  *
  *	SUPPORTING ROUTINES
@@ -2541,23 +2369,20 @@ create_hashjoin_plan(PlannerInfo *root,
  * root->curOuterParams if not already present.
  */
 static Node *
-replace_nestloop_params(PlannerInfo *root, Node *expr)
-{
+replace_nestloop_params(PlannerInfo *root, Node *expr) {
 	/* No setup needed for tree walk, so away we go */
 	return replace_nestloop_params_mutator(expr, root);
 }
 
 static Node *
-replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
-{
+replace_nestloop_params_mutator(Node *node, PlannerInfo *root) {
 	if (node == NULL)
 		return NULL;
-	if (IsA(node, Var))
-	{
-		Var		   *var = (Var *) node;
-		Param	   *param;
+	if (IsA(node, Var)) {
+		Var *var = (Var *) node;
+		Param *param;
 		NestLoopParam *nlp;
-		ListCell   *lc;
+		ListCell *lc;
 
 		/* Upper-level Vars should be long gone at this point */
 		Assert(var->varlevelsup == 0);
@@ -2566,12 +2391,9 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 			return node;
 		/* Create a Param representing the Var */
 		param = assign_nestloop_param_var(root, var);
-		/* Is this param already listed in root->curOuterParams? */
-		foreach(lc, root->curOuterParams)
-		{
+		/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 			nlp = (NestLoopParam *) lfirst(lc);
-			if (nlp->paramno == param->paramid)
-			{
+			if (nlp->paramno == param->paramid) {
 				Assert(equal(var, nlp->paramval));
 				/* Present, so we can just return the Param */
 				return (Node *) param;
@@ -2585,12 +2407,11 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		/* And return the replacement Param */
 		return (Node *) param;
 	}
-	if (IsA(node, PlaceHolderVar))
-	{
+	if (IsA(node, PlaceHolderVar)) {
 		PlaceHolderVar *phv = (PlaceHolderVar *) node;
-		Param	   *param;
+		Param *param;
 		NestLoopParam *nlp;
-		ListCell   *lc;
+		ListCell *lc;
 
 		/* Upper-level PlaceHolderVars should be long gone at this point */
 		Assert(phv->phlevelsup == 0);
@@ -2600,10 +2421,10 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		 * cheap/quick test to see if the PHV might be evaluated in the outer
 		 * rels, and then grab its PlaceHolderInfo to tell for sure.
 		 */
-		if (!bms_overlap(phv->phrels, root->curOuterRels) ||
-		  !bms_is_subset(find_placeholder_info(root, phv, false)->ph_eval_at,
-						 root->curOuterRels))
-		{
+		if (!bms_overlap(phv->phrels, root->curOuterRels)
+				|| !bms_is_subset(
+						find_placeholder_info(root, phv, false)->ph_eval_at,
+						root->curOuterRels)) {
 			/*
 			 * We can't replace the whole PHV, but we might still need to
 			 * replace Vars or PHVs within its expression, in case it ends up
@@ -2622,19 +2443,15 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 			PlaceHolderVar *newphv = makeNode(PlaceHolderVar);
 
 			memcpy(newphv, phv, sizeof(PlaceHolderVar));
-			newphv->phexpr = (Expr *)
-				replace_nestloop_params_mutator((Node *) phv->phexpr,
-												root);
+			newphv->phexpr = (Expr *) replace_nestloop_params_mutator(
+					(Node *) phv->phexpr, root);
 			return (Node *) newphv;
 		}
 		/* Create a Param representing the PlaceHolderVar */
 		param = assign_nestloop_param_placeholdervar(root, phv);
-		/* Is this param already listed in root->curOuterParams? */
-		foreach(lc, root->curOuterParams)
-		{
+		/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 			nlp = (NestLoopParam *) lfirst(lc);
-			if (nlp->paramno == param->paramid)
-			{
+			if (nlp->paramno == param->paramid) {
 				Assert(equal(phv, nlp->paramval));
 				/* Present, so we can just return the Param */
 				return (Node *) param;
@@ -2648,9 +2465,8 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		/* And return the replacement Param */
 		return (Node *) param;
 	}
-	return expression_tree_mutator(node,
-								   replace_nestloop_params_mutator,
-								   (void *) root);
+	return expression_tree_mutator(node, replace_nestloop_params_mutator,
+			(void *) root);
 }
 
 /*
@@ -2666,75 +2482,62 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
  * do need to do is add entries to root->curOuterParams to signal the parent
  * nestloop plan node that it must provide these values.
  */
-static void
-process_subquery_nestloop_params(PlannerInfo *root, List *subplan_params)
-{
-	ListCell   *ppl;
+static void process_subquery_nestloop_params(PlannerInfo *root,
+		List *subplan_params) {
+	ListCell *ppl;
 
-	foreach(ppl, subplan_params)
-	{
+	foreach(ppl, subplan_params) {
 		PlannerParamItem *pitem = (PlannerParamItem *) lfirst(ppl);
 
-		if (IsA(pitem->item, Var))
-		{
-			Var		   *var = (Var *) pitem->item;
+		if (IsA(pitem->item, Var)) {
+			Var *var = (Var *) pitem->item;
 			NestLoopParam *nlp;
-			ListCell   *lc;
+			ListCell *lc;
 
 			/* If not from a nestloop outer rel, complain */
 			if (!bms_is_member(var->varno, root->curOuterRels))
 				elog(ERROR, "non-LATERAL parameter required by subquery");
-			/* Is this param already listed in root->curOuterParams? */
-			foreach(lc, root->curOuterParams)
-			{
+			/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 				nlp = (NestLoopParam *) lfirst(lc);
-				if (nlp->paramno == pitem->paramId)
-				{
+				if (nlp->paramno == pitem->paramId) {
 					Assert(equal(var, nlp->paramval));
 					/* Present, so nothing to do */
 					break;
 				}
 			}
-			if (lc == NULL)
-			{
+			if (lc == NULL) {
 				/* No, so add it */
 				nlp = makeNode(NestLoopParam);
 				nlp->paramno = pitem->paramId;
 				nlp->paramval = copyObject(var);
 				root->curOuterParams = lappend(root->curOuterParams, nlp);
 			}
-		}
-		else if (IsA(pitem->item, PlaceHolderVar))
-		{
+		} else if (IsA(pitem->item, PlaceHolderVar)) {
 			PlaceHolderVar *phv = (PlaceHolderVar *) pitem->item;
 			NestLoopParam *nlp;
-			ListCell   *lc;
+			ListCell *lc;
 
 			/* If not from a nestloop outer rel, complain */
-			if (!bms_is_subset(find_placeholder_info(root, phv, false)->ph_eval_at,
-							   root->curOuterRels))
+			if (!bms_is_subset(
+					find_placeholder_info(root, phv, false)->ph_eval_at,
+					root->curOuterRels))
 				elog(ERROR, "non-LATERAL parameter required by subquery");
-			/* Is this param already listed in root->curOuterParams? */
-			foreach(lc, root->curOuterParams)
-			{
+			/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 				nlp = (NestLoopParam *) lfirst(lc);
-				if (nlp->paramno == pitem->paramId)
-				{
+				if (nlp->paramno == pitem->paramId) {
 					Assert(equal(phv, nlp->paramval));
 					/* Present, so nothing to do */
 					break;
 				}
 			}
-			if (lc == NULL)
-			{
+			if (lc == NULL) {
 				/* No, so add it */
 				nlp = makeNode(NestLoopParam);
 				nlp->paramno = pitem->paramId;
 				nlp->paramval = copyObject(phv);
 				root->curOuterParams = lappend(root->curOuterParams, nlp);
 			}
-		}
-		else
+		} else
 			elog(ERROR, "unexpected type of subquery parameter");
 	}
 }
@@ -2759,20 +2562,17 @@ process_subquery_nestloop_params(PlannerInfo *root, List *subplan_params)
  * two separate copies of the subplan tree, or things will go awry).
  */
 static List *
-fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
-{
+fix_indexqual_references(PlannerInfo *root, IndexPath *index_path) {
 	IndexOptInfo *index = index_path->indexinfo;
-	List	   *fixed_indexquals;
-	ListCell   *lcc,
-			   *lci;
+	List *fixed_indexquals;
+	ListCell *lcc, *lci;
 
 	fixed_indexquals = NIL;
 
-	forboth(lcc, index_path->indexquals, lci, index_path->indexqualcols)
-	{
+	forboth(lcc, index_path->indexquals, lci, index_path->indexqualcols) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lcc);
-		int			indexcol = lfirst_int(lci);
-		Node	   *clause;
+		int indexcol = lfirst_int(lci);
+		Node *clause;
 
 		Assert(IsA(rinfo, RestrictInfo));
 
@@ -2784,9 +2584,8 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 		 */
 		clause = replace_nestloop_params(root, (Node *) rinfo->clause);
 
-		if (IsA(clause, OpExpr))
-		{
-			OpExpr	   *op = (OpExpr *) clause;
+		if (IsA(clause, OpExpr)) {
+			OpExpr *op = (OpExpr *) clause;
 
 			if (list_length(op->args) != 2)
 				elog(ERROR, "indexqual clause is not binary opclause");
@@ -2803,26 +2602,19 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expression with an index Var.
 			 */
 			linitial(op->args) = fix_indexqual_operand(linitial(op->args),
-													   index,
-													   indexcol);
-		}
-		else if (IsA(clause, RowCompareExpr))
-		{
+					index, indexcol);
+		} else if (IsA(clause, RowCompareExpr)) {
 			RowCompareExpr *rc = (RowCompareExpr *) clause;
-			Expr	   *newrc;
-			List	   *indexcolnos;
-			bool		var_on_left;
-			ListCell   *lca,
-					   *lcai;
+			Expr *newrc;
+			List *indexcolnos;
+			bool var_on_left;
+			ListCell *lca, *lcai;
 
 			/*
 			 * Re-discover which index columns are used in the rowcompare.
 			 */
-			newrc = adjust_rowcompare_for_index(rc,
-												index,
-												indexcol,
-												&indexcolnos,
-												&var_on_left);
+			newrc = adjust_rowcompare_for_index(rc, index, indexcol,
+					&indexcolnos, &var_on_left);
 
 			/*
 			 * Trouble if adjust_rowcompare_for_index thought the
@@ -2830,7 +2622,8 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * have gone through that routine already.
 			 */
 			if (newrc != (Expr *) rc)
-				elog(ERROR, "inconsistent results from adjust_rowcompare_for_index");
+				elog(ERROR,
+						"inconsistent results from adjust_rowcompare_for_index");
 
 			/*
 			 * Check to see if the indexkey is on the right; if so, commute
@@ -2843,36 +2636,27 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expressions with index Vars.
 			 */
 			Assert(list_length(rc->largs) == list_length(indexcolnos));
-			forboth(lca, rc->largs, lcai, indexcolnos)
-			{
-				lfirst(lca) = fix_indexqual_operand(lfirst(lca),
-													index,
-													lfirst_int(lcai));
+			forboth(lca, rc->largs, lcai, indexcolnos) {
+				lfirst(lca) = fix_indexqual_operand(lfirst(lca), index,
+						lfirst_int(lcai));
 			}
-		}
-		else if (IsA(clause, ScalarArrayOpExpr))
-		{
+		} else if (IsA(clause, ScalarArrayOpExpr)) {
 			ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;
 
 			/* Never need to commute... */
 
 			/* Replace the indexkey expression with an index Var. */
 			linitial(saop->args) = fix_indexqual_operand(linitial(saop->args),
-														 index,
-														 indexcol);
-		}
-		else if (IsA(clause, NullTest))
-		{
-			NullTest   *nt = (NullTest *) clause;
+					index, indexcol);
+		} else if (IsA(clause, NullTest)) {
+			NullTest *nt = (NullTest *) clause;
 
 			/* Replace the indexkey expression with an index Var. */
-			nt->arg = (Expr *) fix_indexqual_operand((Node *) nt->arg,
-													 index,
-													 indexcol);
-		}
-		else
-			elog(ERROR, "unsupported indexqual type: %d",
-				 (int) nodeTag(clause));
+			nt->arg = (Expr *) fix_indexqual_operand((Node *) nt->arg, index,
+					indexcol);
+		} else
+			elog(ERROR,
+					"unsupported indexqual type: %d", (int) nodeTag(clause));
 
 		fixed_indexquals = lappend(fixed_indexquals, clause);
 	}
@@ -2892,19 +2676,16 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
  * is allowed for ordering operators.
  */
 static List *
-fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
-{
+fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path) {
 	IndexOptInfo *index = index_path->indexinfo;
-	List	   *fixed_indexorderbys;
-	ListCell   *lcc,
-			   *lci;
+	List *fixed_indexorderbys;
+	ListCell *lcc, *lci;
 
 	fixed_indexorderbys = NIL;
 
-	forboth(lcc, index_path->indexorderbys, lci, index_path->indexorderbycols)
-	{
-		Node	   *clause = (Node *) lfirst(lcc);
-		int			indexcol = lfirst_int(lci);
+	forboth(lcc, index_path->indexorderbys, lci, index_path->indexorderbycols) {
+		Node *clause = (Node *) lfirst(lcc);
+		int indexcol = lfirst_int(lci);
 
 		/*
 		 * Replace any outer-relation variables with nestloop params.
@@ -2914,9 +2695,8 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
 		 */
 		clause = replace_nestloop_params(root, clause);
 
-		if (IsA(clause, OpExpr))
-		{
-			OpExpr	   *op = (OpExpr *) clause;
+		if (IsA(clause, OpExpr)) {
+			OpExpr *op = (OpExpr *) clause;
 
 			if (list_length(op->args) != 2)
 				elog(ERROR, "indexorderby clause is not binary opclause");
@@ -2925,12 +2705,10 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expression with an index Var.
 			 */
 			linitial(op->args) = fix_indexqual_operand(linitial(op->args),
-													   index,
-													   indexcol);
-		}
-		else
-			elog(ERROR, "unsupported indexorderby type: %d",
-				 (int) nodeTag(clause));
+					index, indexcol);
+		} else
+			elog(ERROR,
+					"unsupported indexorderby type: %d", (int) nodeTag(clause));
 
 		fixed_indexorderbys = lappend(fixed_indexorderbys, clause);
 	}
@@ -2949,11 +2727,10 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
  * expression actually matches the index column it's claimed to.
  */
 static Node *
-fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
-{
-	Var		   *result;
-	int			pos;
-	ListCell   *indexpr_item;
+fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol) {
+	Var *result;
+	int pos;
+	ListCell *indexpr_item;
 
 	/*
 	 * Remove any binary-compatible relabeling of the indexkey
@@ -2963,47 +2740,38 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
 
 	Assert(indexcol >= 0 && indexcol < index->ncolumns);
 
-	if (index->indexkeys[indexcol] != 0)
-	{
+	if (index->indexkeys[indexcol] != 0) {
 		/* It's a simple index column */
-		if (IsA(node, Var) &&
-			((Var *) node)->varno == index->rel->relid &&
-			((Var *) node)->varattno == index->indexkeys[indexcol])
-		{
+		if (IsA(node, Var) && ((Var *) node)->varno == index->rel->relid
+				&& ((Var *) node)->varattno == index->indexkeys[indexcol]) {
 			result = (Var *) copyObject(node);
 			result->varno = INDEX_VAR;
 			result->varattno = indexcol + 1;
 			return (Node *) result;
-		}
-		else
+		} else
 			elog(ERROR, "index key does not match expected index column");
 	}
 
 	/* It's an index expression, so find and cross-check the expression */
 	indexpr_item = list_head(index->indexprs);
-	for (pos = 0; pos < index->ncolumns; pos++)
-	{
-		if (index->indexkeys[pos] == 0)
-		{
+	for (pos = 0; pos < index->ncolumns; pos++) {
+		if (index->indexkeys[pos] == 0) {
 			if (indexpr_item == NULL)
 				elog(ERROR, "too few entries in indexprs list");
-			if (pos == indexcol)
-			{
-				Node	   *indexkey;
+			if (pos == indexcol) {
+				Node *indexkey;
 
 				indexkey = (Node *) lfirst(indexpr_item);
 				if (indexkey && IsA(indexkey, RelabelType))
 					indexkey = (Node *) ((RelabelType *) indexkey)->arg;
-				if (equal(node, indexkey))
-				{
+				if (equal(node, indexkey)) {
 					result = makeVar(INDEX_VAR, indexcol + 1,
-									 exprType(lfirst(indexpr_item)), -1,
-									 exprCollation(lfirst(indexpr_item)),
-									 0);
+							exprType(lfirst(indexpr_item)), -1,
+							exprCollation(lfirst(indexpr_item)), 0);
 					return (Node *) result;
-				}
-				else
-					elog(ERROR, "index key does not match expected index column");
+				} else
+					elog(ERROR,
+							"index key does not match expected index column");
 			}
 			indexpr_item = lnext(indexpr_item);
 		}
@@ -3011,7 +2779,7 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
 
 	/* Ooops... */
 	elog(ERROR, "index key does not match expected index column");
-	return NULL;				/* keep compiler quiet */
+	return NULL; /* keep compiler quiet */
 }
 
 /*
@@ -3024,25 +2792,22 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
  *	  outer_is_left field in each RestrictInfo to show which side was which.
  */
 static List *
-get_switched_clauses(List *clauses, Relids outerrelids)
-{
-	List	   *t_list = NIL;
-	ListCell   *l;
+get_switched_clauses(List *clauses, Relids outerrelids) {
+	List *t_list = NIL;
+	ListCell *l;
 
-	foreach(l, clauses)
-	{
+	foreach(l, clauses) {
 		RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(l);
-		OpExpr	   *clause = (OpExpr *) restrictinfo->clause;
+		OpExpr *clause = (OpExpr *) restrictinfo->clause;
 
 		Assert(is_opclause(clause));
-		if (bms_is_subset(restrictinfo->right_relids, outerrelids))
-		{
+		if (bms_is_subset(restrictinfo->right_relids, outerrelids)) {
 			/*
 			 * Duplicate just enough of the structure to allow commuting the
 			 * clause without changing the original list.  Could use
 			 * copyObject, but a complete deep copy is overkill.
 			 */
-			OpExpr	   *temp = makeNode(OpExpr);
+			OpExpr *temp = makeNode(OpExpr);
 
 			temp->opno = clause->opno;
 			temp->opfuncid = InvalidOid;
@@ -3056,10 +2821,8 @@ get_switched_clauses(List *clauses, Relids outerrelids)
 			CommuteOpExpr(temp);
 			t_list = lappend(t_list, temp);
 			restrictinfo->outer_is_left = false;
-		}
-		else
-		{
-			Assert(bms_is_subset(restrictinfo->left_relids, outerrelids));
+		} else {
+			Assert( bms_is_subset(restrictinfo->left_relids, outerrelids));
 			t_list = lappend(t_list, clause);
 			restrictinfo->outer_is_left = true;
 		}
@@ -3090,18 +2853,16 @@ get_switched_clauses(List *clauses, Relids outerrelids)
  * a cost/selectivity combination would likely do the wrong thing.
  */
 static List *
-order_qual_clauses(PlannerInfo *root, List *clauses)
-{
-	typedef struct
-	{
-		Node	   *clause;
-		Cost		cost;
+order_qual_clauses(PlannerInfo *root, List *clauses) {
+	typedef struct {
+		Node *clause;
+		Cost cost;
 	} QualItem;
-	int			nitems = list_length(clauses);
-	QualItem   *items;
-	ListCell   *lc;
-	int			i;
-	List	   *result;
+	int nitems = list_length(clauses);
+	QualItem *items;
+	ListCell *lc;
+	int i;
+	List *result;
 
 	/* No need to work hard for 0 or 1 clause */
 	if (nitems <= 1)
@@ -3113,10 +2874,9 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
 	 */
 	items = (QualItem *) palloc(nitems * sizeof(QualItem));
 	i = 0;
-	foreach(lc, clauses)
-	{
-		Node	   *clause = (Node *) lfirst(lc);
-		QualCost	qcost;
+	foreach(lc, clauses) {
+		Node *clause = (Node *) lfirst(lc);
+		QualCost qcost;
 
 		cost_qual_eval_node(&qcost, clause, root);
 		items[i].clause = clause;
@@ -3129,14 +2889,12 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
 	 * equal keys.	The expected number of entries is small enough that a
 	 * simple insertion sort should be good enough.
 	 */
-	for (i = 1; i < nitems; i++)
-	{
-		QualItem	newitem = items[i];
-		int			j;
+	for (i = 1; i < nitems; i++) {
+		QualItem newitem = items[i];
+		int j;
 
 		/* insert newitem into the already-sorted subarray */
-		for (j = i; j > 0; j--)
-		{
+		for (j = i; j > 0; j--) {
 			if (newitem.cost >= items[j - 1].cost)
 				break;
 			items[j] = items[j - 1];
@@ -3156,18 +2914,14 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
  * Copy cost and size info from a Path node to the Plan node created from it.
  * The executor usually won't use this info, but it's needed by EXPLAIN.
  */
-static void
-copy_path_costsize(Plan *dest, Path *src)
-{
-	if (src)
-	{
+static void copy_path_costsize(Plan *dest, Path *src) {
+	if (src) {
 		dest->startup_cost = src->startup_cost;
-		dest->total_cost = src->total_cost;
+		dest->total_cost =
+				(src->mtotal_cost == 0) ? src->total_cost : src->mtotal_cost;
 		dest->plan_rows = src->rows;
 		dest->plan_width = src->parent->width;
-	}
-	else
-	{
+	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
@@ -3179,18 +2933,13 @@ copy_path_costsize(Plan *dest, Path *src)
  * Copy cost and size info from a lower plan node to an inserted node.
  * (Most callers alter the info after copying it.)
  */
-static void
-copy_plan_costsize(Plan *dest, Plan *src)
-{
-	if (src)
-	{
+static void copy_plan_costsize(Plan *dest, Plan *src) {
+	if (src) {
 		dest->startup_cost = src->startup_cost;
 		dest->total_cost = src->total_cost;
 		dest->plan_rows = src->plan_rows;
 		dest->plan_width = src->plan_width;
-	}
-	else
-	{
+	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
@@ -3198,7 +2947,6 @@ copy_plan_costsize(Plan *dest, Plan *src)
 	}
 }
 
-
 /*****************************************************************************
  *
  *	PLAN NODE BUILDING ROUTINES
@@ -3209,12 +2957,9 @@ copy_plan_costsize(Plan *dest, Plan *src)
  *****************************************************************************/
 
 static SeqScan *
-make_seqscan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid)
-{
-	SeqScan    *node = makeNode(SeqScan);
-	Plan	   *plan = &node->plan;
+make_seqscan(List *qptlist, List *qpqual, Index scanrelid) {
+	SeqScan *node = makeNode(SeqScan);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3227,18 +2972,11 @@ make_seqscan(List *qptlist,
 }
 
 static IndexScan *
-make_indexscan(List *qptlist,
-			   List *qpqual,
-			   Index scanrelid,
-			   Oid indexid,
-			   List *indexqual,
-			   List *indexqualorig,
-			   List *indexorderby,
-			   List *indexorderbyorig,
-			   ScanDirection indexscandir)
-{
-	IndexScan  *node = makeNode(IndexScan);
-	Plan	   *plan = &node->scan.plan;
+make_indexscan(List *qptlist, List *qpqual, Index scanrelid, Oid indexid,
+		List *indexqual, List *indexqualorig, List *indexorderby,
+		List *indexorderbyorig, ScanDirection indexscandir) {
+	IndexScan *node = makeNode(IndexScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3257,17 +2995,11 @@ make_indexscan(List *qptlist,
 }
 
 static IndexOnlyScan *
-make_indexonlyscan(List *qptlist,
-				   List *qpqual,
-				   Index scanrelid,
-				   Oid indexid,
-				   List *indexqual,
-				   List *indexorderby,
-				   List *indextlist,
-				   ScanDirection indexscandir)
-{
+make_indexonlyscan(List *qptlist, List *qpqual, Index scanrelid, Oid indexid,
+		List *indexqual, List *indexorderby, List *indextlist,
+		ScanDirection indexscandir) {
 	IndexOnlyScan *node = makeNode(IndexOnlyScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3285,17 +3017,14 @@ make_indexonlyscan(List *qptlist,
 }
 
 static BitmapIndexScan *
-make_bitmap_indexscan(Index scanrelid,
-					  Oid indexid,
-					  List *indexqual,
-					  List *indexqualorig)
-{
+make_bitmap_indexscan(Index scanrelid, Oid indexid, List *indexqual,
+		List *indexqualorig) {
 	BitmapIndexScan *node = makeNode(BitmapIndexScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
-	plan->targetlist = NIL;		/* not used */
-	plan->qual = NIL;			/* not used */
+	plan->targetlist = NIL; /* not used */
+	plan->qual = NIL; /* not used */
 	plan->lefttree = NULL;
 	plan->righttree = NULL;
 	node->scan.scanrelid = scanrelid;
@@ -3307,14 +3036,10 @@ make_bitmap_indexscan(Index scanrelid,
 }
 
 static BitmapHeapScan *
-make_bitmap_heapscan(List *qptlist,
-					 List *qpqual,
-					 Plan *lefttree,
-					 List *bitmapqualorig,
-					 Index scanrelid)
-{
+make_bitmap_heapscan(List *qptlist, List *qpqual, Plan *lefttree,
+		List *bitmapqualorig, Index scanrelid) {
 	BitmapHeapScan *node = makeNode(BitmapHeapScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3328,13 +3053,9 @@ make_bitmap_heapscan(List *qptlist,
 }
 
 static TidScan *
-make_tidscan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid,
-			 List *tidquals)
-{
-	TidScan    *node = makeNode(TidScan);
-	Plan	   *plan = &node->scan.plan;
+make_tidscan(List *qptlist, List *qpqual, Index scanrelid, List *tidquals) {
+	TidScan *node = makeNode(TidScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3348,13 +3069,9 @@ make_tidscan(List *qptlist,
 }
 
 SubqueryScan *
-make_subqueryscan(List *qptlist,
-				  List *qpqual,
-				  Index scanrelid,
-				  Plan *subplan)
-{
+make_subqueryscan(List *qptlist, List *qpqual, Index scanrelid, Plan *subplan) {
 	SubqueryScan *node = makeNode(SubqueryScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/*
 	 * Cost is figured here for the convenience of prepunion.c.  Note this is
@@ -3375,14 +3092,10 @@ make_subqueryscan(List *qptlist,
 }
 
 static FunctionScan *
-make_functionscan(List *qptlist,
-				  List *qpqual,
-				  Index scanrelid,
-				  List *functions,
-				  bool funcordinality)
-{
+make_functionscan(List *qptlist, List *qpqual, Index scanrelid, List *functions,
+		bool funcordinality) {
 	FunctionScan *node = makeNode(FunctionScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3397,13 +3110,10 @@ make_functionscan(List *qptlist,
 }
 
 static ValuesScan *
-make_valuesscan(List *qptlist,
-				List *qpqual,
-				Index scanrelid,
-				List *values_lists)
-{
+make_valuesscan(List *qptlist, List *qpqual, Index scanrelid,
+		List *values_lists) {
 	ValuesScan *node = makeNode(ValuesScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3417,14 +3127,10 @@ make_valuesscan(List *qptlist,
 }
 
 static CteScan *
-make_ctescan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid,
-			 int ctePlanId,
-			 int cteParam)
-{
-	CteScan    *node = makeNode(CteScan);
-	Plan	   *plan = &node->scan.plan;
+make_ctescan(List *qptlist, List *qpqual, Index scanrelid, int ctePlanId,
+		int cteParam) {
+	CteScan *node = makeNode(CteScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3439,13 +3145,9 @@ make_ctescan(List *qptlist,
 }
 
 static WorkTableScan *
-make_worktablescan(List *qptlist,
-				   List *qpqual,
-				   Index scanrelid,
-				   int wtParam)
-{
+make_worktablescan(List *qptlist, List *qpqual, Index scanrelid, int wtParam) {
 	WorkTableScan *node = makeNode(WorkTableScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3459,14 +3161,10 @@ make_worktablescan(List *qptlist,
 }
 
 ForeignScan *
-make_foreignscan(List *qptlist,
-				 List *qpqual,
-				 Index scanrelid,
-				 List *fdw_exprs,
-				 List *fdw_private)
-{
+make_foreignscan(List *qptlist, List *qpqual, Index scanrelid, List *fdw_exprs,
+		List *fdw_private) {
 	ForeignScan *node = makeNode(ForeignScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost will be filled in by create_foreignscan_plan */
 	plan->targetlist = qptlist;
@@ -3483,12 +3181,11 @@ make_foreignscan(List *qptlist,
 }
 
 Append *
-make_append(List *appendplans, List *tlist)
-{
-	Append	   *node = makeNode(Append);
-	Plan	   *plan = &node->plan;
-	double		total_size;
-	ListCell   *subnode;
+make_append(List *appendplans, List *tlist) {
+	Append *node = makeNode(Append);
+	Plan *plan = &node->plan;
+	double total_size;
+	ListCell *subnode;
 
 	/*
 	 * Compute cost as sum of subplan costs.  We charge nothing extra for the
@@ -3505,11 +3202,10 @@ make_append(List *appendplans, List *tlist)
 	plan->total_cost = 0;
 	plan->plan_rows = 0;
 	total_size = 0;
-	foreach(subnode, appendplans)
-	{
-		Plan	   *subplan = (Plan *) lfirst(subnode);
+	foreach(subnode, appendplans) {
+		Plan *subplan = (Plan *) lfirst(subnode);
 
-		if (subnode == list_head(appendplans))	/* first node? */
+		if (subnode == list_head(appendplans)) /* first node? */
 			plan->startup_cost = subplan->startup_cost;
 		plan->total_cost += subplan->total_cost;
 		plan->plan_rows += subplan->plan_rows;
@@ -3530,16 +3226,11 @@ make_append(List *appendplans, List *tlist)
 }
 
 RecursiveUnion *
-make_recursive_union(List *tlist,
-					 Plan *lefttree,
-					 Plan *righttree,
-					 int wtParam,
-					 List *distinctList,
-					 long numGroups)
-{
+make_recursive_union(List *tlist, Plan *lefttree, Plan *righttree, int wtParam,
+		List *distinctList, long numGroups) {
 	RecursiveUnion *node = makeNode(RecursiveUnion);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
 
 	cost_recursive_union(plan, lefttree, righttree);
 
@@ -3554,21 +3245,19 @@ make_recursive_union(List *tlist,
 	 * operators, as wanted by executor
 	 */
 	node->numCols = numCols;
-	if (numCols > 0)
-	{
-		int			keyno = 0;
+	if (numCols > 0) {
+		int keyno = 0;
 		AttrNumber *dupColIdx;
-		Oid		   *dupOperators;
-		ListCell   *slitem;
+		Oid *dupOperators;
+		ListCell *slitem;
 
 		dupColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 		dupOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-		foreach(slitem, distinctList)
-		{
+		foreach(slitem, distinctList) {
 			SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 			TargetEntry *tle = get_sortgroupclause_tle(sortcl,
-													   plan->targetlist);
+					plan->targetlist);
 
 			dupColIdx[keyno] = tle->resno;
 			dupOperators[keyno] = sortcl->eqop;
@@ -3584,10 +3273,9 @@ make_recursive_union(List *tlist,
 }
 
 static BitmapAnd *
-make_bitmap_and(List *bitmapplans)
-{
-	BitmapAnd  *node = makeNode(BitmapAnd);
-	Plan	   *plan = &node->plan;
+make_bitmap_and(List *bitmapplans) {
+	BitmapAnd *node = makeNode(BitmapAnd);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = NIL;
@@ -3600,10 +3288,9 @@ make_bitmap_and(List *bitmapplans)
 }
 
 static BitmapOr *
-make_bitmap_or(List *bitmapplans)
-{
-	BitmapOr   *node = makeNode(BitmapOr);
-	Plan	   *plan = &node->plan;
+make_bitmap_or(List *bitmapplans) {
+	BitmapOr *node = makeNode(BitmapOr);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = NIL;
@@ -3616,16 +3303,10 @@ make_bitmap_or(List *bitmapplans)
 }
 
 static NestLoop *
-make_nestloop(List *tlist,
-			  List *joinclauses,
-			  List *otherclauses,
-			  List *nestParams,
-			  Plan *lefttree,
-			  Plan *righttree,
-			  JoinType jointype)
-{
-	NestLoop   *node = makeNode(NestLoop);
-	Plan	   *plan = &node->join.plan;
+make_nestloop(List *tlist, List *joinclauses, List *otherclauses,
+		List *nestParams, Plan *lefttree, Plan *righttree, JoinType jointype) {
+	NestLoop *node = makeNode(NestLoop);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3640,16 +3321,10 @@ make_nestloop(List *tlist,
 }
 
 static HashJoin *
-make_hashjoin(List *tlist,
-			  List *joinclauses,
-			  List *otherclauses,
-			  List *hashclauses,
-			  Plan *lefttree,
-			  Plan *righttree,
-			  JoinType jointype)
-{
-	HashJoin   *node = makeNode(HashJoin);
-	Plan	   *plan = &node->join.plan;
+make_hashjoin(List *tlist, List *joinclauses, List *otherclauses,
+		List *hashclauses, Plan *lefttree, Plan *righttree, JoinType jointype) {
+	HashJoin *node = makeNode(HashJoin);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3664,15 +3339,10 @@ make_hashjoin(List *tlist,
 }
 
 static Hash *
-make_hash(Plan *lefttree,
-		  Oid skewTable,
-		  AttrNumber skewColumn,
-		  bool skewInherit,
-		  Oid skewColType,
-		  int32 skewColTypmod)
-{
-	Hash	   *node = makeNode(Hash);
-	Plan	   *plan = &node->plan;
+make_hash(Plan *lefttree, Oid skewTable, AttrNumber skewColumn,
+		bool skewInherit, Oid skewColType, int32 skewColTypmod) {
+	Hash *node = makeNode(Hash);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -3696,20 +3366,12 @@ make_hash(Plan *lefttree,
 }
 
 static MergeJoin *
-make_mergejoin(List *tlist,
-			   List *joinclauses,
-			   List *otherclauses,
-			   List *mergeclauses,
-			   Oid *mergefamilies,
-			   Oid *mergecollations,
-			   int *mergestrategies,
-			   bool *mergenullsfirst,
-			   Plan *lefttree,
-			   Plan *righttree,
-			   JoinType jointype)
-{
-	MergeJoin  *node = makeNode(MergeJoin);
-	Plan	   *plan = &node->join.plan;
+make_mergejoin(List *tlist, List *joinclauses, List *otherclauses,
+		List *mergeclauses, Oid *mergefamilies, Oid *mergecollations,
+		int *mergestrategies, bool *mergenullsfirst, Plan *lefttree,
+		Plan *righttree, JoinType jointype) {
+	MergeJoin *node = makeNode(MergeJoin);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3736,22 +3398,15 @@ make_mergejoin(List *tlist,
  */
 static Sort *
 make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
-		  AttrNumber *sortColIdx, Oid *sortOperators,
-		  Oid *collations, bool *nullsFirst,
-		  double limit_tuples)
-{
-	Sort	   *node = makeNode(Sort);
-	Plan	   *plan = &node->plan;
-	Path		sort_path;		/* dummy for result of cost_sort */
+		AttrNumber *sortColIdx, Oid *sortOperators, Oid *collations,
+		bool *nullsFirst, double limit_tuples) {
+	Sort *node = makeNode(Sort);
+	Plan *plan = &node->plan;
+	Path sort_path; /* dummy for result of cost_sort */
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_sort(&sort_path, root, NIL,
-			  lefttree->total_cost,
-			  lefttree->plan_rows,
-			  lefttree->plan_width,
-			  0.0,
-			  work_mem,
-			  limit_tuples);
+	cost_sort(&sort_path, root, NIL, lefttree->total_cost, lefttree->plan_rows,
+			lefttree->plan_width, 0.0, work_mem, limit_tuples);
 	plan->startup_cost = sort_path.startup_cost;
 	plan->total_cost = sort_path.total_cost;
 	plan->targetlist = lefttree->targetlist;
@@ -3809,22 +3464,16 @@ make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
  */
 static Plan *
 prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
-						   Relids relids,
-						   const AttrNumber *reqColIdx,
-						   bool adjust_tlist_in_place,
-						   int *p_numsortkeys,
-						   AttrNumber **p_sortColIdx,
-						   Oid **p_sortOperators,
-						   Oid **p_collations,
-						   bool **p_nullsFirst)
-{
-	List	   *tlist = lefttree->targetlist;
-	ListCell   *i;
-	int			numsortkeys;
+		Relids relids, const AttrNumber *reqColIdx, bool adjust_tlist_in_place,
+		int *p_numsortkeys, AttrNumber **p_sortColIdx, Oid **p_sortOperators,
+		Oid **p_collations, bool **p_nullsFirst) {
+	List *tlist = lefttree->targetlist;
+	ListCell *i;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/*
 	 * We will need at most list_length(pathkeys) sort columns; possibly less
@@ -3837,32 +3486,29 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 
 	numsortkeys = 0;
 
-	foreach(i, pathkeys)
-	{
-		PathKey    *pathkey = (PathKey *) lfirst(i);
+	foreach(i, pathkeys) {
+		PathKey *pathkey = (PathKey *) lfirst(i);
 		EquivalenceClass *ec = pathkey->pk_eclass;
 		EquivalenceMember *em;
 		TargetEntry *tle = NULL;
-		Oid			pk_datatype = InvalidOid;
-		Oid			sortop;
-		ListCell   *j;
+		Oid pk_datatype = InvalidOid;
+		Oid sortop;
+		ListCell *j;
 
-		if (ec->ec_has_volatile)
-		{
+		if (ec->ec_has_volatile) {
 			/*
 			 * If the pathkey's EquivalenceClass is volatile, then it must
 			 * have come from an ORDER BY clause, and we have to match it to
 			 * that same targetlist entry.
 			 */
-			if (ec->ec_sortref == 0)	/* can't happen */
+			if (ec->ec_sortref == 0) /* can't happen */
 				elog(ERROR, "volatile EquivalenceClass has no sortref");
 			tle = get_sortgroupref_tle(ec->ec_sortref, tlist);
 			Assert(tle);
 			Assert(list_length(ec->ec_members) == 1);
-			pk_datatype = ((EquivalenceMember *) linitial(ec->ec_members))->em_datatype;
-		}
-		else if (reqColIdx != NULL)
-		{
+			pk_datatype =
+					((EquivalenceMember *) linitial(ec->ec_members))->em_datatype;
+		} else if (reqColIdx != NULL) {
 			/*
 			 * If we are given a sort column number to match, only consider
 			 * the single TLE at that position.  It's possible that there is
@@ -3873,20 +3519,15 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * but we'll leave it to caller to complain about the mismatch.
 			 */
 			tle = get_tle_by_resno(tlist, reqColIdx[numsortkeys]);
-			if (tle)
-			{
+			if (tle) {
 				em = find_ec_member_for_tle(ec, tle, relids);
-				if (em)
-				{
+				if (em) {
 					/* found expr at right place in tlist */
 					pk_datatype = em->em_datatype;
-				}
-				else
+				} else
 					tle = NULL;
 			}
-		}
-		else
-		{
+		} else {
 			/*
 			 * Otherwise, we can sort by any non-constant expression listed in
 			 * the pathkey's EquivalenceClass.  For now, we take the first
@@ -3903,12 +3544,10 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * in the same equivalence class...)  Not clear that we ever will
 			 * have an interesting choice in practice, so it may not matter.
 			 */
-			foreach(j, tlist)
-			{
+			foreach(j, tlist) {
 				tle = (TargetEntry *) lfirst(j);
 				em = find_ec_member_for_tle(ec, tle, relids);
-				if (em)
-				{
+				if (em) {
 					/* found expr already in tlist */
 					pk_datatype = em->em_datatype;
 					break;
@@ -3917,8 +3556,7 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			}
 		}
 
-		if (!tle)
-		{
+		if (!tle) {
 			/*
 			 * No matching tlist item; look for a computable expression. Note
 			 * that we treat Aggrefs as if they were variables; this is
@@ -3926,13 +3564,12 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * for use in a WindowFunc (since grouping_planner will have
 			 * treated the Aggrefs as variables, too).
 			 */
-			Expr	   *sortexpr = NULL;
+			Expr *sortexpr = NULL;
 
-			foreach(j, ec->ec_members)
-			{
+			foreach(j, ec->ec_members) {
 				EquivalenceMember *em = (EquivalenceMember *) lfirst(j);
-				List	   *exprvars;
-				ListCell   *k;
+				List *exprvars;
+				ListCell *k;
 
 				/*
 				 * We shouldn't be trying to sort by an equivalence class that
@@ -3946,24 +3583,20 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 				 * Ignore child members unless they match the rel being
 				 * sorted.
 				 */
-				if (em->em_is_child &&
-					!bms_equal(em->em_relids, relids))
+				if (em->em_is_child && !bms_equal(em->em_relids, relids))
 					continue;
 
 				sortexpr = em->em_expr;
 				exprvars = pull_var_clause((Node *) sortexpr,
-										   PVC_INCLUDE_AGGREGATES,
-										   PVC_INCLUDE_PLACEHOLDERS);
-				foreach(k, exprvars)
-				{
+						PVC_INCLUDE_AGGREGATES, PVC_INCLUDE_PLACEHOLDERS);
+				foreach(k, exprvars) {
 					if (!tlist_member_ignore_relabel(lfirst(k), tlist))
 						break;
 				}
 				list_free(exprvars);
-				if (!k)
-				{
+				if (!k) {
 					pk_datatype = em->em_datatype;
-					break;		/* found usable expression */
+					break; /* found usable expression */
 				}
 			}
 			if (!j)
@@ -3972,13 +3605,11 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			/*
 			 * Do we need to insert a Result node?
 			 */
-			if (!adjust_tlist_in_place &&
-				!is_projection_capable_plan(lefttree))
-			{
+			if (!adjust_tlist_in_place
+					&& !is_projection_capable_plan(lefttree)) {
 				/* copy needed so we don't modify input's tlist below */
 				tlist = copyObject(tlist);
-				lefttree = (Plan *) make_result(root, tlist, NULL,
-												lefttree);
+				lefttree = (Plan *) make_result(root, tlist, NULL, lefttree);
 			}
 
 			/* Don't bother testing is_projection_capable_plan again */
@@ -3987,26 +3618,20 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			/*
 			 * Add resjunk entry to input's tlist
 			 */
-			tle = makeTargetEntry(sortexpr,
-								  list_length(tlist) + 1,
-								  NULL,
-								  true);
+			tle = makeTargetEntry(sortexpr, list_length(tlist) + 1, NULL, true);
 			tlist = lappend(tlist, tle);
-			lefttree->targetlist = tlist;		/* just in case NIL before */
+			lefttree->targetlist = tlist; /* just in case NIL before */
 		}
 
 		/*
 		 * Look up the correct sort operator from the PathKey's slightly
 		 * abstracted representation.
 		 */
-		sortop = get_opfamily_member(pathkey->pk_opfamily,
-									 pk_datatype,
-									 pk_datatype,
-									 pathkey->pk_strategy);
-		if (!OidIsValid(sortop))	/* should not happen */
-			elog(ERROR, "could not find member %d(%u,%u) of opfamily %u",
-				 pathkey->pk_strategy, pk_datatype, pk_datatype,
-				 pathkey->pk_opfamily);
+		sortop = get_opfamily_member(pathkey->pk_opfamily, pk_datatype,
+				pk_datatype, pathkey->pk_strategy);
+		if (!OidIsValid(sortop)) /* should not happen */
+			elog(ERROR,
+					"could not find member %d(%u,%u) of opfamily %u", pathkey->pk_strategy, pk_datatype, pk_datatype, pathkey->pk_opfamily);
 
 		/* Add the column to the sort arrays */
 		sortColIdx[numsortkeys] = tle->resno;
@@ -4033,22 +3658,18 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
  * Child EC members are ignored unless they match 'relids'.
  */
 static EquivalenceMember *
-find_ec_member_for_tle(EquivalenceClass *ec,
-					   TargetEntry *tle,
-					   Relids relids)
-{
-	Expr	   *tlexpr;
-	ListCell   *lc;
+find_ec_member_for_tle(EquivalenceClass *ec, TargetEntry *tle, Relids relids) {
+	Expr *tlexpr;
+	ListCell *lc;
 
 	/* We ignore binary-compatible relabeling on both ends */
 	tlexpr = tle->expr;
 	while (tlexpr && IsA(tlexpr, RelabelType))
 		tlexpr = ((RelabelType *) tlexpr)->arg;
 
-	foreach(lc, ec->ec_members)
-	{
+	foreach(lc, ec->ec_members) {
 		EquivalenceMember *em = (EquivalenceMember *) lfirst(lc);
-		Expr	   *emexpr;
+		Expr *emexpr;
 
 		/*
 		 * We shouldn't be trying to sort by an equivalence class that
@@ -4060,8 +3681,7 @@ find_ec_member_for_tle(EquivalenceClass *ec,
 		/*
 		 * Ignore child members unless they match the rel being sorted.
 		 */
-		if (em->em_is_child &&
-			!bms_equal(em->em_relids, relids))
+		if (em->em_is_child && !bms_equal(em->em_relids, relids))
 			continue;
 
 		/* Match if same expression (after stripping relabel) */
@@ -4087,29 +3707,21 @@ find_ec_member_for_tle(EquivalenceClass *ec,
  */
 Sort *
 make_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
-						double limit_tuples)
-{
-	int			numsortkeys;
+		double limit_tuples) {
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Compute sort column info, and adjust lefttree as needed */
-	lefttree = prepare_sort_from_pathkeys(root, lefttree, pathkeys,
-										  NULL,
-										  NULL,
-										  false,
-										  &numsortkeys,
-										  &sortColIdx,
-										  &sortOperators,
-										  &collations,
-										  &nullsFirst);
+	lefttree = prepare_sort_from_pathkeys(root, lefttree, pathkeys, NULL, NULL,
+			false, &numsortkeys, &sortColIdx, &sortOperators, &collations,
+			&nullsFirst);
 
 	/* Now build the Sort node */
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, limit_tuples);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, limit_tuples);
 }
 
 /*
@@ -4120,15 +3732,14 @@ make_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
  *	  'lefttree' is the node which yields input tuples
  */
 Sort *
-make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
-{
-	List	   *sub_tlist = lefttree->targetlist;
-	ListCell   *l;
-	int			numsortkeys;
+make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree) {
+	List *sub_tlist = lefttree->targetlist;
+	ListCell *l;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Convert list-ish representation to arrays wanted by executor */
 	numsortkeys = list_length(sortcls);
@@ -4138,8 +3749,7 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
 	nullsFirst = (bool *) palloc(numsortkeys * sizeof(bool));
 
 	numsortkeys = 0;
-	foreach(l, sortcls)
-	{
+	foreach(l, sortcls) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, sub_tlist);
 
@@ -4150,9 +3760,8 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
 		numsortkeys++;
 	}
 
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, -1.0);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, -1.0);
 }
 
 /*
@@ -4169,18 +3778,15 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
  * is used from the SortGroupClause entries.
  */
 Sort *
-make_sort_from_groupcols(PlannerInfo *root,
-						 List *groupcls,
-						 AttrNumber *grpColIdx,
-						 Plan *lefttree)
-{
-	List	   *sub_tlist = lefttree->targetlist;
-	ListCell   *l;
-	int			numsortkeys;
+make_sort_from_groupcols(PlannerInfo *root, List *groupcls,
+		AttrNumber *grpColIdx, Plan *lefttree) {
+	List *sub_tlist = lefttree->targetlist;
+	ListCell *l;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Convert list-ish representation to arrays wanted by executor */
 	numsortkeys = list_length(groupcls);
@@ -4190,8 +3796,7 @@ make_sort_from_groupcols(PlannerInfo *root,
 	nullsFirst = (bool *) palloc(numsortkeys * sizeof(bool));
 
 	numsortkeys = 0;
-	foreach(l, groupcls)
-	{
+	foreach(l, groupcls) {
 		SortGroupClause *grpcl = (SortGroupClause *) lfirst(l);
 		TargetEntry *tle = get_tle_by_resno(sub_tlist, grpColIdx[numsortkeys]);
 
@@ -4205,16 +3810,14 @@ make_sort_from_groupcols(PlannerInfo *root,
 		numsortkeys++;
 	}
 
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, -1.0);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, -1.0);
 }
 
 static Material *
-make_material(Plan *lefttree)
-{
-	Material   *node = makeNode(Material);
-	Plan	   *plan = &node->plan;
+make_material(Plan *lefttree) {
+	Material *node = makeNode(Material);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = lefttree->targetlist;
@@ -4236,19 +3839,15 @@ make_material(Plan *lefttree)
  * until setrefs.c is run?
  */
 Plan *
-materialize_finished_plan(Plan *subplan)
-{
-	Plan	   *matplan;
-	Path		matpath;		/* dummy for result of cost_material */
+materialize_finished_plan(Plan *subplan) {
+	Plan *matplan;
+	Path matpath; /* dummy for result of cost_material */
 
 	matplan = (Plan *) make_material(subplan);
 
 	/* Set cost data */
-	cost_material(&matpath,
-				  subplan->startup_cost,
-				  subplan->total_cost,
-				  subplan->plan_rows,
-				  subplan->plan_width);
+	cost_material(&matpath, subplan->startup_cost, subplan->total_cost,
+			subplan->plan_rows, subplan->plan_width);
 	matplan->startup_cost = matpath.startup_cost;
 	matplan->total_cost = matpath.total_cost;
 	matplan->plan_rows = subplan->plan_rows;
@@ -4262,16 +3861,13 @@ materialize_finished_plan(Plan *subplan)
 }
 
 Agg *
-make_agg(PlannerInfo *root, List *tlist, List *qual,
-		 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
-		 int numGroupCols, AttrNumber *grpColIdx, Oid *grpOperators,
-		 long numGroups,
-		 Plan *lefttree)
-{
-	Agg		   *node = makeNode(Agg);
-	Plan	   *plan = &node->plan;
-	Path		agg_path;		/* dummy for result of cost_agg */
-	QualCost	qual_cost;
+make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
+		const AggClauseCosts *aggcosts, int numGroupCols, AttrNumber *grpColIdx,
+		Oid *grpOperators, long numGroups, Plan *lefttree) {
+	Agg *node = makeNode(Agg);
+	Plan *plan = &node->plan;
+	Path agg_path; /* dummy for result of cost_agg */
+	QualCost qual_cost;
 
 	node->aggstrategy = aggstrategy;
 	node->numCols = numGroupCols;
@@ -4280,12 +3876,8 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 	node->numGroups = numGroups;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_agg(&agg_path, root,
-			 aggstrategy, aggcosts,
-			 numGroupCols, numGroups,
-			 lefttree->startup_cost,
-			 lefttree->total_cost,
-			 lefttree->plan_rows);
+	cost_agg(&agg_path, root, aggstrategy, aggcosts, numGroupCols, numGroups,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = agg_path.startup_cost;
 	plan->total_cost = agg_path.total_cost;
 
@@ -4307,8 +3899,7 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 	 * See notes in add_tlist_costs_to_plan about why only make_agg,
 	 * make_windowagg and make_group worry about tlist eval cost.
 	 */
-	if (qual)
-	{
+	if (qual) {
 		cost_qual_eval(&qual_cost, qual, root);
 		plan->startup_cost += qual_cost.startup;
 		plan->total_cost += qual_cost.startup;
@@ -4325,16 +3916,13 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 }
 
 WindowAgg *
-make_windowagg(PlannerInfo *root, List *tlist,
-			   List *windowFuncs, Index winref,
-			   int partNumCols, AttrNumber *partColIdx, Oid *partOperators,
-			   int ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators,
-			   int frameOptions, Node *startOffset, Node *endOffset,
-			   Plan *lefttree)
-{
-	WindowAgg  *node = makeNode(WindowAgg);
-	Plan	   *plan = &node->plan;
-	Path		windowagg_path; /* dummy for result of cost_windowagg */
+make_windowagg(PlannerInfo *root, List *tlist, List *windowFuncs, Index winref,
+		int partNumCols, AttrNumber *partColIdx, Oid *partOperators,
+		int ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators,
+		int frameOptions, Node *startOffset, Node *endOffset, Plan *lefttree) {
+	WindowAgg *node = makeNode(WindowAgg);
+	Plan *plan = &node->plan;
+	Path windowagg_path; /* dummy for result of cost_windowagg */
 
 	node->winref = winref;
 	node->partNumCols = partNumCols;
@@ -4348,11 +3936,8 @@ make_windowagg(PlannerInfo *root, List *tlist,
 	node->endOffset = endOffset;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_windowagg(&windowagg_path, root,
-				   windowFuncs, partNumCols, ordNumCols,
-				   lefttree->startup_cost,
-				   lefttree->total_cost,
-				   lefttree->plan_rows);
+	cost_windowagg(&windowagg_path, root, windowFuncs, partNumCols, ordNumCols,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = windowagg_path.startup_cost;
 	plan->total_cost = windowagg_path.total_cost;
 
@@ -4374,30 +3959,21 @@ make_windowagg(PlannerInfo *root, List *tlist,
 }
 
 Group *
-make_group(PlannerInfo *root,
-		   List *tlist,
-		   List *qual,
-		   int numGroupCols,
-		   AttrNumber *grpColIdx,
-		   Oid *grpOperators,
-		   double numGroups,
-		   Plan *lefttree)
-{
-	Group	   *node = makeNode(Group);
-	Plan	   *plan = &node->plan;
-	Path		group_path;		/* dummy for result of cost_group */
-	QualCost	qual_cost;
+make_group(PlannerInfo *root, List *tlist, List *qual, int numGroupCols,
+		AttrNumber *grpColIdx, Oid *grpOperators, double numGroups,
+		Plan *lefttree) {
+	Group *node = makeNode(Group);
+	Plan *plan = &node->plan;
+	Path group_path; /* dummy for result of cost_group */
+	QualCost qual_cost;
 
 	node->numCols = numGroupCols;
 	node->grpColIdx = grpColIdx;
 	node->grpOperators = grpOperators;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_group(&group_path, root,
-			   numGroupCols, numGroups,
-			   lefttree->startup_cost,
-			   lefttree->total_cost,
-			   lefttree->plan_rows);
+	cost_group(&group_path, root, numGroupCols, numGroups,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = group_path.startup_cost;
 	plan->total_cost = group_path.total_cost;
 
@@ -4416,8 +3992,7 @@ make_group(PlannerInfo *root,
 	 * See notes in add_tlist_costs_to_plan about why only make_agg,
 	 * make_windowagg and make_group worry about tlist eval cost.
 	 */
-	if (qual)
-	{
+	if (qual) {
 		cost_qual_eval(&qual_cost, qual, root);
 		plan->startup_cost += qual_cost.startup;
 		plan->total_cost += qual_cost.startup;
@@ -4439,15 +4014,14 @@ make_group(PlannerInfo *root,
  * already be sorted accordingly.
  */
 Unique *
-make_unique(Plan *lefttree, List *distinctList)
-{
-	Unique	   *node = makeNode(Unique);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
-	int			keyno = 0;
+make_unique(Plan *lefttree, List *distinctList) {
+	Unique *node = makeNode(Unique);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
+	int keyno = 0;
 	AttrNumber *uniqColIdx;
-	Oid		   *uniqOperators;
-	ListCell   *slitem;
+	Oid *uniqOperators;
+	ListCell *slitem;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4477,8 +4051,7 @@ make_unique(Plan *lefttree, List *distinctList)
 	uniqColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 	uniqOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-	foreach(slitem, distinctList)
-	{
+	foreach(slitem, distinctList) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, plan->targetlist);
 
@@ -4502,16 +4075,15 @@ make_unique(Plan *lefttree, List *distinctList)
  */
 SetOp *
 make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
-		   List *distinctList, AttrNumber flagColIdx, int firstFlag,
-		   long numGroups, double outputRows)
-{
-	SetOp	   *node = makeNode(SetOp);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
-	int			keyno = 0;
+		List *distinctList, AttrNumber flagColIdx, int firstFlag,
+		long numGroups, double outputRows) {
+	SetOp *node = makeNode(SetOp);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
+	int keyno = 0;
 	AttrNumber *dupColIdx;
-	Oid		   *dupOperators;
-	ListCell   *slitem;
+	Oid *dupOperators;
+	ListCell *slitem;
 
 	copy_plan_costsize(plan, lefttree);
 	plan->plan_rows = outputRows;
@@ -4535,8 +4107,7 @@ make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
 	dupColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 	dupOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-	foreach(slitem, distinctList)
-	{
+	foreach(slitem, distinctList) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, plan->targetlist);
 
@@ -4563,10 +4134,9 @@ make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
  *	  Build a LockRows plan node
  */
 LockRows *
-make_lockrows(Plan *lefttree, List *rowMarks, int epqParam)
-{
-	LockRows   *node = makeNode(LockRows);
-	Plan	   *plan = &node->plan;
+make_lockrows(Plan *lefttree, List *rowMarks, int epqParam) {
+	LockRows *node = makeNode(LockRows);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4593,10 +4163,9 @@ make_lockrows(Plan *lefttree, List *rowMarks, int epqParam)
  */
 Limit *
 make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
-		   int64 offset_est, int64 count_est)
-{
-	Limit	   *node = makeNode(Limit);
-	Plan	   *plan = &node->plan;
+		int64 offset_est, int64 count_est) {
+	Limit *node = makeNode(Limit);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4609,9 +4178,8 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 	 * When the offset or count couldn't be estimated, use 10% of the
 	 * estimated number of rows emitted from the subplan.
 	 */
-	if (offset_est != 0)
-	{
-		double		offset_rows;
+	if (offset_est != 0) {
+		double offset_rows;
 
 		if (offset_est > 0)
 			offset_rows = (double) offset_est;
@@ -4620,17 +4188,15 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 		if (offset_rows > plan->plan_rows)
 			offset_rows = plan->plan_rows;
 		if (plan->plan_rows > 0)
-			plan->startup_cost +=
-				(plan->total_cost - plan->startup_cost)
-				* offset_rows / plan->plan_rows;
+			plan->startup_cost += (plan->total_cost - plan->startup_cost)
+					* offset_rows / plan->plan_rows;
 		plan->plan_rows -= offset_rows;
 		if (plan->plan_rows < 1)
 			plan->plan_rows = 1;
 	}
 
-	if (count_est != 0)
-	{
-		double		count_rows;
+	if (count_est != 0) {
+		double count_rows;
 
 		if (count_est > 0)
 			count_rows = (double) count_est;
@@ -4639,9 +4205,9 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 		if (count_rows > plan->plan_rows)
 			count_rows = plan->plan_rows;
 		if (plan->plan_rows > 0)
-			plan->total_cost = plan->startup_cost +
-				(plan->total_cost - plan->startup_cost)
-				* count_rows / plan->plan_rows;
+			plan->total_cost = plan->startup_cost
+					+ (plan->total_cost - plan->startup_cost) * count_rows
+							/ plan->plan_rows;
 		plan->plan_rows = count_rows;
 		if (plan->plan_rows < 1)
 			plan->plan_rows = 1;
@@ -4668,25 +4234,20 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
  * cost.  In either case, tlist eval cost is not to be included here.
  */
 Result *
-make_result(PlannerInfo *root,
-			List *tlist,
-			Node *resconstantqual,
-			Plan *subplan)
-{
-	Result	   *node = makeNode(Result);
-	Plan	   *plan = &node->plan;
+make_result(PlannerInfo *root, List *tlist, Node *resconstantqual,
+		Plan *subplan) {
+	Result *node = makeNode(Result);
+	Plan *plan = &node->plan;
 
 	if (subplan)
 		copy_plan_costsize(plan, subplan);
-	else
-	{
+	else {
 		plan->startup_cost = 0;
 		plan->total_cost = cpu_tuple_cost;
-		plan->plan_rows = 1;	/* wrong if we have a set-valued function? */
-		plan->plan_width = 0;	/* XXX is it worth being smarter? */
-		if (resconstantqual)
-		{
-			QualCost	qual_cost;
+		plan->plan_rows = 1; /* wrong if we have a set-valued function? */
+		plan->plan_width = 0; /* XXX is it worth being smarter? */
+		if (resconstantqual) {
+			QualCost qual_cost;
 
 			cost_qual_eval(&qual_cost, (List *) resconstantqual, root);
 			/* resconstantqual is evaluated once at startup */
@@ -4715,25 +4276,22 @@ make_result(PlannerInfo *root,
  * But we might want to make it look better sometime.
  */
 ModifyTable *
-make_modifytable(PlannerInfo *root,
-				 CmdType operation, bool canSetTag,
-				 List *resultRelations, List *subplans,
-				 List *withCheckOptionLists, List *returningLists,
-				 List *rowMarks, int epqParam)
-{
+make_modifytable(PlannerInfo *root, CmdType operation, bool canSetTag,
+		List *resultRelations, List *subplans, List *withCheckOptionLists,
+		List *returningLists, List *rowMarks, int epqParam) {
 	ModifyTable *node = makeNode(ModifyTable);
-	Plan	   *plan = &node->plan;
-	double		total_size;
-	List	   *fdw_private_list;
-	ListCell   *subnode;
-	ListCell   *lc;
-	int			i;
+	Plan *plan = &node->plan;
+	double total_size;
+	List *fdw_private_list;
+	ListCell *subnode;
+	ListCell *lc;
+	int i;
 
 	Assert(list_length(resultRelations) == list_length(subplans));
-	Assert(withCheckOptionLists == NIL ||
-		   list_length(resultRelations) == list_length(withCheckOptionLists));
-	Assert(returningLists == NIL ||
-		   list_length(resultRelations) == list_length(returningLists));
+	Assert(
+			withCheckOptionLists == NIL || list_length(resultRelations) == list_length(withCheckOptionLists));
+	Assert(
+			returningLists == NIL || list_length(resultRelations) == list_length(returningLists));
 
 	/*
 	 * Compute cost as sum of subplan costs.
@@ -4742,11 +4300,10 @@ make_modifytable(PlannerInfo *root,
 	plan->total_cost = 0;
 	plan->plan_rows = 0;
 	total_size = 0;
-	foreach(subnode, subplans)
-	{
-		Plan	   *subplan = (Plan *) lfirst(subnode);
+	foreach(subnode, subplans) {
+		Plan *subplan = (Plan *) lfirst(subnode);
 
-		if (subnode == list_head(subplans))		/* first node? */
+		if (subnode == list_head(subplans)) /* first node? */
 			plan->startup_cost = subplan->startup_cost;
 		plan->total_cost += subplan->total_cost;
 		plan->plan_rows += subplan->plan_rows;
@@ -4766,7 +4323,7 @@ make_modifytable(PlannerInfo *root,
 	node->operation = operation;
 	node->canSetTag = canSetTag;
 	node->resultRelations = resultRelations;
-	node->resultRelIndex = -1;	/* will be set correctly in setrefs.c */
+	node->resultRelIndex = -1; /* will be set correctly in setrefs.c */
 	node->plans = subplans;
 	node->withCheckOptionLists = withCheckOptionLists;
 	node->returningLists = returningLists;
@@ -4779,11 +4336,10 @@ make_modifytable(PlannerInfo *root,
 	 */
 	fdw_private_list = NIL;
 	i = 0;
-	foreach(lc, resultRelations)
-	{
-		Index		rti = lfirst_int(lc);
+	foreach(lc, resultRelations) {
+		Index rti = lfirst_int(lc);
 		FdwRoutine *fdwroutine;
-		List	   *fdw_private;
+		List *fdw_private;
 
 		/*
 		 * If possible, we want to get the FdwRoutine from our RelOptInfo for
@@ -4792,26 +4348,21 @@ make_modifytable(PlannerInfo *root,
 		 * so it's not a baserel; and there are also corner cases for
 		 * updatable views where the target rel isn't a baserel.)
 		 */
-		if (rti < root->simple_rel_array_size &&
-			root->simple_rel_array[rti] != NULL)
-		{
-			RelOptInfo *resultRel = root->simple_rel_array[rti];
+		if (rti
+				< root->simple_rel_array_size&& root->simple_rel_array[rti] != NULL) {RelOptInfo *resultRel = root->simple_rel_array[rti];
 
-			fdwroutine = resultRel->fdwroutine;
-		}
+		fdwroutine = resultRel->fdwroutine;
+	} else {
+		RangeTblEntry *rte = planner_rt_fetch(rti, root);
+
+		Assert(rte->rtekind == RTE_RELATION);
+		if (rte->relkind == RELKIND_FOREIGN_TABLE)
+		fdwroutine = GetFdwRoutineByRelId(rte->relid);
 		else
-		{
-			RangeTblEntry *rte = planner_rt_fetch(rti, root);
-
-			Assert(rte->rtekind == RTE_RELATION);
-			if (rte->relkind == RELKIND_FOREIGN_TABLE)
-				fdwroutine = GetFdwRoutineByRelId(rte->relid);
-			else
-				fdwroutine = NULL;
-		}
+		fdwroutine = NULL;
+	}
 
-		if (fdwroutine != NULL &&
-			fdwroutine->PlanForeignModify != NULL)
+		if (fdwroutine != NULL && fdwroutine->PlanForeignModify != NULL)
 			fdw_private = fdwroutine->PlanForeignModify(root, node, rti, i);
 		else
 			fdw_private = NIL;
@@ -4827,26 +4378,48 @@ make_modifytable(PlannerInfo *root,
  * is_projection_capable_plan
  *		Check whether a given Plan node is able to do projection.
  */
-bool
-is_projection_capable_plan(Plan *plan)
-{
+bool is_projection_capable_plan(Plan *plan) {
 	/* Most plan types can project, so just list the ones that can't */
-	switch (nodeTag(plan))
-	{
-		case T_Hash:
-		case T_Material:
-		case T_Sort:
-		case T_Unique:
-		case T_SetOp:
-		case T_LockRows:
-		case T_Limit:
-		case T_ModifyTable:
-		case T_Append:
-		case T_MergeAppend:
-		case T_RecursiveUnion:
-			return false;
-		default:
-			break;
+	switch (nodeTag(plan)) {
+	case T_Hash:
+	case T_Material:
+	case T_Sort:
+	case T_Unique:
+	case T_SetOp:
+	case T_LockRows:
+	case T_Limit:
+	case T_ModifyTable:
+	case T_Append:
+	case T_MergeAppend:
+	case T_RecursiveUnion:
+		return false;
+	default:
+		break;
 	}
 	return true;
 }
+void print_injected_cost(const char *rel, int rows,double old_cost , double cost_result) {
+
+	fprintf(file, "%s	%d	%.2f	%.2f\n", rel, rows, old_cost, cost_result);
+
+}
+int get_base_rows_from_memo(char *name, int level) {
+
+	if (enable_cost_check) {
+
+		return get_baserel_memo_size(name, level);
+
+	}
+
+	return (-1);
+}
+int get_join_rows_from_memo(char *name, int level) {
+
+	if (enable_cost_check) {
+
+		return get_join_memo_size(name, level);
+
+	}
+
+	return (-1);
+}
diff --git a/src/backend/optimizer/plan/planmain.c b/src/backend/optimizer/plan/planmain.c
index 3ea916f..6680216 100644
--- a/src/backend/optimizer/plan/planmain.c
+++ b/src/backend/optimizer/plan/planmain.c
@@ -26,7 +26,6 @@
 #include "optimizer/placeholder.h"
 #include "optimizer/planmain.h"
 
-
 /*
  * query_planner
  *	  Generate a path (that is, a simplified plan) for a basic query,
@@ -242,3 +241,4 @@ query_planner(PlannerInfo *root, List *tlist,
 
 	return final_rel;
 }
+
diff --git a/src/backend/optimizer/plan/planner.c b/src/backend/optimizer/plan/planner.c
index 35bda67..45e84a6 100644
--- a/src/backend/optimizer/plan/planner.c
+++ b/src/backend/optimizer/plan/planner.c
@@ -42,9 +42,12 @@
 #include "utils/selfuncs.h"
 
 
+
+
 /* GUC parameter */
 double		cursor_tuple_fraction = DEFAULT_CURSOR_TUPLE_FRACTION;
 
+
 /* Hook for plugins to get control in planner() */
 planner_hook_type planner_hook = NULL;
 
@@ -151,6 +154,9 @@ standard_planner(Query *parse, int cursorOptions, ParamListInfo boundParams)
 	ListCell   *lp,
 			   *lr;
 
+
+
+
 	/* Cursor options may come from caller or from DECLARE CURSOR stmt */
 	if (parse->utilityStmt &&
 		IsA(parse->utilityStmt, DeclareCursorStmt))
@@ -1438,13 +1444,14 @@ grouping_planner(PlannerInfo *root, double tuple_fraction)
 			best_path = cheapest_path;
 		else
 			best_path = sorted_path;
-
+	//
 		/*
 		 * Check to see if it's possible to optimize MIN/MAX aggregates. If
 		 * so, we will forget all the work we did so far to choose a "regular"
 		 * path ... but we had to do it anyway to be able to tell which way is
 		 * cheaper.
 		 */
+		//check_memo_costs(root);
 		result_plan = optimize_minmax_aggregates(root,
 												 tlist,
 												 &agg_costs,
diff --git a/src/backend/optimizer/util/pathnode.c b/src/backend/optimizer/util/pathnode.c
index b79af7a..e8be972 100644
--- a/src/backend/optimizer/util/pathnode.c
+++ b/src/backend/optimizer/util/pathnode.c
@@ -27,6 +27,7 @@
 #include "parser/parsetree.h"
 #include "utils/lsyscache.h"
 #include "utils/selfuncs.h"
+#include "storage/fd.h"
 
 
 typedef enum
@@ -2067,3 +2068,73 @@ reparameterize_path(PlannerInfo *root, Path *path,
 	}
 	return NULL;
 }
+int get_baserel_memo_size(char *rel_name, int level) {
+	FILE *file = AllocateFile("memoTxt.txt", "rb");
+	char buffer[200];
+	char relname[200];
+	int level_n;
+	int estsize;
+	int actsize;
+	int max = 200;
+	printf("Checking rows for %s at level %d\n", rel_name, level);
+		fflush(stdout);
+	while (fgets(buffer, max, file) != NULL) {
+
+		if (sscanf(buffer, "%d %s %d %d", &level_n,relname, &estsize, &actsize) > 0) {
+			//printf("token rel: %s\n\r", buffer);
+			if (!strcmp(relname, rel_name) && level_n == level) {
+			printf("found rel: %s at level %d\n", rel_name,level_n);
+			fflush(stdout);
+				return actsize;
+			}
+
+		}
+
+	}
+
+	return -1;
+
+}
+
+int get_join_memo_size(char *rel_names, int level) {
+
+	FILE *file = AllocateFile("memoTxt.txt", "rb");
+	int max = strlen(rel_names);
+	char buffer[200];
+	char relnames[max];
+	int level_n;
+	int estsize;
+	int actsize;
+	const char s[2] = ",";
+
+	char *found;
+
+	char *rel_name;
+	printf("Checking rows for %s at level %d\n", rel_names, level);
+	fflush(stdout);
+	while (fgets(buffer, 200, file) != NULL) {
+		if (sscanf(buffer, "%d [ %s ] %d %d",&level_n, relnames, &estsize, &actsize) > 0) {
+			if (max == strlen(relnames) && level == level_n) {
+				rel_name = strtok(relnames, s);
+				while (rel_name != NULL) {
+
+					found = strstr(rel_names, rel_name);
+					if (found == NULL)
+						break;
+					rel_name = strtok(NULL, s);
+
+				}
+				if (found != NULL) {
+					printf("found rel: %s at level %d\n", rel_names,level_n);
+								fflush(stdout);
+					return actsize;
+				}
+
+			}
+
+		}
+	}
+
+	return -1;
+
+}
diff --git a/src/backend/optimizer/util/plancat.c b/src/backend/optimizer/util/plancat.c
index 73ba2f6..b635661 100644
--- a/src/backend/optimizer/util/plancat.c
+++ b/src/backend/optimizer/util/plancat.c
@@ -106,7 +106,7 @@ get_relation_info(PlannerInfo *root, Oid relationObjectId, bool inhparent,
 	rel->min_attr = FirstLowInvalidHeapAttributeNumber + 1;
 	rel->max_attr = RelationGetNumberOfAttributes(relation);
 	rel->reltablespace = RelationGetForm(relation)->reltablespace;
-
+	rel->rel_name = RelationGetRelationName(relation);
 	Assert(rel->max_attr >= rel->min_attr);
 	rel->attr_needed = (Relids *)
 		palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
diff --git a/src/backend/optimizer/util/relnode.c b/src/backend/optimizer/util/relnode.c
index 8ae8f55..f6b97e3 100644
--- a/src/backend/optimizer/util/relnode.c
+++ b/src/backend/optimizer/util/relnode.c
@@ -13,7 +13,8 @@
  *-------------------------------------------------------------------------
  */
 #include "postgres.h"
-
+#include "stdio.h"
+#include "unistd.h"
 #include "optimizer/cost.h"
 #include "optimizer/pathnode.h"
 #include "optimizer/paths.h"
@@ -21,51 +22,49 @@
 #include "optimizer/plancat.h"
 #include "optimizer/restrictinfo.h"
 #include "utils/hsearch.h"
-
-
-typedef struct JoinHashEntry
-{
-	Relids		join_relids;	/* hash key --- MUST BE FIRST */
+#include "lib/stringinfo.h"
+#include "nodes/nodes.h"
+#include "utils/rel.h"
+#include "catalog/objectaddress.h"
+#include "catalog/namespace.h"
+#include "c.h"
+#include "storage/fd.h"
+
+typedef struct JoinHashEntry {
+	Relids join_relids; /* hash key --- MUST BE FIRST */
 	RelOptInfo *join_rel;
 } JoinHashEntry;
 
 static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
-					RelOptInfo *input_rel);
-static List *build_joinrel_restrictlist(PlannerInfo *root,
-						   RelOptInfo *joinrel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel);
-static void build_joinrel_joinlist(RelOptInfo *joinrel,
-					   RelOptInfo *outer_rel,
-					   RelOptInfo *inner_rel);
-static List *subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
-							  List *joininfo_list,
-							  List *new_restrictlist);
-static List *subbuild_joinrel_joinlist(RelOptInfo *joinrel,
-						  List *joininfo_list,
-						  List *new_joininfo);
+		RelOptInfo *input_rel);
 
+static List *build_joinrel_restrictlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel);
+static void build_joinrel_joinlist(RelOptInfo *joinrel, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel);
+static List *subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
+		List *joininfo_list, List *new_restrictlist);
+static List *subbuild_joinrel_joinlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_joininfo);
 
 /*
  * setup_simple_rel_arrays
  *	  Prepare the arrays we use for quickly accessing base relations.
  */
-void
-setup_simple_rel_arrays(PlannerInfo *root)
-{
-	Index		rti;
-	ListCell   *lc;
+void setup_simple_rel_arrays(PlannerInfo *root) {
+	Index rti;
+	ListCell *lc;
 
 	/* Arrays are accessed using RT indexes (1..N) */
 	root->simple_rel_array_size = list_length(root->parse->rtable) + 1;
 
 	/* simple_rel_array is initialized to all NULLs */
-	root->simple_rel_array = (RelOptInfo **)
-		palloc0(root->simple_rel_array_size * sizeof(RelOptInfo *));
+	root->simple_rel_array = (RelOptInfo **) palloc0(
+			root->simple_rel_array_size * sizeof(RelOptInfo *));
 
 	/* simple_rte_array is an array equivalent of the rtable list */
-	root->simple_rte_array = (RangeTblEntry **)
-		palloc0(root->simple_rel_array_size * sizeof(RangeTblEntry *));
+	root->simple_rte_array = (RangeTblEntry **) palloc0(
+			root->simple_rel_array_size * sizeof(RangeTblEntry *));
 	rti = 1;
 	foreach(lc, root->parse->rtable)
 	{
@@ -80,11 +79,10 @@ setup_simple_rel_arrays(PlannerInfo *root)
  *	  Construct a new RelOptInfo for a base relation or 'other' relation.
  */
 RelOptInfo *
-build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
-{
+build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 	RelOptInfo *rel;
 	RangeTblEntry *rte;
-
+	int memo_size;
 	/* Rel should not exist already */
 	Assert(relid > 0 && relid < root->simple_rel_array_size);
 	if (root->simple_rel_array[relid] != NULL)
@@ -123,6 +121,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	rel->subplan_params = NIL;
 	rel->fdwroutine = NULL;
 	rel->fdw_private = NULL;
+	rel->workspace = NULL;
 	rel->baserestrictinfo = NIL;
 	rel->baserestrictcost.startup = 0;
 	rel->baserestrictcost.per_tuple = 0;
@@ -130,34 +129,40 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	rel->has_eclass_joins = false;
 
 	/* Check type of rtable entry */
-	switch (rte->rtekind)
-	{
-		case RTE_RELATION:
-			/* Table --- retrieve statistics from the system catalogs */
-			get_relation_info(root, rte->relid, rte->inh, rel);
-			break;
-		case RTE_SUBQUERY:
-		case RTE_FUNCTION:
-		case RTE_VALUES:
-		case RTE_CTE:
+	switch (rte->rtekind) {
+	case RTE_RELATION:
+
+		/* Table --- retrieve statistics from the system catalogs */
+		get_relation_info(root, rte->relid, rte->inh, rel);
+		/*hack for memo*/
+		if (enable_memo) {
+			printf("memo status : %d", enable_memo);
+			memo_size = get_baserel_memo_size(rel->rel_name,root->query_level);
+			//printf("rel size was : %d", memo_size );
+			rel->rows = memo_size;
+		}
+		break;
+	case RTE_SUBQUERY:
+	case RTE_FUNCTION:
+	case RTE_VALUES:
+	case RTE_CTE:
 
-			/*
-			 * Subquery, function, or values list --- set up attr range and
-			 * arrays
-			 *
-			 * Note: 0 is included in range to support whole-row Vars
-			 */
-			rel->min_attr = 0;
-			rel->max_attr = list_length(rte->eref->colnames);
-			rel->attr_needed = (Relids *)
-				palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
-			rel->attr_widths = (int32 *)
-				palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(int32));
-			break;
-		default:
-			elog(ERROR, "unrecognized RTE kind: %d",
-				 (int) rte->rtekind);
-			break;
+		/*
+		 * Subquery, function, or values list --- set up attr range and
+		 * arrays
+		 *
+		 * Note: 0 is included in range to support whole-row Vars
+		 */
+		rel->min_attr = 0;
+		rel->max_attr = list_length(rte->eref->colnames);
+		rel->attr_needed = (Relids *) palloc0(
+				(rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
+		rel->attr_widths = (int32 *) palloc0(
+				(rel->max_attr - rel->min_attr + 1) * sizeof(int32));
+		break;
+	default:
+		elog(ERROR, "unrecognized RTE kind: %d", (int ) rte->rtekind);
+		break;
 	}
 
 	/* Save the finished struct in the query's simple_rel_array */
@@ -169,9 +174,8 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	 * not in the main join tree, but we will need RelOptInfos to plan access
 	 * to them.
 	 */
-	if (rte->inh)
-	{
-		ListCell   *l;
+	if (rte->inh) {
+		ListCell *l;
 
 		foreach(l, root->append_rel_list)
 		{
@@ -182,7 +186,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 				continue;
 
 			(void) build_simple_rel(root, appinfo->child_relid,
-									RELOPT_OTHER_MEMBER_REL);
+					RELOPT_OTHER_MEMBER_REL);
 		}
 	}
 
@@ -194,14 +198,12 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
  *	  Find a base or other relation entry, which must already exist.
  */
 RelOptInfo *
-find_base_rel(PlannerInfo *root, int relid)
-{
+find_base_rel(PlannerInfo *root, int relid) {
 	RelOptInfo *rel;
 
 	Assert(relid > 0);
 
-	if (relid < root->simple_rel_array_size)
-	{
+	if (relid < root->simple_rel_array_size) {
 		rel = root->simple_rel_array[relid];
 		if (rel)
 			return rel;
@@ -209,19 +211,17 @@ find_base_rel(PlannerInfo *root, int relid)
 
 	elog(ERROR, "no relation entry for relid %d", relid);
 
-	return NULL;				/* keep compiler quiet */
+	return NULL; /* keep compiler quiet */
 }
 
 /*
  * build_join_rel_hash
  *	  Construct the auxiliary hash table for join relations.
  */
-static void
-build_join_rel_hash(PlannerInfo *root)
-{
-	HTAB	   *hashtab;
-	HASHCTL		hash_ctl;
-	ListCell   *l;
+static void build_join_rel_hash(PlannerInfo *root) {
+	HTAB *hashtab;
+	HASHCTL hash_ctl;
+	ListCell *l;
 
 	/* Create the hash table */
 	MemSet(&hash_ctl, 0, sizeof(hash_ctl));
@@ -230,22 +230,18 @@ build_join_rel_hash(PlannerInfo *root)
 	hash_ctl.hash = bitmap_hash;
 	hash_ctl.match = bitmap_match;
 	hash_ctl.hcxt = CurrentMemoryContext;
-	hashtab = hash_create("JoinRelHashTable",
-						  256L,
-						  &hash_ctl,
-					HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
+	hashtab = hash_create("JoinRelHashTable", 256L, &hash_ctl,
+	HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
 
 	/* Insert all the already-existing joinrels */
 	foreach(l, root->join_rel_list)
 	{
 		RelOptInfo *rel = (RelOptInfo *) lfirst(l);
 		JoinHashEntry *hentry;
-		bool		found;
+		bool found;
 
-		hentry = (JoinHashEntry *) hash_search(hashtab,
-											   &(rel->relids),
-											   HASH_ENTER,
-											   &found);
+		hentry = (JoinHashEntry *) hash_search(hashtab, &(rel->relids),
+				HASH_ENTER, &found);
 		Assert(!found);
 		hentry->join_rel = rel;
 	}
@@ -259,8 +255,7 @@ build_join_rel_hash(PlannerInfo *root)
  *	  or NULL if none exists.  This is for join relations.
  */
 RelOptInfo *
-find_join_rel(PlannerInfo *root, Relids relids)
-{
+find_join_rel(PlannerInfo *root, Relids relids) {
 	/*
 	 * Switch to using hash lookup when list grows "too long".	The threshold
 	 * is arbitrary and is known only here.
@@ -276,21 +271,17 @@ find_join_rel(PlannerInfo *root, Relids relids)
 	 * so would force relids out of a register and thus probably slow down the
 	 * list-search case.
 	 */
-	if (root->join_rel_hash)
-	{
-		Relids		hashkey = relids;
+	if (root->join_rel_hash) {
+		Relids hashkey = relids;
 		JoinHashEntry *hentry;
 
-		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash,
-											   &hashkey,
-											   HASH_FIND,
-											   NULL);
+		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash, &hashkey,
+				HASH_FIND,
+				NULL);
 		if (hentry)
 			return hentry->join_rel;
-	}
-	else
-	{
-		ListCell   *l;
+	} else {
+		ListCell *l;
 
 		foreach(l, root->join_rel_list)
 		{
@@ -321,32 +312,30 @@ find_join_rel(PlannerInfo *root, Relids relids)
  * duplicated calculation of the restrictlist...
  */
 RelOptInfo *
-build_join_rel(PlannerInfo *root,
-			   Relids joinrelids,
-			   RelOptInfo *outer_rel,
-			   RelOptInfo *inner_rel,
-			   SpecialJoinInfo *sjinfo,
-			   List **restrictlist_ptr)
-{
+build_join_rel(PlannerInfo *root, Relids joinrelids, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo, List **restrictlist_ptr) {
 	RelOptInfo *joinrel;
-	List	   *restrictlist;
+	//Relation relation;
+	List *restrictlist;
+	int name_len = 0;
+
+	int memo_size = 0;
+	char *rel_names;
+	StringInfoData join_name;
 
 	/*
 	 * See if we already have a joinrel for this set of base rels.
 	 */
 	joinrel = find_join_rel(root, joinrelids);
 
-	if (joinrel)
-	{
+	if (joinrel) {
 		/*
 		 * Yes, so we only need to figure the restrictlist for this particular
 		 * pair of component relations.
 		 */
 		if (restrictlist_ptr)
-			*restrictlist_ptr = build_joinrel_restrictlist(root,
-														   joinrel,
-														   outer_rel,
-														   inner_rel);
+			*restrictlist_ptr = build_joinrel_restrictlist(root, joinrel,
+					outer_rel, inner_rel);
 		return joinrel;
 	}
 
@@ -367,7 +356,7 @@ build_join_rel(PlannerInfo *root,
 	joinrel->cheapest_total_path = NULL;
 	joinrel->cheapest_unique_path = NULL;
 	joinrel->cheapest_parameterized_paths = NIL;
-	joinrel->relid = 0;			/* indicates not a baserel */
+	joinrel->relid = 0; /* indicates not a baserel */
 	joinrel->rtekind = RTE_JOIN;
 	joinrel->min_attr = 0;
 	joinrel->max_attr = 0;
@@ -385,12 +374,25 @@ build_join_rel(PlannerInfo *root,
 	joinrel->subplan_params = NIL;
 	joinrel->fdwroutine = NULL;
 	joinrel->fdw_private = NULL;
+	joinrel->workspace = NULL;
 	joinrel->baserestrictinfo = NIL;
 	joinrel->baserestrictcost.startup = 0;
 	joinrel->baserestrictcost.per_tuple = 0;
 	joinrel->joininfo = NIL;
 	joinrel->has_eclass_joins = false;
 
+	/* We build the join mane  separated by colons using names of childs*/
+	/* see stringinfo.h for an explanation of this maneuver */
+	initStringInfo(&join_name);
+	appendStringInfoString(&join_name, inner_rel->rel_name);
+	appendStringInfoChar(&join_name, ',');
+	appendStringInfoString(&join_name, outer_rel->rel_name);
+	joinrel->rel_name = join_name.data;
+	name_len = strlen(join_name.data) + 1;
+	rel_names = palloc(name_len * sizeof(joinrel->rel_name));
+	memset(rel_names, '\0', name_len);
+	strcpy(rel_names, joinrel->rel_name);
+
 	/*
 	 * Create a new tlist containing just the vars that need to be output from
 	 * this join (ie, are needed for higher joinclauses or final output).
@@ -408,8 +410,8 @@ build_join_rel(PlannerInfo *root,
 	 * caller might or might not need the restrictlist, but I need it anyway
 	 * for set_joinrel_size_estimates().)
 	 */
-	restrictlist = build_joinrel_restrictlist(root, joinrel,
-											  outer_rel, inner_rel);
+	restrictlist = build_joinrel_restrictlist(root, joinrel, outer_rel,
+			inner_rel);
 	if (restrictlist_ptr)
 		*restrictlist_ptr = restrictlist;
 	build_joinrel_joinlist(joinrel, outer_rel, inner_rel);
@@ -423,8 +425,16 @@ build_join_rel(PlannerInfo *root,
 	/*
 	 * Set estimates of the joinrel's size.
 	 */
-	set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel,
-							   sjinfo, restrictlist);
+
+	/* hack for memo injection*/ // to-do set_rel
+	if (enable_memo) {
+		memo_size = get_join_memo_size(rel_names,root->query_level);
+		if (memo_size > -1)
+			joinrel->rows = memo_size;
+
+	} else
+		set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel, sjinfo,
+				restrictlist);
 
 	/*
 	 * Add the joinrel to the query's joinrel list, and store it into the
@@ -433,15 +443,12 @@ build_join_rel(PlannerInfo *root,
 	 */
 	root->join_rel_list = lappend(root->join_rel_list, joinrel);
 
-	if (root->join_rel_hash)
-	{
+	if (root->join_rel_hash) {
 		JoinHashEntry *hentry;
-		bool		found;
+		bool found;
 
 		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash,
-											   &(joinrel->relids),
-											   HASH_ENTER,
-											   &found);
+				&(joinrel->relids), HASH_ENTER, &found);
 		Assert(!found);
 		hentry->join_rel = joinrel;
 	}
@@ -452,12 +459,11 @@ build_join_rel(PlannerInfo *root,
 	 * of members should be for equality, but some of the level 1 rels might
 	 * have been joinrels already, so we can only assert <=.
 	 */
-	if (root->join_rel_level)
-	{
+	if (root->join_rel_level) {
 		Assert(root->join_cur_level > 0);
 		Assert(root->join_cur_level <= bms_num_members(joinrel->relids));
-		root->join_rel_level[root->join_cur_level] =
-			lappend(root->join_rel_level[root->join_cur_level], joinrel);
+		root->join_rel_level[root->join_cur_level] = lappend(
+				root->join_rel_level[root->join_cur_level], joinrel);
 	}
 
 	return joinrel;
@@ -475,18 +481,16 @@ build_join_rel(PlannerInfo *root,
  * We also compute the expected width of the join's output, making use
  * of data that was cached at the baserel level by set_rel_width().
  */
-static void
-build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
-					RelOptInfo *input_rel)
-{
-	Relids		relids = joinrel->relids;
-	ListCell   *vars;
+static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *input_rel) {
+	Relids relids = joinrel->relids;
+	ListCell *vars;
 
 	foreach(vars, input_rel->reltargetlist)
 	{
-		Var		   *var = (Var *) lfirst(vars);
+		Var *var = (Var *) lfirst(vars);
 		RelOptInfo *baserel;
-		int			ndx;
+		int ndx;
 
 		/*
 		 * Ignore PlaceHolderVars in the input tlists; we'll make our own
@@ -502,15 +506,14 @@ build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
 		 */
 		if (!IsA(var, Var))
 			elog(ERROR, "unexpected node type in reltargetlist: %d",
-				 (int) nodeTag(var));
+					(int) nodeTag(var));
 
 		/* Get the Var's original base rel */
 		baserel = find_base_rel(root, var->varno);
 
 		/* Is it still needed above this joinrel? */
 		ndx = var->varattno - baserel->min_attr;
-		if (bms_nonempty_difference(baserel->attr_needed[ndx], relids))
-		{
+		if (bms_nonempty_difference(baserel->attr_needed[ndx], relids)) {
 			/* Yup, add it to the output */
 			joinrel->reltargetlist = lappend(joinrel->reltargetlist, var);
 			joinrel->width += baserel->attr_widths[ndx];
@@ -561,12 +564,9 @@ build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
  * the original nodes in the lists made for the join relation.
  */
 static List *
-build_joinrel_restrictlist(PlannerInfo *root,
-						   RelOptInfo *joinrel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel)
-{
-	List	   *result;
+build_joinrel_restrictlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel) {
+	List *result;
 
 	/*
 	 * Collect all the clauses that syntactically belong at this level,
@@ -574,7 +574,8 @@ build_joinrel_restrictlist(PlannerInfo *root,
 	 * same clauses arriving from both input relations).
 	 */
 	result = subbuild_joinrel_restrictlist(joinrel, outer_rel->joininfo, NIL);
-	result = subbuild_joinrel_restrictlist(joinrel, inner_rel->joininfo, result);
+	result = subbuild_joinrel_restrictlist(joinrel, inner_rel->joininfo,
+			result);
 
 	/*
 	 * Add on any clauses derived from EquivalenceClasses.	These cannot be
@@ -582,20 +583,15 @@ build_joinrel_restrictlist(PlannerInfo *root,
 	 * checking.
 	 */
 	result = list_concat(result,
-						 generate_join_implied_equalities(root,
-														  joinrel->relids,
-														  outer_rel->relids,
-														  inner_rel));
+			generate_join_implied_equalities(root, joinrel->relids,
+					outer_rel->relids, inner_rel));
 
 	return result;
 }
 
-static void
-build_joinrel_joinlist(RelOptInfo *joinrel,
-					   RelOptInfo *outer_rel,
-					   RelOptInfo *inner_rel)
-{
-	List	   *result;
+static void build_joinrel_joinlist(RelOptInfo *joinrel, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel) {
+	List *result;
 
 	/*
 	 * Collect all the clauses that syntactically belong above this level,
@@ -609,18 +605,15 @@ build_joinrel_joinlist(RelOptInfo *joinrel,
 }
 
 static List *
-subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
-							  List *joininfo_list,
-							  List *new_restrictlist)
-{
-	ListCell   *l;
+subbuild_joinrel_restrictlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_restrictlist) {
+	ListCell *l;
 
 	foreach(l, joininfo_list)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
-		if (bms_is_subset(rinfo->required_relids, joinrel->relids))
-		{
+		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
 			/*
 			 * This clause becomes a restriction clause for the joinrel, since
 			 * it refers to no outside rels.  Add it to the list, being
@@ -629,9 +622,7 @@ subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
 			 * copied, pointer equality should be a sufficient test.)
 			 */
 			new_restrictlist = list_append_unique_ptr(new_restrictlist, rinfo);
-		}
-		else
-		{
+		} else {
 			/*
 			 * This clause is still a join clause at this level, so we ignore
 			 * it in this routine.
@@ -643,26 +634,21 @@ subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
 }
 
 static List *
-subbuild_joinrel_joinlist(RelOptInfo *joinrel,
-						  List *joininfo_list,
-						  List *new_joininfo)
-{
-	ListCell   *l;
+subbuild_joinrel_joinlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_joininfo) {
+	ListCell *l;
 
 	foreach(l, joininfo_list)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
-		if (bms_is_subset(rinfo->required_relids, joinrel->relids))
-		{
+		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
 			/*
 			 * This clause becomes a restriction clause for the joinrel, since
 			 * it refers to no outside rels.  So we can ignore it in this
 			 * routine.
 			 */
-		}
-		else
-		{
+		} else {
 			/*
 			 * This clause is still a join clause at this level, so add it to
 			 * the new joininfo list, being careful to eliminate duplicates.
@@ -677,7 +663,6 @@ subbuild_joinrel_joinlist(RelOptInfo *joinrel,
 	return new_joininfo;
 }
 
-
 /*
  * build_empty_join_rel
  *		Build a dummy join relation describing an empty set of base rels.
@@ -688,8 +673,7 @@ subbuild_joinrel_joinlist(RelOptInfo *joinrel,
  * we just need it to carry a simple Result path out of query_planner().
  */
 RelOptInfo *
-build_empty_join_rel(PlannerInfo *root)
-{
+build_empty_join_rel(PlannerInfo *root) {
 	RelOptInfo *joinrel;
 
 	/* The dummy join relation should be the only one ... */
@@ -697,9 +681,9 @@ build_empty_join_rel(PlannerInfo *root)
 
 	joinrel = makeNode(RelOptInfo);
 	joinrel->reloptkind = RELOPT_JOINREL;
-	joinrel->relids = NULL;		/* empty set */
-	joinrel->rows = 1;			/* we produce one row for such cases */
-	joinrel->width = 0;			/* it contains no Vars */
+	joinrel->relids = NULL; /* empty set */
+	joinrel->rows = 1; /* we produce one row for such cases */
+	joinrel->width = 0; /* it contains no Vars */
 	joinrel->rtekind = RTE_JOIN;
 
 	root->join_rel_list = lappend(root->join_rel_list, joinrel);
@@ -707,7 +691,6 @@ build_empty_join_rel(PlannerInfo *root)
 	return joinrel;
 }
 
-
 /*
  * find_childrel_appendrelinfo
  *		Get the AppendRelInfo associated with an appendrel child rel.
@@ -716,10 +699,9 @@ build_empty_join_rel(PlannerInfo *root)
  * but for now it doesn't seem performance-critical.
  */
 AppendRelInfo *
-find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
-{
-	Index		relid = rel->relid;
-	ListCell   *lc;
+find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel) {
+	Index relid = rel->relid;
+	ListCell *lc;
 
 	/* Should only be called on child rels */
 	Assert(rel->reloptkind == RELOPT_OTHER_MEMBER_REL);
@@ -733,10 +715,9 @@ find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
 	}
 	/* should have found the entry ... */
 	elog(ERROR, "child rel %d not found in append_rel_list", relid);
-	return NULL;				/* not reached */
+	return NULL; /* not reached */
 }
 
-
 /*
  * get_baserel_parampathinfo
  *		Get the ParamPathInfo for a parameterized path for a base relation,
@@ -750,13 +731,12 @@ find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
  */
 ParamPathInfo *
 get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
-						  Relids required_outer)
-{
+		Relids required_outer) {
 	ParamPathInfo *ppi;
-	Relids		joinrelids;
-	List	   *pclauses;
-	double		rows;
-	ListCell   *lc;
+	Relids joinrelids;
+	List *pclauses;
+	double rows;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo */
 	if (bms_is_empty(required_outer))
@@ -782,9 +762,7 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										baserel->relids,
-										joinrelids))
+		if (join_clause_is_movable_into(rinfo, baserel->relids, joinrelids))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
@@ -793,10 +771,8 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	 * necessarily satisfy join_clause_is_movable_into.)
 	 */
 	pclauses = list_concat(pclauses,
-						   generate_join_implied_equalities(root,
-															joinrelids,
-															required_outer,
-															baserel));
+			generate_join_implied_equalities(root, joinrelids, required_outer,
+					baserel));
 
 	/* Estimate the number of rows returned by the parameterized scan */
 	rows = get_parameterized_baserel_size(root, baserel, pclauses);
@@ -841,20 +817,16 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
  */
 ParamPathInfo *
 get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
-						  Path *outer_path,
-						  Path *inner_path,
-						  SpecialJoinInfo *sjinfo,
-						  Relids required_outer,
-						  List **restrict_clauses)
-{
+		Path *outer_path, Path *inner_path, SpecialJoinInfo *sjinfo,
+		Relids required_outer, List **restrict_clauses) {
 	ParamPathInfo *ppi;
-	Relids		join_and_req;
-	Relids		outer_and_req;
-	Relids		inner_and_req;
-	List	   *pclauses;
-	List	   *eclauses;
-	double		rows;
-	ListCell   *lc;
+	Relids join_and_req;
+	Relids outer_and_req;
+	Relids inner_and_req;
+	List *pclauses;
+	List *eclauses;
+	double rows;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo or extra join clauses */
 	if (bms_is_empty(required_outer))
@@ -874,51 +846,43 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	join_and_req = bms_union(joinrel->relids, required_outer);
 	if (outer_path->param_info)
 		outer_and_req = bms_union(outer_path->parent->relids,
-								  PATH_REQ_OUTER(outer_path));
+				PATH_REQ_OUTER(outer_path));
 	else
-		outer_and_req = NULL;	/* outer path does not accept parameters */
+		outer_and_req = NULL; /* outer path does not accept parameters */
 	if (inner_path->param_info)
 		inner_and_req = bms_union(inner_path->parent->relids,
-								  PATH_REQ_OUTER(inner_path));
+				PATH_REQ_OUTER(inner_path));
 	else
-		inner_and_req = NULL;	/* inner path does not accept parameters */
+		inner_and_req = NULL; /* inner path does not accept parameters */
 
 	pclauses = NIL;
 	foreach(lc, joinrel->joininfo)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										joinrel->relids,
-										join_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 outer_path->parent->relids,
-										 outer_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 inner_path->parent->relids,
-										 inner_and_req))
+		if (join_clause_is_movable_into(rinfo, joinrel->relids, join_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						outer_path->parent->relids, outer_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						inner_path->parent->relids, inner_and_req))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
 	/* Consider joinclauses generated by EquivalenceClasses, too */
-	eclauses = generate_join_implied_equalities(root,
-												join_and_req,
-												required_outer,
-												joinrel);
+	eclauses = generate_join_implied_equalities(root, join_and_req,
+			required_outer, joinrel);
 	/* We only want ones that aren't movable to lower levels */
 	foreach(lc, eclauses)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		Assert(join_clause_is_movable_into(rinfo,
-										   joinrel->relids,
-										   join_and_req));
-		if (!join_clause_is_movable_into(rinfo,
-										 outer_path->parent->relids,
-										 outer_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 inner_path->parent->relids,
-										 inner_and_req))
+		Assert(
+				join_clause_is_movable_into(rinfo, joinrel->relids,
+						join_and_req));
+		if (!join_clause_is_movable_into(rinfo, outer_path->parent->relids,
+				outer_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						inner_path->parent->relids, inner_and_req))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
@@ -938,11 +902,8 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	}
 
 	/* Estimate the number of rows returned by the parameterized join */
-	rows = get_parameterized_joinrel_size(root, joinrel,
-										  outer_path->rows,
-										  inner_path->rows,
-										  sjinfo,
-										  *restrict_clauses);
+	rows = get_parameterized_joinrel_size(root, joinrel, outer_path->rows,
+			inner_path->rows, sjinfo, *restrict_clauses);
 
 	/*
 	 * And now we can build the ParamPathInfo.	No point in saving the
@@ -971,10 +932,9 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
  * the Append node isn't responsible for checking quals).
  */
 ParamPathInfo *
-get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer)
-{
+get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer) {
 	ParamPathInfo *ppi;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo */
 	if (bms_is_empty(required_outer))
@@ -999,3 +959,5 @@ get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer)
 
 	return ppi;
 }
+
+
diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c
index 15020c4..580ff2e 100644
--- a/src/backend/utils/misc/guc.c
+++ b/src/backend/utils/misc/guc.c
@@ -787,7 +787,7 @@ static struct config_bool ConfigureNamesBool[] =
 			NULL
 		},
 		&enable_hashjoin,
-		true,
+		false,
 		NULL, NULL, NULL
 	},
 	{
@@ -801,6 +801,24 @@ static struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 	{
+		{"enable_memo", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables memo query optimization."),
+			NULL
+		},
+		&enable_memo,
+		false,
+		NULL, NULL, NULL
+	},
+	{
+		{"enable_cost_check", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables memo query optimization."),
+			NULL
+		},
+		&enable_cost_check,
+		false,
+		NULL, NULL, NULL
+	},
+	{
 		/* Not for general use --- used by SET SESSION AUTHORIZATION */
 		{"is_superuser", PGC_INTERNAL, UNGROUPED,
 			gettext_noop("Shows whether the current user is a superuser."),
diff --git a/src/include/nodes/plannodes.h b/src/include/nodes/plannodes.h
index 38c039c..b1c78f3 100644
--- a/src/include/nodes/plannodes.h
+++ b/src/include/nodes/plannodes.h
@@ -95,7 +95,7 @@ typedef struct Plan
 	 */
 	Cost		startup_cost;	/* cost expended before fetching any tuples */
 	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
-
+	Cost 		mtotal_cost;
 	/*
 	 * planner's estimate of result size of this plan step
 	 */
diff --git a/src/include/nodes/relation.h b/src/include/nodes/relation.h
index c607b36..f9f7fc6 100644
--- a/src/include/nodes/relation.h
+++ b/src/include/nodes/relation.h
@@ -265,6 +265,67 @@ typedef struct PlannerInfo
 	((root)->simple_rte_array ? (root)->simple_rte_array[rti] : \
 	 rt_fetch(rti, (root)->parse->rtable))
 
+/*
+ * When making cost estimates for a SEMI or ANTI join, there are some
+ * correction factors that are needed in both nestloop and hash joins
+ * to account for the fact that the executor can stop scanning inner rows
+ * as soon as it finds a match to the current outer row.  These numbers
+ * depend only on the selected outer and inner join relations, not on the
+ * particular paths used for them, so it's worthwhile to calculate them
+ * just once per relation pair not once per considered path.  This struct
+ * is filled by compute_semi_anti_join_factors and must be passed along
+ * to the join cost estimation functions.
+ *
+ * outer_match_frac is the fraction of the outer tuples that are
+ *		expected to have at least one match.
+ * match_count is the average number of matches expected for
+ *		outer tuples that have at least one match.
+ */
+typedef struct SemiAntiJoinFactors
+{
+	Selectivity outer_match_frac;
+	Selectivity match_count;
+} SemiAntiJoinFactors;
+
+/*
+ * For speed reasons, cost estimation for join paths is performed in two
+ * phases: the first phase tries to quickly derive a lower bound for the
+ * join cost, and then we check if that's sufficient to reject the path.
+ * If not, we come back for a more refined cost estimate.  The first phase
+ * fills a JoinCostWorkspace struct with its preliminary cost estimates
+ * and possibly additional intermediate values.  The second phase takes
+ * these values as inputs to avoid repeating work.
+ *
+ * (Ideally we'd declare this in cost.h, but it's also needed in pathnode.h,
+ * so seems best to put it here.)
+ */
+typedef struct JoinCostWorkspace
+{
+	/* Preliminary cost estimates --- must not be larger than final ones! */
+	Cost		startup_cost;	/* cost expended before fetching any tuples */
+	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
+
+	/* Fields below here should be treated as private to costsize.c */
+	Cost		run_cost;		/* non-startup cost components */
+
+	/* private for cost_nestloop code */
+	Cost		inner_rescan_run_cost;
+	double		outer_matched_rows;
+	Selectivity inner_scan_frac;
+
+	/* private for cost_mergejoin code */
+	Cost		inner_run_cost;
+	double		outer_rows;
+	double		inner_rows;
+	double		outer_skip_rows;
+	double		inner_skip_rows;
+
+	SemiAntiJoinFactors *semifactors;
+
+	/* private for cost_hashjoin code */
+	int			numbuckets;
+	int			numbatches;
+} JoinCostWorkspace;
 
 /*----------
  * RelOptInfo
@@ -427,7 +488,7 @@ typedef struct RelOptInfo
 	/* materialization information */
 	List	   *reltargetlist;	/* Vars to be output by scan of relation */
 	List	   *pathlist;		/* Path structures */
-	List	   *ppilist;		/* ParamPathInfos used in pathlist */
+	List	   *ppilist;		/* ParamPathInfos used in pathrlist */
 	struct Path *cheapest_startup_path;
 	struct Path *cheapest_total_path;
 	struct Path *cheapest_unique_path;
@@ -435,6 +496,7 @@ typedef struct RelOptInfo
 
 	/* information about a base rel (not set for join rels!) */
 	Index		relid;
+	char		*rel_name;
 	Oid			reltablespace;	/* containing tablespace */
 	RTEKind		rtekind;		/* RELATION, SUBQUERY, or FUNCTION */
 	AttrNumber	min_attr;		/* smallest attrno of rel (often <0) */
@@ -456,6 +518,7 @@ typedef struct RelOptInfo
 	struct FdwRoutine *fdwroutine;		/* if foreign table */
 	void	   *fdw_private;	/* if foreign table */
 
+	JoinCostWorkspace *workspace; /* used for calculating cost on cardinality injection*/
 	/* used by various scans and joins: */
 	List	   *baserestrictinfo;		/* RestrictInfo structures (if base
 										 * rel) */
@@ -522,6 +585,9 @@ typedef struct IndexOptInfo
 
 	List	   *indextlist;		/* targetlist representing index columns */
 
+
+	double		loop_count;
+
 	bool		predOK;			/* true if predicate matches query */
 	bool		unique;			/* true if a unique index */
 	bool		immediate;		/* is uniqueness enforced immediately? */
@@ -717,15 +783,22 @@ typedef struct Path
 	NodeTag		type;
 
 	NodeTag		pathtype;		/* tag identifying scan/join method */
+	char		*path_name;
 
 	RelOptInfo *parent;			/* the relation this path can build */
 	ParamPathInfo *param_info;	/* parameterization info, or NULL if none */
+	bool 		memo_checked;
 
 	/* estimated size/costs for path (see costsize.c for more info) */
+
 	double		rows;			/* estimated number of result tuples */
 	Cost		startup_cost;	/* cost expended before fetching any tuples */
+
 	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
 
+	double 		mrows;
+	Cost		mstartup_cost;
+	Cost        mtotal_cost;
 	List	   *pathkeys;		/* sort ordering of path's output */
 	/* pathkeys is a List of PathKey nodes; see above */
 } Path;
@@ -820,6 +893,8 @@ typedef struct IndexPath
 typedef struct BitmapHeapPath
 {
 	Path		path;
+
+	double		loop;
 	Path	   *bitmapqual;		/* IndexPath, BitmapAndPath, BitmapOrPath */
 } BitmapHeapPath;
 
@@ -974,7 +1049,6 @@ typedef struct JoinPath
 	Path		path;
 
 	JoinType	jointype;
-
 	Path	   *outerjoinpath;	/* path for the outer side of the join */
 	Path	   *innerjoinpath;	/* path for the inner side of the join */
 
@@ -1583,64 +1657,6 @@ typedef struct PlannerParamItem
 	int			paramId;		/* its assigned PARAM_EXEC slot number */
 } PlannerParamItem;
 
-/*
- * When making cost estimates for a SEMI or ANTI join, there are some
- * correction factors that are needed in both nestloop and hash joins
- * to account for the fact that the executor can stop scanning inner rows
- * as soon as it finds a match to the current outer row.  These numbers
- * depend only on the selected outer and inner join relations, not on the
- * particular paths used for them, so it's worthwhile to calculate them
- * just once per relation pair not once per considered path.  This struct
- * is filled by compute_semi_anti_join_factors and must be passed along
- * to the join cost estimation functions.
- *
- * outer_match_frac is the fraction of the outer tuples that are
- *		expected to have at least one match.
- * match_count is the average number of matches expected for
- *		outer tuples that have at least one match.
- */
-typedef struct SemiAntiJoinFactors
-{
-	Selectivity outer_match_frac;
-	Selectivity match_count;
-} SemiAntiJoinFactors;
-
-/*
- * For speed reasons, cost estimation for join paths is performed in two
- * phases: the first phase tries to quickly derive a lower bound for the
- * join cost, and then we check if that's sufficient to reject the path.
- * If not, we come back for a more refined cost estimate.  The first phase
- * fills a JoinCostWorkspace struct with its preliminary cost estimates
- * and possibly additional intermediate values.  The second phase takes
- * these values as inputs to avoid repeating work.
- *
- * (Ideally we'd declare this in cost.h, but it's also needed in pathnode.h,
- * so seems best to put it here.)
- */
-typedef struct JoinCostWorkspace
-{
-	/* Preliminary cost estimates --- must not be larger than final ones! */
-	Cost		startup_cost;	/* cost expended before fetching any tuples */
-	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
-
-	/* Fields below here should be treated as private to costsize.c */
-	Cost		run_cost;		/* non-startup cost components */
 
-	/* private for cost_nestloop code */
-	Cost		inner_rescan_run_cost;
-	double		outer_matched_rows;
-	Selectivity inner_scan_frac;
-
-	/* private for cost_mergejoin code */
-	Cost		inner_run_cost;
-	double		outer_rows;
-	double		inner_rows;
-	double		outer_skip_rows;
-	double		inner_skip_rows;
-
-	/* private for cost_hashjoin code */
-	int			numbuckets;
-	int			numbatches;
-} JoinCostWorkspace;
 
 #endif   /* RELATION_H */
diff --git a/src/include/optimizer/cost.h b/src/include/optimizer/cost.h
index ec1605d..f6c2931 100644
--- a/src/include/optimizer/cost.h
+++ b/src/include/optimizer/cost.h
@@ -59,6 +59,9 @@ extern bool enable_nestloop;
 extern bool enable_material;
 extern bool enable_mergejoin;
 extern bool enable_hashjoin;
+extern bool enable_memo;
+extern bool enable_cost_check;
+extern bool mode_cost_check;
 extern int	constraint_exclusion;
 
 extern double clamp_row_est(double nrows);
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index a0bcc82..44c6b36 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -157,5 +157,7 @@ extern ParamPathInfo *get_joinrel_parampathinfo(PlannerInfo *root,
 						  List **restrict_clauses);
 extern ParamPathInfo *get_appendrel_parampathinfo(RelOptInfo *appendrel,
 							Relids required_outer);
+extern int get_join_memo_size(char *rel_names, int level);
+extern int get_baserel_memo_size(char *rel_name, int level);
 
 #endif   /* PATHNODE_H */
-- 
1.9.1

