From a9d9acbf219b9e96585779cd5f99d674d4ccba74 Mon Sep 17 00:00:00 2001
From: Tom Lane <tgl@sss.pgh.pa.us>
Date: Sat, 12 Apr 2014 11:58:53 -0400
Subject: [PATCH 1/3] Create infrastructure for moving-aggregate optimization.

Until now, when executing an aggregate function as a window function
within a window with moving frame start (that is, any frame start mode
except UNBOUNDED PRECEDING), we had to recalculate the aggregate from
scratch each time the frame head moved.  This patch allows an aggregate
definition to include an alternate "moving aggregate" implementation
that includes an inverse transition function for removing rows from
the aggregate's running state.  As long as this can be done successfully,
runtime is proportional to the total number of input rows, rather than
to the number of input rows times the average frame length.

This commit includes the core infrastructure, documentation, and regression
tests using user-defined aggregates.  Follow-on commits will update some
of the built-in aggregates to use this feature.

David Rowley and Florian Pflug, reviewed by Dean Rasheed; additional
hacking by me
---
 doc/src/sgml/catalogs.sgml                     |  43 ++
 doc/src/sgml/ref/create_aggregate.sgml         | 153 +++++-
 doc/src/sgml/xaggr.sgml                        | 197 +++++++-
 src/backend/catalog/pg_aggregate.c             | 241 +++++++++-
 src/backend/commands/aggregatecmds.c           | 101 +++-
 src/backend/executor/nodeAgg.c                 |  13 +-
 src/backend/executor/nodeWindowAgg.c           | 639 +++++++++++++++++++++----
 src/backend/optimizer/util/clauses.c           |   6 +-
 src/backend/parser/parse_agg.c                 |  32 +-
 src/bin/pg_dump/pg_dump.c                      |  68 +++
 src/include/catalog/catversion.h               |   2 +-
 src/include/catalog/pg_aggregate.h             | 302 ++++++------
 src/include/nodes/execnodes.h                  |   3 +-
 src/include/parser/parse_agg.h                 |   2 +
 src/test/regress/expected/create_aggregate.out |  35 ++
 src/test/regress/expected/opr_sanity.out       | 122 ++++-
 src/test/regress/expected/window.out           | 223 +++++++++
 src/test/regress/sql/create_aggregate.sql      |  41 ++
 src/test/regress/sql/opr_sanity.sql            | 103 +++-
 src/test/regress/sql/window.sql                | 192 ++++++++
 20 files changed, 2228 insertions(+), 290 deletions(-)

diff --git a/doc/src/sgml/catalogs.sgml b/doc/src/sgml/catalogs.sgml
index 0069573..c174e67 100644
--- a/doc/src/sgml/catalogs.sgml
+++ b/doc/src/sgml/catalogs.sgml
@@ -387,6 +387,24 @@
       <entry>Final function (zero if none)</entry>
      </row>
      <row>
+      <entry><structfield>aggmtransfn</structfield></entry>
+      <entry><type>regproc</type></entry>
+      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
+      <entry>Forward transition function for moving-aggregate mode (zero if none)</entry>
+     </row>
+     <row>
+      <entry><structfield>aggminvtransfn</structfield></entry>
+      <entry><type>regproc</type></entry>
+      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
+      <entry>Inverse transition function for moving-aggregate mode (zero if none)</entry>
+     </row>
+     <row>
+      <entry><structfield>aggmfinalfn</structfield></entry>
+      <entry><type>regproc</type></entry>
+      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
+      <entry>Final function for moving-aggregate mode (zero if none)</entry>
+     </row>
+     <row>
       <entry><structfield>aggsortop</structfield></entry>
       <entry><type>oid</type></entry>
       <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
@@ -406,6 +424,20 @@
        data, or zero to use a default estimate</entry>
      </row>
      <row>
+      <entry><structfield>aggmtranstype</structfield></entry>
+      <entry><type>oid</type></entry>
+      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
+      <entry>Data type of the aggregate function's internal transition (state)
+       data for moving-aggregate mode (zero if none)</entry>
+     </row>
+     <row>
+      <entry><structfield>aggmtransspace</structfield></entry>
+      <entry><type>int4</type></entry>
+      <entry></entry>
+      <entry>Approximate average size (in bytes) of the transition state data
+       for moving-aggregate mode, or zero to use a default estimate</entry>
+     </row>
+     <row>
       <entry><structfield>agginitval</structfield></entry>
       <entry><type>text</type></entry>
       <entry></entry>
@@ -416,6 +448,17 @@
        value starts out null.
       </entry>
      </row>
+     <row>
+      <entry><structfield>aggminitval</structfield></entry>
+      <entry><type>text</type></entry>
+      <entry></entry>
+      <entry>
+       The initial value of the transition state for moving-aggregate mode.
+       This is a text field containing the initial value in its external
+       string representation.  If this field is null, the transition state
+       value starts out null.
+      </entry>
+     </row>
     </tbody>
    </tgroup>
   </table>
diff --git a/doc/src/sgml/ref/create_aggregate.sgml b/doc/src/sgml/ref/create_aggregate.sgml
index e5fc7186..268acf3 100644
--- a/doc/src/sgml/ref/create_aggregate.sgml
+++ b/doc/src/sgml/ref/create_aggregate.sgml
@@ -27,6 +27,12 @@ CREATE AGGREGATE <replaceable class="parameter">name</replaceable> ( [ <replacea
     [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
     [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
     [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
+    [ , MSFUNC = <replaceable class="PARAMETER">msfunc</replaceable> ]
+    [ , MINVFUNC = <replaceable class="PARAMETER">minvfunc</replaceable> ]
+    [ , MSTYPE = <replaceable class="PARAMETER">mstate_data_type</replaceable> ]
+    [ , MSSPACE = <replaceable class="PARAMETER">mstate_data_size</replaceable> ]
+    [ , MFINALFUNC = <replaceable class="PARAMETER">mffunc</replaceable> ]
+    [ , MINITCOND = <replaceable class="PARAMETER">minitial_condition</replaceable> ]
     [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
 )
 
@@ -49,6 +55,12 @@ CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
     [ , SSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
     [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
     [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
+    [ , MSFUNC = <replaceable class="PARAMETER">sfunc</replaceable> ]
+    [ , MINVFUNC = <replaceable class="PARAMETER">invfunc</replaceable> ]
+    [ , MSTYPE = <replaceable class="PARAMETER">state_data_type</replaceable> ]
+    [ , MSSPACE = <replaceable class="PARAMETER">state_data_size</replaceable> ]
+    [ , MFINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
+    [ , MINITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
     [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
 )
 </synopsis>
@@ -84,7 +96,7 @@ CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
   </para>
 
   <para>
-   An aggregate function is made from one or two ordinary
+   A simple aggregate function is made from one or two ordinary
    functions:
    a state transition function
    <replaceable class="PARAMETER">sfunc</replaceable>,
@@ -126,7 +138,7 @@ CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
    values are ignored (the function is not called and the previous state value
    is retained).  If the initial state value is null, then at the first row
    with all-nonnull input values, the first argument value replaces the state
-   value, and the transition function is invoked at subsequent rows with
+   value, and the transition function is invoked at each subsequent row with
    all-nonnull input values.
    This is handy for implementing aggregates like <function>max</function>.
    Note that this behavior is only available when
@@ -155,6 +167,18 @@ CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
   </para>
 
   <para>
+   An aggregate can optionally support <firstterm>moving-aggregate mode</>,
+   as described in <xref linkend="xaggr-moving-aggregates">.  This requires
+   specifying the <literal>MSFUNC</>, <literal>MINVFUNC</>,
+   and <literal>MSTYPE</> parameters, and optionally
+   the <literal>MSPACE</>, <literal>MFINALFUNC</>,
+   and <literal>MINITCOND</> parameters.  Except for <literal>MINVFUNC</>,
+   these parameters work like the corresponding simple-aggregate parameters
+   without <literal>M</>; they define a separate implementation of the
+   aggregate that includes an inverse transition function.
+  </para>
+
+  <para>
    The syntax with <literal>ORDER BY</literal> in the parameter list creates
    a special type of aggregate called an <firstterm>ordered-set
    aggregate</firstterm>; or if <literal>HYPOTHETICAL</> is specified, then
@@ -197,8 +221,8 @@ SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
   <para>
    To be able to create an aggregate function, you must
    have <literal>USAGE</literal> privilege on the argument types, the state
-   type, and the return type, as well as <literal>EXECUTE</literal> privilege
-   on the transition and final functions.
+   type(s), and the return type, as well as <literal>EXECUTE</literal>
+   privilege on the transition and final functions.
   </para>
  </refsect1>
 
@@ -360,6 +384,79 @@ SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
    </varlistentry>
 
    <varlistentry>
+    <term><replaceable class="PARAMETER">msfunc</replaceable></term>
+    <listitem>
+     <para>
+      The name of the forward state transition function to be called for each
+      input row in moving-aggregate mode.  This is exactly like the regular
+      transition function, except that its first argument and result are of
+      type <replaceable>mstate_data_type</>, which might be different
+      from <replaceable>state_data_type</>.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
+    <term><replaceable class="PARAMETER">minvfunc</replaceable></term>
+    <listitem>
+     <para>
+      The name of the inverse state transition function to be used in
+      moving-aggregate mode.  This function has the same argument and
+      result types as <replaceable>msfunc</>, but it is used to remove
+      a value from the current aggregate state, rather than add a value to
+      it.  The inverse transition function must have the same strictness
+      attribute as the forward state transition function.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
+    <term><replaceable class="PARAMETER">mstate_data_type</replaceable></term>
+    <listitem>
+     <para>
+      The data type for the aggregate's state value, when using
+      moving-aggregate mode.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
+    <term><replaceable class="PARAMETER">mstate_data_size</replaceable></term>
+    <listitem>
+     <para>
+      The approximate average size (in bytes) of the aggregate's state
+      value, when using moving-aggregate mode.  This works the same as 
+      <replaceable>state_data_size</>.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
+    <term><replaceable class="PARAMETER">mffunc</replaceable></term>
+    <listitem>
+     <para>
+      The name of the final function called to compute the aggregate's
+      result after all input rows have been traversed, when using
+      moving-aggregate mode.  This works the same as <replaceable>ffunc</>,
+      except that its input type is <replaceable>mstate_data_type</>.
+      The aggregate result type determined by <replaceable>mffunc</>
+      and <replaceable>mstate_data_type</> must match that determined by the
+      aggregate's regular implementation.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
+    <term><replaceable class="PARAMETER">minitial_condition</replaceable></term>
+    <listitem>
+     <para>
+      The initial setting for the state value, when using moving-aggregate
+      mode.  This works the same as <replaceable>initial_condition</>.
+     </para>
+    </listitem>
+   </varlistentry>
+
+   <varlistentry>
     <term><replaceable class="PARAMETER">sort_operator</replaceable></term>
     <listitem>
      <para>
@@ -398,6 +495,49 @@ SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
   <title>Notes</title>
 
    <para>
+    If an aggregate supports moving-aggregate mode, it will improve
+    calculation efficiency when the aggregate is used as a window function
+    for a window with moving frame start (that is, a frame start mode other
+    than <literal>UNBOUNDED PRECEDING</>).  Conceptually, the forward
+    transition function adds input values to the aggregate's state when
+    they enter the window frame from the bottom, and the inverse transition
+    function removes them again when they leave the frame at the top.  So,
+    when values are removed, they are always removed in the same order they
+    were added.  Whenever the inverse transition function is invoked, it will
+    thus receive the earliest added but not yet removed argument value(s).
+    The inverse transition function can assume that at least one row will
+    remain in the current state after it removes the oldest row.  (When this
+    would not be the case, the window function mechanism simply starts a
+    fresh aggregation, rather than using the inverse transition function.)
+   </para>
+
+   <para>
+    The forward transition function for moving-aggregate mode is not
+    allowed to return NULL as the new state value. If the inverse
+    transition function returns NULL, this is taken as an indication that
+    the inverse function cannot reverse the state calculation for this
+    particular input, and so the aggregate calculation will be redone from
+    scratch for the current frame starting position.  This convention
+    allows moving-aggregate mode to be used in situations where there are
+    some infrequent cases that are impractical to reverse out of the
+    running state value.
+   </para>
+
+   <para>
+    If no moving-aggregate implementation is supplied,
+    the aggregate can still be used with moving frames,
+    but <productname>PostgreSQL</productname> will recompute the whole
+    aggregation whenever the start of the frame moves.
+    Note that whether or not the aggregate supports moving-aggregate
+    mode, <productname>PostgreSQL</productname> can handle a moving frame
+    end without recalculation; this is done by continuing to add new values
+    to the aggregate's state.  It is assumed that the final function does
+    not damage the aggregate's state value, so that the aggregation can be
+    continued even after an aggregate result value has been obtained for
+    one set of frame boundaries.
+   </para>
+
+   <para>
     The syntax for ordered-set aggregates allows <literal>VARIADIC</>
     to be specified for both the last direct parameter and the last
     aggregated (<literal>WITHIN GROUP</>) parameter.  However, the
@@ -415,6 +555,11 @@ SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
     ones; any preceding parameters represent additional direct arguments
     that are not constrained to match the aggregated arguments.
    </para>
+
+   <para>
+    Currently, ordered-set aggregates do not need to support
+    moving-aggregate mode, since they cannot be used as window functions.
+   </para>
  </refsect1>
 
  <refsect1>
diff --git a/doc/src/sgml/xaggr.sgml b/doc/src/sgml/xaggr.sgml
index e77ef12..cbbb051 100644
--- a/doc/src/sgml/xaggr.sgml
+++ b/doc/src/sgml/xaggr.sgml
@@ -132,6 +132,161 @@ CREATE AGGREGATE avg (float8)
   </note>
 
   <para>
+   Aggregate function calls in SQL allow <literal>DISTINCT</>
+   and <literal>ORDER BY</> options that control which rows are fed
+   to the aggregate's transition function and in what order.  These
+   options are implemented behind the scenes and are not the concern
+   of the aggregate's support functions.
+  </para>
+
+  <para>
+   For further details see the
+   <xref linkend="sql-createaggregate">
+   command.
+  </para>
+
+ <sect2 id="xaggr-moving-aggregates">
+  <title>Moving-Aggregate Mode</title>
+
+  <indexterm>
+   <primary>moving-aggregate mode</primary>
+  </indexterm>
+
+  <indexterm>
+   <primary>aggregate function</primary>
+   <secondary>moving aggregate</secondary>
+  </indexterm>
+
+  <para>
+   Aggregate functions can optionally support <firstterm>moving-aggregate
+   mode</>, which allows substantially faster execution of aggregate
+   functions within windows with moving frame starting points.
+   (See <xref linkend="tutorial-window">
+   and <xref linkend="syntax-window-functions"> for information about use of
+   aggregate functions as window functions.)
+   The basic idea is that in addition to a normal <quote>forward</>
+   transition function, the aggregate provides an <firstterm>inverse
+   transition function</>, which allows rows to be removed from the
+   aggregate's running state value when they exit the window frame.
+   For example a <function>sum</> aggregate, which uses addition as the
+   forward transition function, would use subtraction as the inverse
+   transition function.  Without an inverse transition function, the window
+   function mechanism must recalculate the aggregate from scratch each time
+   the frame starting point moves, resulting in run time proportional to the
+   number of input rows times the average frame length.  With an inverse
+   transition function, the run time is only proportional to the number of
+   input rows.
+  </para>
+
+  <para>
+   The inverse transition function is passed the current state value and the
+   aggregate input value(s) for the earliest row included in the current
+   state.  It must reconstruct what the state value would have been if the
+   given input value had never been aggregated, but only the rows following
+   it.  This sometimes requires that the forward transition function keep
+   more state than is needed for plain aggregation mode.  Therefore, the
+   moving-aggregate mode uses a completely separate implementation from the
+   plain mode: it has its own state data type, its own forward transition
+   function, and its own final function if needed.  These can be the same as
+   the plain mode's data type and functions, if there is no need for extra
+   state.
+  </para>
+
+  <para>
+   As an example, we could extend the <function>sum</> aggregate given above
+   to support moving-aggregate mode like this:
+
+<programlisting>
+CREATE AGGREGATE sum (complex)
+(
+    sfunc = complex_add,
+    stype = complex,
+    initcond = '(0,0)',
+    msfunc = complex_add,
+    minvfunc = complex_sub,
+    mstype = complex,
+    minitcond = '(0,0)'
+);
+</programlisting>
+
+   The parameters whose names begin with <literal>m</> define the
+   moving-aggregate implementation.  Except for the inverse transition
+   function <literal>minvfunc</>, they correspond to the plain-aggregate
+   parameters without <literal>m</>.
+  </para>
+
+  <para>
+   The forward transition function for moving-aggregate mode is not allowed
+   to return NULL as the new state value.  If the inverse transition
+   function returns NULL, this is taken as an indication that the inverse
+   function cannot reverse the state calculation for this particular input,
+   and so the aggregate calculation will be redone from scratch for the
+   current frame starting position.  This convention allows moving-aggregate
+   mode to be used in situations where there are some infrequent cases that
+   are impractical to reverse out of the running state value.  The inverse
+   transition function can <quote>punt</> on these cases, and yet still come
+   out ahead so long as it can work for most cases.  As an example, an
+   aggregate working with floating-point numbers might choose to punt when
+   a <literal>NaN</> (not a number) input has to be removed from the running
+   state value.
+  </para>
+
+  <para>
+   When writing moving-aggregate support functions, it is important to be
+   sure that the inverse transition function can reconstruct the correct
+   state value exactly.  Otherwise there might be user-visible differences
+   in results depending on whether the moving-aggregate mode is used.
+   An example of an aggregate for which adding an inverse transition
+   function seems easy at first, yet where this requirement cannot be met
+   is <function>sum</> over <type>float4</> or <type>float8</> inputs.  A
+   naive declaration of <function>sum(<type>float8</>)</function> could be
+
+<programlisting>
+CREATE AGGREGATE unsafe_sum (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi
+);
+</programlisting>
+
+   This aggregate, however, can give wildly different results than it would
+   have without the inverse transition function. For example, consider
+
+<programlisting>
+SELECT
+  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
+FROM (VALUES (1, 1.0e20::float8),
+             (2, 1.0::float8)) AS v (n,x);
+</programlisting>
+
+   This query returns <literal>0</> as its second result, rather than the
+   expected answer of <literal>1</>.  The cause is the limited precision of
+   floating-point values: adding <literal>1</> to <literal>1e20</> results
+   in <literal>1e20</> again, and so subtracting <literal>1e20</> from that
+   yields <literal>0</>, not <literal>1</>.  Note that this is a limitation
+   of floating-point arithmetic in general, not a limitation
+   of <productname>PostgreSQL</>.
+  </para>
+
+ </sect2>
+
+ <sect2 id="xaggr-polymorphic-aggregates">
+  <title>Polymorphic and Variadic Aggregates</title>
+
+  <indexterm>
+   <primary>aggregate function</primary>
+   <secondary>polymorphic</secondary>
+  </indexterm>
+
+  <indexterm>
+   <primary>aggregate function</primary>
+   <secondary>variadic</secondary>
+  </indexterm>
+
+  <para>
    Aggregate functions can use polymorphic
    state transition functions or final functions, so that the same functions
    can be used to implement multiple aggregates.
@@ -189,8 +344,8 @@ SELECT attrelid::regclass, array_accum(atttypid::regtype)
    by declaring its last argument as a <literal>VARIADIC</> array, in much
    the same fashion as for regular functions; see
    <xref linkend="xfunc-sql-variadic-functions">.  The aggregate's transition
-   function must have the same array type as its last argument.  The
-   transition function typically would also be marked <literal>VARIADIC</>,
+   function(s) must have the same array type as their last argument.  The
+   transition function(s) typically would also be marked <literal>VARIADIC</>,
    but this is not strictly required.
   </para>
 
@@ -220,13 +375,15 @@ SELECT myaggregate(a, b, c ORDER BY a) FROM ...
    </para>
   </note>
 
-  <para>
-   Aggregate function calls in SQL allow <literal>DISTINCT</>
-   and <literal>ORDER BY</> options that control which rows are fed
-   to the aggregate's transition function and in what order.  These
-   options are implemented behind the scenes and are not the concern
-   of the aggregate's support functions.
-  </para>
+ </sect2>
+
+ <sect2 id="xaggr-ordered-set-aggregates">
+  <title>Ordered-Set Aggregates</title>
+
+  <indexterm>
+   <primary>aggregate function</primary>
+   <secondary>ordered set</secondary>
+  </indexterm>
 
   <para>
    The aggregates we have been describing so far are <quote>normal</>
@@ -312,6 +469,21 @@ SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
   </para>
 
   <para>
+   Currently, ordered-set aggregates cannot be used as window functions,
+   and therefore there is no need for them to support moving-aggregate mode.
+  </para>
+
+ </sect2>
+
+ <sect2 id="xaggr-support-functions">
+  <title>Support Functions for Aggregates</title>
+
+  <indexterm>
+   <primary>aggregate function</primary>
+   <secondary>support functions for</secondary>
+  </indexterm>
+
+  <para>
    A function written in C can detect that it is being called as an
    aggregate transition or final function by calling
    <function>AggCheckCallContext</>, for example:
@@ -341,9 +513,6 @@ if (AggCheckCallContext(fcinfo, NULL))
    source code.
   </para>
 
-  <para>
-   For further details see the
-   <xref linkend="sql-createaggregate">
-   command.
-  </para>
+ </sect2>
+
  </sect1>
diff --git a/src/backend/catalog/pg_aggregate.c b/src/backend/catalog/pg_aggregate.c
index fe6dc8a..633b8f1 100644
--- a/src/backend/catalog/pg_aggregate.c
+++ b/src/backend/catalog/pg_aggregate.c
@@ -57,10 +57,16 @@ AggregateCreate(const char *aggName,
 				Oid variadicArgType,
 				List *aggtransfnName,
 				List *aggfinalfnName,
+				List *aggmtransfnName,
+				List *aggminvtransfnName,
+				List *aggmfinalfnName,
 				List *aggsortopName,
 				Oid aggTransType,
 				int32 aggTransSpace,
-				const char *agginitval)
+				Oid aggmTransType,
+				int32 aggmTransSpace,
+				const char *agginitval,
+				const char *aggminitval)
 {
 	Relation	aggdesc;
 	HeapTuple	tup;
@@ -69,14 +75,19 @@ AggregateCreate(const char *aggName,
 	Form_pg_proc proc;
 	Oid			transfn;
 	Oid			finalfn = InvalidOid;	/* can be omitted */
+	Oid			mtransfn = InvalidOid;	/* can be omitted */
+	Oid			minvtransfn = InvalidOid;		/* can be omitted */
+	Oid			mfinalfn = InvalidOid;	/* can be omitted */
 	Oid			sortop = InvalidOid;	/* can be omitted */
 	Oid		   *aggArgTypes = parameterTypes->values;
 	bool		hasPolyArg;
 	bool		hasInternalArg;
+	bool		mtransIsStrict = false;
 	Oid			rettype;
 	Oid			finaltype;
 	Oid			fnArgs[FUNC_MAX_ARGS];
 	int			nargs_transfn;
+	int			nargs_finalfn;
 	Oid			procOid;
 	TupleDesc	tupDesc;
 	int			i;
@@ -129,6 +140,16 @@ AggregateCreate(const char *aggName,
 				 errdetail("An aggregate using a polymorphic transition type must have at least one polymorphic argument.")));
 
 	/*
+	 * Likewise for moving-aggregate transtype, if any
+	 */
+	if (OidIsValid(aggmTransType) &&
+		IsPolymorphicType(aggmTransType) && !hasPolyArg)
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+				 errmsg("cannot determine transition data type"),
+				 errdetail("An aggregate using a polymorphic transition type must have at least one polymorphic argument.")));
+
+	/*
 	 * An ordered-set aggregate that is VARIADIC must be VARIADIC ANY.	In
 	 * principle we could support regular variadic types, but it would make
 	 * things much more complicated because we'd have to assemble the correct
@@ -234,32 +255,120 @@ AggregateCreate(const char *aggName,
 					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
 					 errmsg("must not omit initial value when transition function is strict and transition type is not compatible with input type")));
 	}
+
 	ReleaseSysCache(tup);
 
-	/* handle finalfn, if supplied */
-	if (aggfinalfnName)
+	/* handle moving-aggregate transfn, if supplied */
+	if (aggmtransfnName)
 	{
-		int			nargs_finalfn;
+		/*
+		 * The arguments are the same as for the regular transfn, except that
+		 * the transition data type might be different.  So re-use the fnArgs
+		 * values set up above, except for that one.
+		 */
+		Assert(OidIsValid(aggmTransType));
+		fnArgs[0] = aggmTransType;
+
+		mtransfn = lookup_agg_function(aggmtransfnName, nargs_transfn,
+									   fnArgs, variadicArgType,
+									   &rettype);
+
+		/* As above, return type must exactly match declared mtranstype. */
+		if (rettype != aggmTransType)
+			ereport(ERROR,
+					(errcode(ERRCODE_DATATYPE_MISMATCH),
+					 errmsg("return type of transition function %s is not %s",
+							NameListToString(aggmtransfnName),
+							format_type_be(aggmTransType))));
+
+		tup = SearchSysCache1(PROCOID, ObjectIdGetDatum(mtransfn));
+		if (!HeapTupleIsValid(tup))
+			elog(ERROR, "cache lookup failed for function %u", mtransfn);
+		proc = (Form_pg_proc) GETSTRUCT(tup);
 
 		/*
-		 * For ordinary aggs, the finalfn just takes the transtype.  For
-		 * ordered-set aggs, it takes the transtype plus all args.	(The
-		 * aggregated args are useless at runtime, and are actually passed as
-		 * NULLs, but we may need them in the function signature to allow
-		 * resolution of a polymorphic agg's result type.)
+		 * If the mtransfn is strict and the minitval is NULL, check first
+		 * input type and mtranstype are binary-compatible.
 		 */
-		fnArgs[0] = aggTransType;
-		if (AGGKIND_IS_ORDERED_SET(aggKind))
+		if (proc->proisstrict && aggminitval == NULL)
 		{
-			nargs_finalfn = numArgs + 1;
-			memcpy(fnArgs + 1, aggArgTypes, numArgs * sizeof(Oid));
-		}
-		else
-		{
-			nargs_finalfn = 1;
-			/* variadic-ness of the aggregate doesn't affect finalfn */
-			variadicArgType = InvalidOid;
+			if (numArgs < 1 ||
+				!IsBinaryCoercible(aggArgTypes[0], aggmTransType))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+						 errmsg("must not omit initial value when transition function is strict and transition type is not compatible with input type")));
 		}
+
+		/* Remember if mtransfn is strict; we may need this below */
+		mtransIsStrict = proc->proisstrict;
+
+		ReleaseSysCache(tup);
+	}
+
+	/* handle minvtransfn, if supplied */
+	if (aggminvtransfnName)
+	{
+		/*
+		 * This must have the same number of arguments with the same types as
+		 * the forward transition function, so just re-use the fnArgs data.
+		 */
+		Assert(aggmtransfnName);
+
+		minvtransfn = lookup_agg_function(aggminvtransfnName, nargs_transfn,
+										  fnArgs, variadicArgType,
+										  &rettype);
+
+		/* As above, return type must exactly match declared mtranstype. */
+		if (rettype != aggmTransType)
+			ereport(ERROR,
+					(errcode(ERRCODE_DATATYPE_MISMATCH),
+			errmsg("return type of inverse transition function %s is not %s",
+				   NameListToString(aggminvtransfnName),
+				   format_type_be(aggmTransType))));
+
+		tup = SearchSysCache1(PROCOID, ObjectIdGetDatum(minvtransfn));
+		if (!HeapTupleIsValid(tup))
+			elog(ERROR, "cache lookup failed for function %u", minvtransfn);
+		proc = (Form_pg_proc) GETSTRUCT(tup);
+
+		/*
+		 * We require the strictness settings of the forward and inverse
+		 * transition functions to agree.  This saves having to handle
+		 * assorted special cases at execution time.
+		 */
+		if (proc->proisstrict != mtransIsStrict)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("strictness of aggregate's forward and inverse transition functions must match")));
+
+		ReleaseSysCache(tup);
+	}
+
+	/*
+	 * Set up fnArgs for looking up finalfn(s)
+	 *
+	 * For ordinary aggs, the finalfn just takes the transtype.  For
+	 * ordered-set aggs, it takes the transtype plus all args.	(The
+	 * aggregated args are useless at runtime, and are actually passed as
+	 * NULLs, but we may need them in the function signature to allow
+	 * resolution of a polymorphic agg's result type.)
+	 */
+	fnArgs[0] = aggTransType;
+	if (AGGKIND_IS_ORDERED_SET(aggKind))
+	{
+		nargs_finalfn = numArgs + 1;
+		memcpy(fnArgs + 1, aggArgTypes, numArgs * sizeof(Oid));
+	}
+	else
+	{
+		nargs_finalfn = 1;
+		/* variadic-ness of the aggregate doesn't affect finalfn */
+		variadicArgType = InvalidOid;
+	}
+
+	/* handle finalfn, if supplied */
+	if (aggfinalfnName)
+	{
 		finalfn = lookup_agg_function(aggfinalfnName, nargs_finalfn,
 									  fnArgs, variadicArgType,
 									  &finaltype);
@@ -314,6 +423,49 @@ AggregateCreate(const char *aggName,
 				 errmsg("unsafe use of pseudo-type \"internal\""),
 				 errdetail("A function returning \"internal\" must have at least one \"internal\" argument.")));
 
+	/*
+	 * If a moving-aggregate implementation is supplied, look up its finalfn
+	 * if any, and check that the implied aggregate result type matches the
+	 * plain implementation.
+	 */
+	if (OidIsValid(aggmTransType))
+	{
+		/* handle finalfn, if supplied */
+		if (aggmfinalfnName)
+		{
+			/*
+			 * The arguments are the same as for the regular finalfn, except
+			 * that the transition data type might be different.  So re-use
+			 * the fnArgs values set up above, except for that one.
+			 */
+			fnArgs[0] = aggmTransType;
+
+			mfinalfn = lookup_agg_function(aggmfinalfnName, nargs_finalfn,
+										   fnArgs, variadicArgType,
+										   &rettype);
+
+			/* As above, check strictness if it's an ordered-set agg */
+			if (AGGKIND_IS_ORDERED_SET(aggKind) && func_strict(mfinalfn))
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+						 errmsg("final function of an ordered-set aggregate must not be declared STRICT")));
+		}
+		else
+		{
+			/*
+			 * If no finalfn, aggregate result type is type of the state value
+			 */
+			rettype = aggmTransType;
+		}
+		Assert(OidIsValid(rettype));
+		if (rettype != finaltype)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("moving-aggregate implementation returns type %s, but plain implementation returns type %s",
+							format_type_be(aggmTransType),
+							format_type_be(aggTransType))));
+	}
+
 	/* handle sortop, if supplied */
 	if (aggsortopName)
 	{
@@ -340,6 +492,13 @@ AggregateCreate(const char *aggName,
 	if (aclresult != ACLCHECK_OK)
 		aclcheck_error_type(aclresult, aggTransType);
 
+	if (OidIsValid(aggmTransType))
+	{
+		aclresult = pg_type_aclcheck(aggmTransType, GetUserId(), ACL_USAGE);
+		if (aclresult != ACLCHECK_OK)
+			aclcheck_error_type(aclresult, aggmTransType);
+	}
+
 	aclresult = pg_type_aclcheck(finaltype, GetUserId(), ACL_USAGE);
 	if (aclresult != ACLCHECK_OK)
 		aclcheck_error_type(aclresult, finaltype);
@@ -392,13 +551,22 @@ AggregateCreate(const char *aggName,
 	values[Anum_pg_aggregate_aggnumdirectargs - 1] = Int16GetDatum(numDirectArgs);
 	values[Anum_pg_aggregate_aggtransfn - 1] = ObjectIdGetDatum(transfn);
 	values[Anum_pg_aggregate_aggfinalfn - 1] = ObjectIdGetDatum(finalfn);
+	values[Anum_pg_aggregate_aggmtransfn - 1] = ObjectIdGetDatum(mtransfn);
+	values[Anum_pg_aggregate_aggminvtransfn - 1] = ObjectIdGetDatum(minvtransfn);
+	values[Anum_pg_aggregate_aggmfinalfn - 1] = ObjectIdGetDatum(mfinalfn);
 	values[Anum_pg_aggregate_aggsortop - 1] = ObjectIdGetDatum(sortop);
 	values[Anum_pg_aggregate_aggtranstype - 1] = ObjectIdGetDatum(aggTransType);
 	values[Anum_pg_aggregate_aggtransspace - 1] = Int32GetDatum(aggTransSpace);
+	values[Anum_pg_aggregate_aggmtranstype - 1] = ObjectIdGetDatum(aggmTransType);
+	values[Anum_pg_aggregate_aggmtransspace - 1] = Int32GetDatum(aggmTransSpace);
 	if (agginitval)
 		values[Anum_pg_aggregate_agginitval - 1] = CStringGetTextDatum(agginitval);
 	else
 		nulls[Anum_pg_aggregate_agginitval - 1] = true;
+	if (aggminitval)
+		values[Anum_pg_aggregate_aggminitval - 1] = CStringGetTextDatum(aggminitval);
+	else
+		nulls[Anum_pg_aggregate_aggminitval - 1] = true;
 
 	aggdesc = heap_open(AggregateRelationId, RowExclusiveLock);
 	tupDesc = aggdesc->rd_att;
@@ -414,6 +582,7 @@ AggregateCreate(const char *aggName,
 	 * Create dependencies for the aggregate (above and beyond those already
 	 * made by ProcedureCreate).  Note: we don't need an explicit dependency
 	 * on aggTransType since we depend on it indirectly through transfn.
+	 * Likewise for aggmTransType if any.
 	 */
 	myself.classId = ProcedureRelationId;
 	myself.objectId = procOid;
@@ -434,6 +603,33 @@ AggregateCreate(const char *aggName,
 		recordDependencyOn(&myself, &referenced, DEPENDENCY_NORMAL);
 	}
 
+	/* Depends on forward transition function, if any */
+	if (OidIsValid(mtransfn))
+	{
+		referenced.classId = ProcedureRelationId;
+		referenced.objectId = mtransfn;
+		referenced.objectSubId = 0;
+		recordDependencyOn(&myself, &referenced, DEPENDENCY_NORMAL);
+	}
+
+	/* Depends on inverse transition function, if any */
+	if (OidIsValid(minvtransfn))
+	{
+		referenced.classId = ProcedureRelationId;
+		referenced.objectId = minvtransfn;
+		referenced.objectSubId = 0;
+		recordDependencyOn(&myself, &referenced, DEPENDENCY_NORMAL);
+	}
+
+	/* Depends on final function, if any */
+	if (OidIsValid(mfinalfn))
+	{
+		referenced.classId = ProcedureRelationId;
+		referenced.objectId = mfinalfn;
+		referenced.objectSubId = 0;
+		recordDependencyOn(&myself, &referenced, DEPENDENCY_NORMAL);
+	}
+
 	/* Depends on sort operator, if any */
 	if (OidIsValid(sortop))
 	{
@@ -447,7 +643,12 @@ AggregateCreate(const char *aggName,
 }
 
 /*
- * lookup_agg_function -- common code for finding both transfn and finalfn
+ * lookup_agg_function
+ * common code for finding transfn, invtransfn and finalfn
+ *
+ * Returns OID of function, and stores its return type into *rettype
+ *
+ * NB: must not scribble on input_types[], as we may re-use those
  */
 static Oid
 lookup_agg_function(List *fnName,
diff --git a/src/backend/commands/aggregatecmds.c b/src/backend/commands/aggregatecmds.c
index 640e19c..9714112 100644
--- a/src/backend/commands/aggregatecmds.c
+++ b/src/backend/commands/aggregatecmds.c
@@ -61,11 +61,17 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 	char		aggKind = AGGKIND_NORMAL;
 	List	   *transfuncName = NIL;
 	List	   *finalfuncName = NIL;
+	List	   *mtransfuncName = NIL;
+	List	   *minvtransfuncName = NIL;
+	List	   *mfinalfuncName = NIL;
 	List	   *sortoperatorName = NIL;
 	TypeName   *baseType = NULL;
 	TypeName   *transType = NULL;
+	TypeName   *mtransType = NULL;
 	int32		transSpace = 0;
+	int32		mtransSpace = 0;
 	char	   *initval = NULL;
+	char	   *minitval = NULL;
 	int			numArgs;
 	int			numDirectArgs = 0;
 	oidvector  *parameterTypes;
@@ -75,7 +81,9 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 	List	   *parameterDefaults;
 	Oid			variadicArgType;
 	Oid			transTypeId;
+	Oid			mtransTypeId = InvalidOid;
 	char		transTypeType;
+	char		mtransTypeType = 0;
 	ListCell   *pl;
 
 	/* Convert list of names to a name and namespace */
@@ -114,6 +122,12 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 			transfuncName = defGetQualifiedName(defel);
 		else if (pg_strcasecmp(defel->defname, "finalfunc") == 0)
 			finalfuncName = defGetQualifiedName(defel);
+		else if (pg_strcasecmp(defel->defname, "msfunc") == 0)
+			mtransfuncName = defGetQualifiedName(defel);
+		else if (pg_strcasecmp(defel->defname, "minvfunc") == 0)
+			minvtransfuncName = defGetQualifiedName(defel);
+		else if (pg_strcasecmp(defel->defname, "mfinalfunc") == 0)
+			mfinalfuncName = defGetQualifiedName(defel);
 		else if (pg_strcasecmp(defel->defname, "sortop") == 0)
 			sortoperatorName = defGetQualifiedName(defel);
 		else if (pg_strcasecmp(defel->defname, "basetype") == 0)
@@ -135,10 +149,16 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 			transType = defGetTypeName(defel);
 		else if (pg_strcasecmp(defel->defname, "sspace") == 0)
 			transSpace = defGetInt32(defel);
+		else if (pg_strcasecmp(defel->defname, "mstype") == 0)
+			mtransType = defGetTypeName(defel);
+		else if (pg_strcasecmp(defel->defname, "msspace") == 0)
+			mtransSpace = defGetInt32(defel);
 		else if (pg_strcasecmp(defel->defname, "initcond") == 0)
 			initval = defGetString(defel);
 		else if (pg_strcasecmp(defel->defname, "initcond1") == 0)
 			initval = defGetString(defel);
+		else if (pg_strcasecmp(defel->defname, "minitcond") == 0)
+			minitval = defGetString(defel);
 		else
 			ereport(WARNING,
 					(errcode(ERRCODE_SYNTAX_ERROR),
@@ -159,6 +179,46 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 				 errmsg("aggregate sfunc must be specified")));
 
 	/*
+	 * if mtransType is given, mtransfuncName and minvtransfuncName must be as
+	 * well; if not, then none of the moving-aggregate options should have
+	 * been given.
+	 */
+	if (mtransType != NULL)
+	{
+		if (mtransfuncName == NIL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate msfunc must be specified when mstype is specified")));
+		if (minvtransfuncName == NIL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate minvfunc must be specified when mstype is specified")));
+	}
+	else
+	{
+		if (mtransfuncName != NIL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+			errmsg("aggregate msfunc must not be specified without mstype")));
+		if (minvtransfuncName != NIL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate minvfunc must not be specified without mstype")));
+		if (mfinalfuncName != NIL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate mfinalfunc must not be specified without mstype")));
+		if (mtransSpace != 0)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate msspace must not be specified without mstype")));
+		if (minitval != NULL)
+			ereport(ERROR,
+					(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+					 errmsg("aggregate minitcond must not be specified without mstype")));
+	}
+
+	/*
 	 * look up the aggregate's input datatype(s).
 	 */
 	if (oldstyle)
@@ -251,6 +311,27 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 	}
 
 	/*
+	 * If a moving-aggregate transtype is specified, look that up.	Same
+	 * restrictions as for transtype.
+	 */
+	if (mtransType)
+	{
+		mtransTypeId = typenameTypeId(NULL, mtransType);
+		mtransTypeType = get_typtype(mtransTypeId);
+		if (mtransTypeType == TYPTYPE_PSEUDO &&
+			!IsPolymorphicType(mtransTypeId))
+		{
+			if (mtransTypeId == INTERNALOID && superuser())
+				 /* okay */ ;
+			else
+				ereport(ERROR,
+						(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+						 errmsg("aggregate transition data type cannot be %s",
+								format_type_be(mtransTypeId))));
+		}
+	}
+
+	/*
 	 * If we have an initval, and it's not for a pseudotype (particularly a
 	 * polymorphic type), make sure it's acceptable to the type's input
 	 * function.  We will store the initval as text, because the input
@@ -269,6 +350,18 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 	}
 
 	/*
+	 * Likewise for moving-aggregate initval.
+	 */
+	if (minitval && mtransTypeType != TYPTYPE_PSEUDO)
+	{
+		Oid			typinput,
+					typioparam;
+
+		getTypeInputInfo(mtransTypeId, &typinput, &typioparam);
+		(void) OidInputFunctionCall(typinput, minitval, typioparam, -1);
+	}
+
+	/*
 	 * Most of the argument-checking is done inside of AggregateCreate
 	 */
 	return AggregateCreate(aggName,		/* aggregate name */
@@ -284,8 +377,14 @@ DefineAggregate(List *name, List *args, bool oldstyle, List *parameters,
 						   variadicArgType,
 						   transfuncName,		/* step function name */
 						   finalfuncName,		/* final function name */
+						   mtransfuncName,		/* fwd trans function name */
+						   minvtransfuncName,	/* inv trans function name */
+						   mfinalfuncName,		/* final function name */
 						   sortoperatorName,	/* sort operator name */
 						   transTypeId, /* transition data type */
 						   transSpace,	/* transition space */
-						   initval);	/* initial condition */
+						   mtransTypeId,		/* transition data type */
+						   mtransSpace, /* transition space */
+						   initval,		/* initial condition */
+						   minitval);	/* initial condition */
 }
diff --git a/src/backend/executor/nodeAgg.c b/src/backend/executor/nodeAgg.c
index 7e4bca5..d60845b 100644
--- a/src/backend/executor/nodeAgg.c
+++ b/src/backend/executor/nodeAgg.c
@@ -1798,8 +1798,10 @@ ExecInitAgg(Agg *node, EState *estate, int eflags)
 								aggref->aggtype,
 								aggref->inputcollid,
 								transfn_oid,
+								InvalidOid,		/* invtrans is not needed here */
 								finalfn_oid,
 								&transfnexpr,
+								NULL,
 								&finalfnexpr);
 
 		/* set up infrastructure for calling the transfn and finalfn */
@@ -1847,7 +1849,8 @@ ExecInitAgg(Agg *node, EState *estate, int eflags)
 		 * type and transtype are the same (or at least binary-compatible), so
 		 * that it's OK to use the first aggregated input value as the initial
 		 * transValue.	This should have been checked at agg definition time,
-		 * but just in case...
+		 * but we must check again in case the transfn's strictness property
+		 * has been changed.
 		 */
 		if (peraggstate->transfn.fn_strict && peraggstate->initValueIsNull)
 		{
@@ -2126,6 +2129,12 @@ ExecReScanAgg(AggState *node)
 		ExecReScan(node->ss.ps.lefttree);
 }
 
+
+/***********************************************************************
+ * API exposed to aggregate functions
+ ***********************************************************************/
+
+
 /*
  * AggCheckCallContext - test if a SQL function is being called as an aggregate
  *
@@ -2152,7 +2161,7 @@ AggCheckCallContext(FunctionCallInfo fcinfo, MemoryContext *aggcontext)
 	if (fcinfo->context && IsA(fcinfo->context, WindowAggState))
 	{
 		if (aggcontext)
-			*aggcontext = ((WindowAggState *) fcinfo->context)->aggcontext;
+			*aggcontext = ((WindowAggState *) fcinfo->context)->curaggcontext;
 		return AGG_CONTEXT_WINDOW;
 	}
 
diff --git a/src/backend/executor/nodeWindowAgg.c b/src/backend/executor/nodeWindowAgg.c
index 0b558e5..046637f 100644
--- a/src/backend/executor/nodeWindowAgg.c
+++ b/src/backend/executor/nodeWindowAgg.c
@@ -102,16 +102,18 @@ typedef struct WindowStatePerFuncData
  */
 typedef struct WindowStatePerAggData
 {
-	/* Oids of transfer functions */
+	/* Oids of transition functions */
 	Oid			transfn_oid;
+	Oid			invtransfn_oid; /* may be InvalidOid */
 	Oid			finalfn_oid;	/* may be InvalidOid */
 
 	/*
-	 * fmgr lookup data for transfer functions --- only valid when
+	 * fmgr lookup data for transition functions --- only valid when
 	 * corresponding oid is not InvalidOid.  Note in particular that fn_strict
 	 * flags are kept here.
 	 */
 	FmgrInfo	transfn;
+	FmgrInfo	invtransfn;
 	FmgrInfo	finalfn;
 
 	/*
@@ -139,11 +141,17 @@ typedef struct WindowStatePerAggData
 
 	int			wfuncno;		/* index of associated PerFuncData */
 
+	/* Context holding transition value and possibly other subsidiary data */
+	MemoryContext aggcontext;	/* may be private, or winstate->aggcontext */
+
 	/* Current transition value */
 	Datum		transValue;		/* current transition value */
 	bool		transValueIsNull;
 
-	bool		noTransValue;	/* true if transValue not set yet */
+	int64		transValueCount;	/* number of currently-aggregated rows */
+
+	/* Data local to eval_windowaggregates() */
+	bool		restart;		/* need to restart this agg in this cycle? */
 } WindowStatePerAggData;
 
 static void initialize_windowaggregate(WindowAggState *winstate,
@@ -152,6 +160,9 @@ static void initialize_windowaggregate(WindowAggState *winstate,
 static void advance_windowaggregate(WindowAggState *winstate,
 						WindowStatePerFunc perfuncstate,
 						WindowStatePerAgg peraggstate);
+static bool advance_windowaggregate_base(WindowAggState *winstate,
+							 WindowStatePerFunc perfuncstate,
+							 WindowStatePerAgg peraggstate);
 static void finalize_windowaggregate(WindowAggState *winstate,
 						 WindowStatePerFunc perfuncstate,
 						 WindowStatePerAgg peraggstate,
@@ -193,18 +204,27 @@ initialize_windowaggregate(WindowAggState *winstate,
 {
 	MemoryContext oldContext;
 
+	/*
+	 * If we're using a private aggcontext, we may reset it here.  But if the
+	 * context is shared, we don't know which other aggregates may still need
+	 * it, so we must leave it to the caller to reset at an appropriate time.
+	 */
+	if (peraggstate->aggcontext != winstate->aggcontext)
+		MemoryContextResetAndDeleteChildren(peraggstate->aggcontext);
+
 	if (peraggstate->initValueIsNull)
 		peraggstate->transValue = peraggstate->initValue;
 	else
 	{
-		oldContext = MemoryContextSwitchTo(winstate->aggcontext);
+		oldContext = MemoryContextSwitchTo(peraggstate->aggcontext);
 		peraggstate->transValue = datumCopy(peraggstate->initValue,
 											peraggstate->transtypeByVal,
 											peraggstate->transtypeLen);
 		MemoryContextSwitchTo(oldContext);
 	}
 	peraggstate->transValueIsNull = peraggstate->initValueIsNull;
-	peraggstate->noTransValue = peraggstate->initValueIsNull;
+	peraggstate->transValueCount = 0;
+	peraggstate->resultValue = (Datum) 0;
 	peraggstate->resultValueIsNull = true;
 }
 
@@ -258,7 +278,8 @@ advance_windowaggregate(WindowAggState *winstate,
 	{
 		/*
 		 * For a strict transfn, nothing happens when there's a NULL input; we
-		 * just keep the prior transValue.
+		 * just keep the prior transValue.	Note transValueCount doesn't
+		 * change either.
 		 */
 		for (i = 1; i <= numArguments; i++)
 		{
@@ -268,41 +289,47 @@ advance_windowaggregate(WindowAggState *winstate,
 				return;
 			}
 		}
-		if (peraggstate->noTransValue)
+
+		/*
+		 * For strict transition functions with initial value NULL we use the
+		 * first non-NULL input as the initial state.  (We already checked
+		 * that the agg's input type is binary-compatible with its transtype,
+		 * so straight copy here is OK.)
+		 *
+		 * We must copy the datum into aggcontext if it is pass-by-ref.  We do
+		 * not need to pfree the old transValue, since it's NULL.
+		 */
+		if (peraggstate->transValueCount == 0 && peraggstate->transValueIsNull)
 		{
-			/*
-			 * transValue has not been initialized. This is the first non-NULL
-			 * input value. We use it as the initial value for transValue. (We
-			 * already checked that the agg's input type is binary-compatible
-			 * with its transtype, so straight copy here is OK.)
-			 *
-			 * We must copy the datum into aggcontext if it is pass-by-ref. We
-			 * do not need to pfree the old transValue, since it's NULL.
-			 */
-			MemoryContextSwitchTo(winstate->aggcontext);
+			MemoryContextSwitchTo(peraggstate->aggcontext);
 			peraggstate->transValue = datumCopy(fcinfo->arg[1],
 												peraggstate->transtypeByVal,
 												peraggstate->transtypeLen);
 			peraggstate->transValueIsNull = false;
-			peraggstate->noTransValue = false;
+			peraggstate->transValueCount = 1;
 			MemoryContextSwitchTo(oldContext);
 			return;
 		}
+
 		if (peraggstate->transValueIsNull)
 		{
 			/*
 			 * Don't call a strict function with NULL inputs.  Note it is
 			 * possible to get here despite the above tests, if the transfn is
-			 * strict *and* returned a NULL on a prior cycle. If that happens
-			 * we will propagate the NULL all the way to the end.
+			 * strict *and* returned a NULL on a prior cycle.  If that happens
+			 * we will propagate the NULL all the way to the end.  That can
+			 * only happen if there's no inverse transition function, though,
+			 * since we disallow transitions back to NULL when there is one.
 			 */
 			MemoryContextSwitchTo(oldContext);
+			Assert(!OidIsValid(peraggstate->invtransfn_oid));
 			return;
 		}
 	}
 
 	/*
-	 * OK to call the transition function
+	 * OK to call the transition function.	Set winstate->curaggcontext while
+	 * calling it, for possible use by AggCheckCallContext.
 	 */
 	InitFunctionCallInfoData(*fcinfo, &(peraggstate->transfn),
 							 numArguments + 1,
@@ -310,7 +337,26 @@ advance_windowaggregate(WindowAggState *winstate,
 							 (void *) winstate, NULL);
 	fcinfo->arg[0] = peraggstate->transValue;
 	fcinfo->argnull[0] = peraggstate->transValueIsNull;
+	winstate->curaggcontext = peraggstate->aggcontext;
 	newVal = FunctionCallInvoke(fcinfo);
+	winstate->curaggcontext = NULL;
+
+	/*
+	 * Moving-aggregate transition functions must not return NULL, see
+	 * advance_windowaggregate_base().
+	 */
+	if (fcinfo->isnull && OidIsValid(peraggstate->invtransfn_oid))
+		ereport(ERROR,
+				(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
+		errmsg("moving-aggregate transition function must not return NULL")));
+
+	/*
+	 * We must track the number of rows included in transValue, since to
+	 * remove the last input, advance_windowaggregate_base() musn't call the
+	 * inverse transition function, but simply reset transValue back to its
+	 * initial value.
+	 */
+	peraggstate->transValueCount++;
 
 	/*
 	 * If pass-by-ref datatype, must copy the new value into aggcontext and
@@ -322,7 +368,161 @@ advance_windowaggregate(WindowAggState *winstate,
 	{
 		if (!fcinfo->isnull)
 		{
-			MemoryContextSwitchTo(winstate->aggcontext);
+			MemoryContextSwitchTo(peraggstate->aggcontext);
+			newVal = datumCopy(newVal,
+							   peraggstate->transtypeByVal,
+							   peraggstate->transtypeLen);
+		}
+		if (!peraggstate->transValueIsNull)
+			pfree(DatumGetPointer(peraggstate->transValue));
+	}
+
+	MemoryContextSwitchTo(oldContext);
+	peraggstate->transValue = newVal;
+	peraggstate->transValueIsNull = fcinfo->isnull;
+}
+
+/*
+ * advance_windowaggregate_base
+ * Remove the oldest tuple from an aggregation.
+ *
+ * This is very much like advance_windowaggregate, except that we will call
+ * the inverse transition function (which caller must have checked is
+ * available).
+ *
+ * Returns true if we successfully removed the current row from this
+ * aggregate, false if not (in the latter case, caller is responsible
+ * for cleaning up by restarting the aggregation).
+ */
+static bool
+advance_windowaggregate_base(WindowAggState *winstate,
+							 WindowStatePerFunc perfuncstate,
+							 WindowStatePerAgg peraggstate)
+{
+	WindowFuncExprState *wfuncstate = perfuncstate->wfuncstate;
+	int			numArguments = perfuncstate->numArguments;
+	FunctionCallInfoData fcinfodata;
+	FunctionCallInfo fcinfo = &fcinfodata;
+	Datum		newVal;
+	ListCell   *arg;
+	int			i;
+	MemoryContext oldContext;
+	ExprContext *econtext = winstate->tmpcontext;
+	ExprState  *filter = wfuncstate->aggfilter;
+
+	oldContext = MemoryContextSwitchTo(econtext->ecxt_per_tuple_memory);
+
+	/* Skip anything FILTERed out */
+	if (filter)
+	{
+		bool		isnull;
+		Datum		res = ExecEvalExpr(filter, econtext, &isnull, NULL);
+
+		if (isnull || !DatumGetBool(res))
+		{
+			MemoryContextSwitchTo(oldContext);
+			return true;
+		}
+	}
+
+	/* We start from 1, since the 0th arg will be the transition value */
+	i = 1;
+	foreach(arg, wfuncstate->args)
+	{
+		ExprState  *argstate = (ExprState *) lfirst(arg);
+
+		fcinfo->arg[i] = ExecEvalExpr(argstate, econtext,
+									  &fcinfo->argnull[i], NULL);
+		i++;
+	}
+
+	if (peraggstate->invtransfn.fn_strict)
+	{
+		/*
+		 * For a strict (inv)transfn, nothing happens when there's a NULL
+		 * input; we just keep the prior transValue.  Note transValueCount
+		 * doesn't change either.
+		 */
+		for (i = 1; i <= numArguments; i++)
+		{
+			if (fcinfo->argnull[i])
+			{
+				MemoryContextSwitchTo(oldContext);
+				return true;
+			}
+		}
+	}
+
+	/* There should still be an added but not yet removed value */
+	Assert(peraggstate->transValueCount > 0);
+
+	/*
+	 * In moving-aggregate mode, the state must never be NULL, except possibly
+	 * before any rows have been aggregated (which is surely not the case at
+	 * this point).  This restriction allows us to interpret a NULL result
+	 * from the inverse function as meaning "sorry, can't do an inverse
+	 * transition in this case".  We already checked this in
+	 * advance_windowaggregate, but just for safety, check again.
+	 */
+	if (peraggstate->transValueIsNull)
+		elog(ERROR, "aggregate transition value is NULL before inverse transition");
+
+	/*
+	 * We mustn't use the inverse transition function to remove the last
+	 * input.  Doing so would yield a non-NULL state, whereas we should be in
+	 * the initial state afterwards which may very well be NULL.  So instead,
+	 * we simply re-initialize the aggregate in this case.
+	 */
+	if (peraggstate->transValueCount == 1)
+	{
+		MemoryContextSwitchTo(oldContext);
+		initialize_windowaggregate(winstate,
+								   &winstate->perfunc[peraggstate->wfuncno],
+								   peraggstate);
+		return true;
+	}
+
+	/*
+	 * OK to call the inverse transition function.	Set
+	 * winstate->curaggcontext while calling it, for possible use by
+	 * AggCheckCallContext.
+	 */
+	InitFunctionCallInfoData(*fcinfo, &(peraggstate->invtransfn),
+							 numArguments + 1,
+							 perfuncstate->winCollation,
+							 (void *) winstate, NULL);
+	fcinfo->arg[0] = peraggstate->transValue;
+	fcinfo->argnull[0] = peraggstate->transValueIsNull;
+	winstate->curaggcontext = peraggstate->aggcontext;
+	newVal = FunctionCallInvoke(fcinfo);
+	winstate->curaggcontext = NULL;
+
+	/*
+	 * If the function returns NULL, report failure, forcing a restart.
+	 */
+	if (fcinfo->isnull)
+	{
+		MemoryContextSwitchTo(oldContext);
+		return false;
+	}
+
+	/* Update number of rows included in transValue */
+	peraggstate->transValueCount--;
+
+	/*
+	 * If pass-by-ref datatype, must copy the new value into aggcontext and
+	 * pfree the prior transValue.	But if invtransfn returned a pointer to
+	 * its first input, we don't need to do anything.
+	 *
+	 * Note: the checks for null values here will never fire, but it seems
+	 * best to have this stanza look just like advance_windowaggregate.
+	 */
+	if (!peraggstate->transtypeByVal &&
+		DatumGetPointer(newVal) != DatumGetPointer(peraggstate->transValue))
+	{
+		if (!fcinfo->isnull)
+		{
+			MemoryContextSwitchTo(peraggstate->aggcontext);
 			newVal = datumCopy(newVal,
 							   peraggstate->transtypeByVal,
 							   peraggstate->transtypeLen);
@@ -334,6 +534,8 @@ advance_windowaggregate(WindowAggState *winstate,
 	MemoryContextSwitchTo(oldContext);
 	peraggstate->transValue = newVal;
 	peraggstate->transValueIsNull = fcinfo->isnull;
+
+	return true;
 }
 
 /*
@@ -370,7 +572,9 @@ finalize_windowaggregate(WindowAggState *winstate,
 		}
 		else
 		{
+			winstate->curaggcontext = peraggstate->aggcontext;
 			*result = FunctionCallInvoke(&fcinfo);
+			winstate->curaggcontext = NULL;
 			*isnull = fcinfo.isnull;
 		}
 	}
@@ -396,7 +600,9 @@ finalize_windowaggregate(WindowAggState *winstate,
  * eval_windowaggregates
  * evaluate plain aggregates being used as window functions
  *
- * Much of this is duplicated from nodeAgg.c.  But NOTE that we expect to be
+ * This differs from nodeAgg.c in two ways.  First, if the window's frame
+ * start position moves, we use the inverse transition function (if it exists)
+ * to remove rows from the transition value.  And second, we expect to be
  * able to call aggregate final functions repeatedly after aggregating more
  * data onto the same transition value.  This is not a behavior required by
  * nodeAgg.c.
@@ -406,12 +612,15 @@ eval_windowaggregates(WindowAggState *winstate)
 {
 	WindowStatePerAgg peraggstate;
 	int			wfuncno,
-				numaggs;
-	int			i;
+				numaggs,
+				numaggs_restart,
+				i;
+	int64		aggregatedupto_nonrestarted;
 	MemoryContext oldContext;
 	ExprContext *econtext;
 	WindowObject agg_winobj;
 	TupleTableSlot *agg_row_slot;
+	TupleTableSlot *temp_slot;
 
 	numaggs = winstate->numaggs;
 	if (numaggs == 0)
@@ -421,6 +630,7 @@ eval_windowaggregates(WindowAggState *winstate)
 	econtext = winstate->ss.ps.ps_ExprContext;
 	agg_winobj = winstate->agg_winobj;
 	agg_row_slot = winstate->agg_row_slot;
+	temp_slot = winstate->temp_slot_1;
 
 	/*
 	 * Currently, we support only a subset of the SQL-standard window framing
@@ -438,9 +648,17 @@ eval_windowaggregates(WindowAggState *winstate)
 	 * damage the running transition value, but we have the same assumption in
 	 * nodeAgg.c too (when it rescans an existing hash table).
 	 *
-	 * For other frame start rules, we discard the aggregate state and re-run
-	 * the aggregates whenever the frame head row moves.  We can still
-	 * optimize as above whenever successive rows share the same frame head.
+	 * If the frame start does sometimes move, we can still optimize as above
+	 * whenever successive rows share the same frame head, but if the frame
+	 * head moves beyond the previous head we try to remove those rows using
+	 * the aggregate's inverse transition function.  This function restores
+	 * the aggregate's current state to what it would be if the removed row
+	 * had never been aggregated in the first place.  Inverse transition
+	 * functions may optionally return NULL, indicating that the function was
+	 * unable to remove the tuple from aggregation.  If this happens, or if
+	 * the aggregate doesn't have an inverse transition function at all, we
+	 * must perform the aggregation all over again for all tuples within the
+	 * new frame boundaries.
 	 *
 	 * In many common cases, multiple rows share the same frame and hence the
 	 * same aggregate value. (In particular, if there's no ORDER BY in a RANGE
@@ -452,75 +670,195 @@ eval_windowaggregates(WindowAggState *winstate)
 	 * 'aggregatedupto' keeps track of the first row that has not yet been
 	 * accumulated into the aggregate transition values.  Whenever we start a
 	 * new peer group, we accumulate forward to the end of the peer group.
-	 *
-	 * TODO: Rerunning aggregates from the frame start can be pretty slow. For
-	 * some aggregates like SUM and COUNT we could avoid that by implementing
-	 * a "negative transition function" that would be called for each row as
-	 * it exits the frame.	We'd have to think about avoiding recalculation of
-	 * volatile arguments of aggregate functions, too.
 	 */
 
 	/*
 	 * First, update the frame head position.
+	 *
+	 * The frame head should never move backwards, and the code below wouldn't
+	 * cope if it did, so for safety we complain if it does.
 	 */
-	update_frameheadpos(agg_winobj, winstate->temp_slot_1);
+	update_frameheadpos(agg_winobj, temp_slot);
+	if (winstate->frameheadpos < winstate->aggregatedbase)
+		elog(ERROR, "window frame head moved backward");
 
 	/*
-	 * Initialize aggregates on first call for partition, or if the frame head
-	 * position moved since last time.
+	 * If the frame didn't change compared to the previous row, we can re-use
+	 * the result values that were previously saved at the bottom of this
+	 * function.  Since we don't know the current frame's end yet, this is not
+	 * possible to check for fully.  But if the frame end mode is UNBOUNDED
+	 * FOLLOWING or CURRENT ROW, and the current row lies within the previous
+	 * row's frame, then the two frames' ends must coincide.  Note that on the
+	 * first row aggregatedbase == aggregatedupto, meaning this test must
+	 * fail, so we don't need to check the "there was no previous row" case
+	 * explicitly here.
 	 */
-	if (winstate->currentpos == 0 ||
-		winstate->frameheadpos != winstate->aggregatedbase)
+	if (winstate->aggregatedbase == winstate->frameheadpos &&
+		(winstate->frameOptions & (FRAMEOPTION_END_UNBOUNDED_FOLLOWING |
+								   FRAMEOPTION_END_CURRENT_ROW)) &&
+		winstate->aggregatedbase <= winstate->currentpos &&
+		winstate->aggregatedupto > winstate->currentpos)
 	{
-		/*
-		 * Discard transient aggregate values
-		 */
-		MemoryContextResetAndDeleteChildren(winstate->aggcontext);
-
 		for (i = 0; i < numaggs; i++)
 		{
 			peraggstate = &winstate->peragg[i];
 			wfuncno = peraggstate->wfuncno;
-			initialize_windowaggregate(winstate,
-									   &winstate->perfunc[wfuncno],
-									   peraggstate);
+			econtext->ecxt_aggvalues[wfuncno] = peraggstate->resultValue;
+			econtext->ecxt_aggnulls[wfuncno] = peraggstate->resultValueIsNull;
 		}
+		return;
+	}
 
+	/*----------
+	 * Initialize restart flags.
+	 *
+	 * We restart the aggregation:
+	 *	 - if we're processing the first row in the partition, or
+	 *	 - if the frame's head moved and we cannot use an inverse
+	 *	   transition function, or
+	 *	 - if the new frame doesn't overlap the old one
+	 *
+	 * Note that we don't strictly need to restart in the last case, but if
+	 * we're going to remove all rows from the aggregation anyway, a restart
+	 * surely is faster.
+	 *----------
+	 */
+	numaggs_restart = 0;
+	for (i = 0; i < numaggs; i++)
+	{
+		peraggstate = &winstate->peragg[i];
+		if (winstate->currentpos == 0 ||
+			(winstate->aggregatedbase != winstate->frameheadpos &&
+			 !OidIsValid(peraggstate->invtransfn_oid)) ||
+			winstate->aggregatedupto <= winstate->frameheadpos)
+		{
+			peraggstate->restart = true;
+			numaggs_restart++;
+		}
+		else
+			peraggstate->restart = false;
+	}
+
+	/*
+	 * If we have any possibly-moving aggregates, attempt to advance
+	 * aggregatedbase to match the frame's head by removing input rows that
+	 * fell off the top of the frame from the aggregations.  This can fail,
+	 * i.e. advance_windowaggregate_base() can return false, in which case
+	 * we'll restart that aggregate below.
+	 */
+	while (numaggs_restart < numaggs &&
+		   winstate->aggregatedbase < winstate->frameheadpos)
+	{
 		/*
-		 * If we created a mark pointer for aggregates, keep it pushed up to
-		 * frame head, so that tuplestore can discard unnecessary rows.
+		 * Fetch the next tuple of those being removed. This should never fail
+		 * as we should have been here before.
 		 */
-		if (agg_winobj->markptr >= 0)
-			WinSetMarkPosition(agg_winobj, winstate->frameheadpos);
+		if (!window_gettupleslot(agg_winobj, winstate->aggregatedbase,
+								 temp_slot))
+			elog(ERROR, "could not re-fetch previously fetched frame row");
+
+		/* Set tuple context for evaluation of aggregate arguments */
+		winstate->tmpcontext->ecxt_outertuple = temp_slot;
 
 		/*
-		 * Initialize for loop below
+		 * Perform the inverse transition for each aggregate function in the
+		 * window, unless it has already been marked as needing a restart.
 		 */
-		ExecClearTuple(agg_row_slot);
-		winstate->aggregatedbase = winstate->frameheadpos;
-		winstate->aggregatedupto = winstate->frameheadpos;
+		for (i = 0; i < numaggs; i++)
+		{
+			bool		ok;
+
+			peraggstate = &winstate->peragg[i];
+			if (peraggstate->restart)
+				continue;
+
+			wfuncno = peraggstate->wfuncno;
+			ok = advance_windowaggregate_base(winstate,
+											  &winstate->perfunc[wfuncno],
+											  peraggstate);
+			if (!ok)
+			{
+				/* Inverse transition function has failed, must restart */
+				peraggstate->restart = true;
+				numaggs_restart++;
+			}
+		}
+
+		/* Reset per-input-tuple context after each tuple */
+		ResetExprContext(winstate->tmpcontext);
+
+		/* And advance the aggregated-row state */
+		winstate->aggregatedbase++;
+		ExecClearTuple(temp_slot);
 	}
 
 	/*
-	 * In UNBOUNDED_FOLLOWING mode, we don't have to recalculate aggregates
-	 * except when the frame head moves.  In END_CURRENT_ROW mode, we only
-	 * have to recalculate when the frame head moves or currentpos has
-	 * advanced past the place we'd aggregated up to.  Check for these cases
-	 * and if so, reuse the saved result values.
+	 * If we successfully advanced the base rows of all the aggregates,
+	 * aggregatedbase now equals frameheadpos; but if we failed for any, we
+	 * must forcibly update aggregatedbase.
 	 */
-	if ((winstate->frameOptions & (FRAMEOPTION_END_UNBOUNDED_FOLLOWING |
-								   FRAMEOPTION_END_CURRENT_ROW)) &&
-		winstate->aggregatedbase <= winstate->currentpos &&
-		winstate->aggregatedupto > winstate->currentpos)
+	winstate->aggregatedbase = winstate->frameheadpos;
+
+	/*
+	 * If we created a mark pointer for aggregates, keep it pushed up to frame
+	 * head, so that tuplestore can discard unnecessary rows.
+	 */
+	if (agg_winobj->markptr >= 0)
+		WinSetMarkPosition(agg_winobj, winstate->frameheadpos);
+
+	/*
+	 * Now restart the aggregates that require it.
+	 *
+	 * We assume that aggregates using the shared context always restart if
+	 * *any* aggregate restarts, and we may thus clean up the shared
+	 * aggcontext if that is the case.	Private aggcontexts are reset by
+	 * initialize_windowaggregate() if their owning aggregate restarts. If we
+	 * aren't restarting an aggregate, we need to free any previously saved
+	 * result for it, else we'll leak memory.
+	 */
+	if (numaggs_restart > 0)
+		MemoryContextResetAndDeleteChildren(winstate->aggcontext);
+	for (i = 0; i < numaggs; i++)
 	{
-		for (i = 0; i < numaggs; i++)
+		peraggstate = &winstate->peragg[i];
+
+		/* Aggregates using the shared ctx must restart if *any* agg does */
+		Assert(peraggstate->aggcontext != winstate->aggcontext ||
+			   numaggs_restart == 0 ||
+			   peraggstate->restart);
+
+		if (peraggstate->restart)
 		{
-			peraggstate = &winstate->peragg[i];
 			wfuncno = peraggstate->wfuncno;
-			econtext->ecxt_aggvalues[wfuncno] = peraggstate->resultValue;
-			econtext->ecxt_aggnulls[wfuncno] = peraggstate->resultValueIsNull;
+			initialize_windowaggregate(winstate,
+									   &winstate->perfunc[wfuncno],
+									   peraggstate);
+		}
+		else if (!peraggstate->resultValueIsNull)
+		{
+			if (!peraggstate->resulttypeByVal)
+				pfree(DatumGetPointer(peraggstate->resultValue));
+			peraggstate->resultValue = (Datum) 0;
+			peraggstate->resultValueIsNull = true;
 		}
-		return;
+	}
+
+	/*
+	 * Non-restarted aggregates now contain the rows between aggregatedbase
+	 * (i.e., frameheadpos) and aggregatedupto, while restarted aggregates
+	 * contain no rows.  If there are any restarted aggregates, we must thus
+	 * begin aggregating anew at frameheadpos, otherwise we may simply
+	 * continue at aggregatedupto.	We must remember the old value of
+	 * aggregatedupto to know how long to skip advancing non-restarted
+	 * aggregates.	If we modify aggregatedupto, we must also clear
+	 * agg_row_slot, per the loop invariant below.
+	 */
+	aggregatedupto_nonrestarted = winstate->aggregatedupto;
+	if (numaggs_restart > 0 &&
+		winstate->aggregatedupto != winstate->frameheadpos)
+	{
+		winstate->aggregatedupto = winstate->frameheadpos;
+		ExecClearTuple(agg_row_slot);
 	}
 
 	/*
@@ -551,6 +889,12 @@ eval_windowaggregates(WindowAggState *winstate)
 		for (i = 0; i < numaggs; i++)
 		{
 			peraggstate = &winstate->peragg[i];
+
+			/* Non-restarted aggs skip until aggregatedupto_nonrestarted */
+			if (!peraggstate->restart &&
+				winstate->aggregatedupto < aggregatedupto_nonrestarted)
+				continue;
+
 			wfuncno = peraggstate->wfuncno;
 			advance_windowaggregate(winstate,
 									&winstate->perfunc[wfuncno],
@@ -565,6 +909,9 @@ eval_windowaggregates(WindowAggState *winstate)
 		ExecClearTuple(agg_row_slot);
 	}
 
+	/* The frame's end is not supposed to move backwards, ever */
+	Assert(aggregatedupto_nonrestarted <= winstate->aggregatedupto);
+
 	/*
 	 * finalize aggregates and fill result/isnull fields.
 	 */
@@ -589,28 +936,14 @@ eval_windowaggregates(WindowAggState *winstate)
 		 * advance that the next row can't possibly share the same frame. Is
 		 * it worth detecting that and skipping this code?
 		 */
-		if (!peraggstate->resulttypeByVal)
+		if (!peraggstate->resulttypeByVal && !*isnull)
 		{
-			/*
-			 * clear old resultValue in order not to leak memory.  (Note: the
-			 * new result can't possibly be the same datum as old resultValue,
-			 * because we never passed it to the trans function.)
-			 */
-			if (!peraggstate->resultValueIsNull)
-				pfree(DatumGetPointer(peraggstate->resultValue));
-
-			/*
-			 * If pass-by-ref, copy it into our aggregate context.
-			 */
-			if (!*isnull)
-			{
-				oldContext = MemoryContextSwitchTo(winstate->aggcontext);
-				peraggstate->resultValue =
-					datumCopy(*result,
-							  peraggstate->resulttypeByVal,
-							  peraggstate->resulttypeLen);
-				MemoryContextSwitchTo(oldContext);
-			}
+			oldContext = MemoryContextSwitchTo(peraggstate->aggcontext);
+			peraggstate->resultValue =
+				datumCopy(*result,
+						  peraggstate->resulttypeByVal,
+						  peraggstate->resulttypeLen);
+			MemoryContextSwitchTo(oldContext);
 		}
 		else
 		{
@@ -650,6 +983,8 @@ eval_windowfunction(WindowAggState *winstate, WindowStatePerFunc perfuncstate,
 							 (void *) perfuncstate->winobj, NULL);
 	/* Just in case, make all the regular argument slots be null */
 	memset(fcinfo.argnull, true, perfuncstate->numArguments);
+	/* Window functions don't have a current aggregate context, either */
+	winstate->curaggcontext = NULL;
 
 	*result = FunctionCallInvoke(&fcinfo);
 	*isnull = fcinfo.isnull;
@@ -870,6 +1205,11 @@ release_partition(WindowAggState *winstate)
 	 */
 	MemoryContextResetAndDeleteChildren(winstate->partcontext);
 	MemoryContextResetAndDeleteChildren(winstate->aggcontext);
+	for (i = 0; i < winstate->numaggs; i++)
+	{
+		if (winstate->peragg[i].aggcontext != winstate->aggcontext)
+			MemoryContextResetAndDeleteChildren(winstate->peragg[i].aggcontext);
+	}
 
 	if (winstate->buffer)
 		tuplestore_end(winstate->buffer);
@@ -1450,7 +1790,12 @@ ExecInitWindowAgg(WindowAgg *node, EState *estate, int eflags)
 							  ALLOCSET_DEFAULT_INITSIZE,
 							  ALLOCSET_DEFAULT_MAXSIZE);
 
-	/* Create mid-lived context for aggregate trans values etc */
+	/*
+	 * Create mid-lived context for aggregate trans values etc.
+	 *
+	 * Note that moving aggregates each use their own private context, not
+	 * this one.
+	 */
 	winstate->aggcontext =
 		AllocSetContextCreate(CurrentMemoryContext,
 							  "WindowAgg_Aggregates",
@@ -1657,12 +2002,10 @@ void
 ExecEndWindowAgg(WindowAggState *node)
 {
 	PlanState  *outerPlan;
+	int			i;
 
 	release_partition(node);
 
-	pfree(node->perfunc);
-	pfree(node->peragg);
-
 	ExecClearTuple(node->ss.ss_ScanTupleSlot);
 	ExecClearTuple(node->first_part_slot);
 	ExecClearTuple(node->agg_row_slot);
@@ -1676,9 +2019,17 @@ ExecEndWindowAgg(WindowAggState *node)
 	node->ss.ps.ps_ExprContext = node->tmpcontext;
 	ExecFreeExprContext(&node->ss.ps);
 
+	for (i = 0; i < node->numaggs; i++)
+	{
+		if (node->peragg[i].aggcontext != node->aggcontext)
+			MemoryContextDelete(node->peragg[i].aggcontext);
+	}
 	MemoryContextDelete(node->partcontext);
 	MemoryContextDelete(node->aggcontext);
 
+	pfree(node->perfunc);
+	pfree(node->peragg);
+
 	outerPlan = outerPlanState(node);
 	ExecEndNode(outerPlan);
 }
@@ -1733,10 +2084,13 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 	HeapTuple	aggTuple;
 	Form_pg_aggregate aggform;
 	Oid			aggtranstype;
+	AttrNumber	initvalAttNo;
 	AclResult	aclresult;
 	Oid			transfn_oid,
+				invtransfn_oid,
 				finalfn_oid;
 	Expr	   *transfnexpr,
+			   *invtransfnexpr,
 			   *finalfnexpr;
 	Datum		textInitVal;
 	int			i;
@@ -1757,13 +2111,39 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 	aggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);
 
 	/*
+	 * Figure out whether we want to use the moving-aggregate implementation,
+	 * and collect the right set of fields from the pg_attribute entry.
+	 *
+	 * If the frame head can't move, we don't need moving-aggregate code. Even
+	 * if we'd like to use it, don't do so if the aggregate's arguments (and
+	 * FILTER clause if any) contain any calls to volatile functions.
+	 * Otherwise, the difference between restarting and not restarting the
+	 * aggregation would be user-visible.
+	 */
+	if (OidIsValid(aggform->aggminvtransfn) &&
+		!(winstate->frameOptions & FRAMEOPTION_START_UNBOUNDED_PRECEDING) &&
+		!contain_volatile_functions((Node *) wfunc))
+	{
+		peraggstate->transfn_oid = transfn_oid = aggform->aggmtransfn;
+		peraggstate->invtransfn_oid = invtransfn_oid = aggform->aggminvtransfn;
+		peraggstate->finalfn_oid = finalfn_oid = aggform->aggmfinalfn;
+		aggtranstype = aggform->aggmtranstype;
+		initvalAttNo = Anum_pg_aggregate_aggminitval;
+	}
+	else
+	{
+		peraggstate->transfn_oid = transfn_oid = aggform->aggtransfn;
+		peraggstate->invtransfn_oid = invtransfn_oid = InvalidOid;
+		peraggstate->finalfn_oid = finalfn_oid = aggform->aggfinalfn;
+		aggtranstype = aggform->aggtranstype;
+		initvalAttNo = Anum_pg_aggregate_agginitval;
+	}
+
+	/*
 	 * ExecInitWindowAgg already checked permission to call aggregate function
 	 * ... but we still need to check the component functions
 	 */
 
-	peraggstate->transfn_oid = transfn_oid = aggform->aggtransfn;
-	peraggstate->finalfn_oid = finalfn_oid = aggform->aggfinalfn;
-
 	/* Check that aggregate owner has permission to call component fns */
 	{
 		HeapTuple	procTuple;
@@ -1783,6 +2163,17 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 			aclcheck_error(aclresult, ACL_KIND_PROC,
 						   get_func_name(transfn_oid));
 		InvokeFunctionExecuteHook(transfn_oid);
+
+		if (OidIsValid(invtransfn_oid))
+		{
+			aclresult = pg_proc_aclcheck(invtransfn_oid, aggOwner,
+										 ACL_EXECUTE);
+			if (aclresult != ACLCHECK_OK)
+				aclcheck_error(aclresult, ACL_KIND_PROC,
+							   get_func_name(invtransfn_oid));
+			InvokeFunctionExecuteHook(invtransfn_oid);
+		}
+
 		if (OidIsValid(finalfn_oid))
 		{
 			aclresult = pg_proc_aclcheck(finalfn_oid, aggOwner,
@@ -1796,7 +2187,7 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 
 	/* resolve actual type of transition state, if polymorphic */
 	aggtranstype = resolve_aggregate_transtype(wfunc->winfnoid,
-											   aggform->aggtranstype,
+											   aggtranstype,
 											   inputTypes,
 											   numArguments);
 
@@ -1810,13 +2201,21 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 							wfunc->wintype,
 							wfunc->inputcollid,
 							transfn_oid,
+							invtransfn_oid,
 							finalfn_oid,
 							&transfnexpr,
+							&invtransfnexpr,
 							&finalfnexpr);
 
 	fmgr_info(transfn_oid, &peraggstate->transfn);
 	fmgr_info_set_expr((Node *) transfnexpr, &peraggstate->transfn);
 
+	if (OidIsValid(invtransfn_oid))
+	{
+		fmgr_info(invtransfn_oid, &peraggstate->invtransfn);
+		fmgr_info_set_expr((Node *) invtransfnexpr, &peraggstate->invtransfn);
+	}
+
 	if (OidIsValid(finalfn_oid))
 	{
 		fmgr_info(finalfn_oid, &peraggstate->finalfn);
@@ -1834,8 +2233,7 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 	 * initval is potentially null, so don't try to access it as a struct
 	 * field. Must do it the hard way with SysCacheGetAttr.
 	 */
-	textInitVal = SysCacheGetAttr(AGGFNOID, aggTuple,
-								  Anum_pg_aggregate_agginitval,
+	textInitVal = SysCacheGetAttr(AGGFNOID, aggTuple, initvalAttNo,
 								  &peraggstate->initValueIsNull);
 
 	if (peraggstate->initValueIsNull)
@@ -1848,7 +2246,8 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 	 * If the transfn is strict and the initval is NULL, make sure input type
 	 * and transtype are the same (or at least binary-compatible), so that
 	 * it's OK to use the first input value as the initial transValue.  This
-	 * should have been checked at agg definition time, but just in case...
+	 * should have been checked at agg definition time, but we must check
+	 * again in case the transfn's strictness property has been changed.
 	 */
 	if (peraggstate->transfn.fn_strict && peraggstate->initValueIsNull)
 	{
@@ -1860,6 +2259,44 @@ initialize_peragg(WindowAggState *winstate, WindowFunc *wfunc,
 							wfunc->winfnoid)));
 	}
 
+	/*
+	 * Insist that forward and inverse transition functions have the same
+	 * strictness setting.	Allowing them to differ would require handling
+	 * more special cases in advance_windowaggregate and
+	 * advance_windowaggregate_base, for no discernible benefit.  This should
+	 * have been checked at agg definition time, but we must check again in
+	 * case either function's strictness property has been changed.
+	 */
+	if (OidIsValid(invtransfn_oid) &&
+		peraggstate->transfn.fn_strict != peraggstate->invtransfn.fn_strict)
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
+				 errmsg("strictness of aggregate's forward and inverse transition functions must match")));
+
+	/*
+	 * Moving aggregates use their own aggcontext.
+	 *
+	 * This is necessary because they might restart at different times, so we
+	 * might never be able to reset the shared context otherwise.  We can't
+	 * make it the aggregates' responsibility to clean up after themselves,
+	 * because strict aggregates must be restarted whenever we remove their
+	 * last non-NULL input, which the aggregate won't be aware is happening.
+	 * Also, just pfree()ing the transValue upon restarting wouldn't help,
+	 * since we'd miss any indirectly referenced data.  We could, in theory,
+	 * make the memory allocation rules for moving aggregates different than
+	 * they have historically been for plain aggregates, but that seems grotty
+	 * and likely to lead to memory leaks.
+	 */
+	if (OidIsValid(invtransfn_oid))
+		peraggstate->aggcontext =
+			AllocSetContextCreate(CurrentMemoryContext,
+								  "WindowAgg_AggregatePrivate",
+								  ALLOCSET_DEFAULT_MINSIZE,
+								  ALLOCSET_DEFAULT_INITSIZE,
+								  ALLOCSET_DEFAULT_MAXSIZE);
+	else
+		peraggstate->aggcontext = winstate->aggcontext;
+
 	ReleaseSysCache(aggTuple);
 
 	return peraggstate;
diff --git a/src/backend/optimizer/util/clauses.c b/src/backend/optimizer/util/clauses.c
index 201529b..3f307e6 100644
--- a/src/backend/optimizer/util/clauses.c
+++ b/src/backend/optimizer/util/clauses.c
@@ -471,7 +471,11 @@ count_agg_clauses_walker(Node *node, count_agg_clauses_context *context)
 
 		Assert(aggref->agglevelsup == 0);
 
-		/* fetch info about aggregate from pg_aggregate */
+		/*
+		 * Fetch info about aggregate from pg_aggregate.  Note it's correct to
+		 * ignore the moving-aggregate variant, since what we're concerned
+		 * with here is aggregates not window functions.
+		 */
 		aggTuple = SearchSysCache1(AGGFNOID,
 								   ObjectIdGetDatum(aggref->aggfnoid));
 		if (!HeapTupleIsValid(aggTuple))
diff --git a/src/backend/parser/parse_agg.c b/src/backend/parser/parse_agg.c
index 9613e2a..272d27f 100644
--- a/src/backend/parser/parse_agg.c
+++ b/src/backend/parser/parse_agg.c
@@ -1187,11 +1187,13 @@ resolve_aggregate_transtype(Oid aggfuncid,
  * For an ordered-set aggregate, remember that agg_input_types describes
  * the direct arguments followed by the aggregated arguments.
  *
- * transfn_oid and finalfn_oid identify the funcs to be called; the latter
- * may be InvalidOid.
+ * transfn_oid, invtransfn_oid and finalfn_oid identify the funcs to be
+ * called; the latter two may be InvalidOid.
  *
- * Pointers to the constructed trees are returned into *transfnexpr and
- * *finalfnexpr.  The latter is set to NULL if there's no finalfn.
+ * Pointers to the constructed trees are returned into *transfnexpr,
+ * *invtransfnexpr and *finalfnexpr. If there is no invtransfn or finalfn,
+ * the respective pointers are set to NULL.  Since use of the invtransfn is
+ * optional, NULL may be passed for invtransfnexpr.
  */
 void
 build_aggregate_fnexprs(Oid *agg_input_types,
@@ -1203,8 +1205,10 @@ build_aggregate_fnexprs(Oid *agg_input_types,
 						Oid agg_result_type,
 						Oid agg_input_collation,
 						Oid transfn_oid,
+						Oid invtransfn_oid,
 						Oid finalfn_oid,
 						Expr **transfnexpr,
+						Expr **invtransfnexpr,
 						Expr **finalfnexpr)
 {
 	Param	   *argp;
@@ -1249,6 +1253,26 @@ build_aggregate_fnexprs(Oid *agg_input_types,
 	fexpr->funcvariadic = agg_variadic;
 	*transfnexpr = (Expr *) fexpr;
 
+	/*
+	 * Build invtransfn expression if requested, with same args as transfn
+	 */
+	if (invtransfnexpr != NULL)
+	{
+		if (OidIsValid(invtransfn_oid))
+		{
+			fexpr = makeFuncExpr(invtransfn_oid,
+								 agg_state_type,
+								 args,
+								 InvalidOid,
+								 agg_input_collation,
+								 COERCE_EXPLICIT_CALL);
+			fexpr->funcvariadic = agg_variadic;
+			*invtransfnexpr = (Expr *) fexpr;
+		}
+		else
+			*invtransfnexpr = NULL;
+	}
+
 	/* see if we have a final function */
 	if (!OidIsValid(finalfn_oid))
 	{
diff --git a/src/bin/pg_dump/pg_dump.c b/src/bin/pg_dump/pg_dump.c
index 2653ef0..a6c0428 100644
--- a/src/bin/pg_dump/pg_dump.c
+++ b/src/bin/pg_dump/pg_dump.c
@@ -11548,20 +11548,32 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	PGresult   *res;
 	int			i_aggtransfn;
 	int			i_aggfinalfn;
+	int			i_aggmtransfn;
+	int			i_aggminvtransfn;
+	int			i_aggmfinalfn;
 	int			i_aggsortop;
 	int			i_hypothetical;
 	int			i_aggtranstype;
 	int			i_aggtransspace;
+	int			i_aggmtranstype;
+	int			i_aggmtransspace;
 	int			i_agginitval;
+	int			i_aggminitval;
 	int			i_convertok;
 	const char *aggtransfn;
 	const char *aggfinalfn;
+	const char *aggmtransfn;
+	const char *aggminvtransfn;
+	const char *aggmfinalfn;
 	const char *aggsortop;
 	char	   *aggsortconvop;
 	bool		hypothetical;
 	const char *aggtranstype;
 	const char *aggtransspace;
+	const char *aggmtranstype;
+	const char *aggmtransspace;
 	const char *agginitval;
+	const char *aggminitval;
 	bool		convertok;
 
 	/* Skip if not to be dumped */
@@ -11582,9 +11594,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, "
 						  "aggfinalfn, aggtranstype::pg_catalog.regtype, "
+						  "aggmtransfn, aggminvtransfn, aggmfinalfn, "
+						  "aggmtranstype::pg_catalog.regtype, "
 						  "aggsortop::pg_catalog.regoperator, "
 						  "(aggkind = 'h') as hypothetical, "
 						  "aggtransspace, agginitval, "
+						  "aggmtransspace, aggminitval, "
 						  "'t'::boolean AS convertok, "
 						  "pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "
 						  "pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs "
@@ -11597,9 +11612,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, "
 						  "aggfinalfn, aggtranstype::pg_catalog.regtype, "
+						  "'-' AS aggmtransfn, '-' AS aggminvtransfn, "
+						  "'-' AS aggmfinalfn, 0 AS aggmtranstype, "
 						  "aggsortop::pg_catalog.regoperator, "
 						  "false as hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
+						  "0 AS aggmtransspace, NULL AS aggminitval, "
 						  "'t'::boolean AS convertok, "
 						  "pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "
 						  "pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs "
@@ -11612,9 +11630,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, "
 						  "aggfinalfn, aggtranstype::pg_catalog.regtype, "
+						  "'-' AS aggmtransfn, '-' AS aggminvtransfn, "
+						  "'-' AS aggmfinalfn, 0 AS aggmtranstype, "
 						  "aggsortop::pg_catalog.regoperator, "
 						  "false as hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
+						  "0 AS aggmtransspace, NULL AS aggminitval, "
 						  "'t'::boolean AS convertok "
 						  "FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "
 						  "WHERE a.aggfnoid = p.oid "
@@ -11625,9 +11646,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, "
 						  "aggfinalfn, aggtranstype::pg_catalog.regtype, "
+						  "'-' AS aggmtransfn, '-' AS aggminvtransfn, "
+						  "'-' AS aggmfinalfn, 0 AS aggmtranstype, "
 						  "0 AS aggsortop, "
 						  "'f'::boolean as hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
+						  "0 AS aggmtransspace, NULL AS aggminitval, "
 						  "'t'::boolean AS convertok "
 					  "FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "
 						  "WHERE a.aggfnoid = p.oid "
@@ -11638,9 +11662,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, aggfinalfn, "
 						  "format_type(aggtranstype, NULL) AS aggtranstype, "
+						  "'-' AS aggmtransfn, '-' AS aggminvtransfn, "
+						  "'-' AS aggmfinalfn, 0 AS aggmtranstype, "
 						  "0 AS aggsortop, "
 						  "'f'::boolean as hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
+						  "0 AS aggmtransspace, NULL AS aggminitval, "
 						  "'t'::boolean AS convertok "
 						  "FROM pg_aggregate "
 						  "WHERE oid = '%u'::oid",
@@ -11651,9 +11678,12 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 		appendPQExpBuffer(query, "SELECT aggtransfn1 AS aggtransfn, "
 						  "aggfinalfn, "
 						  "(SELECT typname FROM pg_type WHERE oid = aggtranstype1) AS aggtranstype, "
+						  "'-' AS aggmtransfn, '-' AS aggminvtransfn, "
+						  "'-' AS aggmfinalfn, 0 AS aggmtranstype, "
 						  "0 AS aggsortop, "
 						  "'f'::boolean as hypothetical, "
 						  "0 AS aggtransspace, agginitval1 AS agginitval, "
+						  "0 AS aggmtransspace, NULL AS aggminitval, "
 						  "(aggtransfn2 = 0 and aggtranstype2 = 0 and agginitval2 is null) AS convertok "
 						  "FROM pg_aggregate "
 						  "WHERE oid = '%u'::oid",
@@ -11664,20 +11694,32 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 
 	i_aggtransfn = PQfnumber(res, "aggtransfn");
 	i_aggfinalfn = PQfnumber(res, "aggfinalfn");
+	i_aggmtransfn = PQfnumber(res, "aggmtransfn");
+	i_aggminvtransfn = PQfnumber(res, "aggminvtransfn");
+	i_aggmfinalfn = PQfnumber(res, "aggmfinalfn");
 	i_aggsortop = PQfnumber(res, "aggsortop");
 	i_hypothetical = PQfnumber(res, "hypothetical");
 	i_aggtranstype = PQfnumber(res, "aggtranstype");
 	i_aggtransspace = PQfnumber(res, "aggtransspace");
+	i_aggmtranstype = PQfnumber(res, "aggmtranstype");
+	i_aggmtransspace = PQfnumber(res, "aggmtransspace");
 	i_agginitval = PQfnumber(res, "agginitval");
+	i_aggminitval = PQfnumber(res, "aggminitval");
 	i_convertok = PQfnumber(res, "convertok");
 
 	aggtransfn = PQgetvalue(res, 0, i_aggtransfn);
 	aggfinalfn = PQgetvalue(res, 0, i_aggfinalfn);
+	aggmtransfn = PQgetvalue(res, 0, i_aggmtransfn);
+	aggminvtransfn = PQgetvalue(res, 0, i_aggminvtransfn);
+	aggmfinalfn = PQgetvalue(res, 0, i_aggmfinalfn);
 	aggsortop = PQgetvalue(res, 0, i_aggsortop);
 	hypothetical = (PQgetvalue(res, 0, i_hypothetical)[0] == 't');
 	aggtranstype = PQgetvalue(res, 0, i_aggtranstype);
 	aggtransspace = PQgetvalue(res, 0, i_aggtransspace);
+	aggmtranstype = PQgetvalue(res, 0, i_aggmtranstype);
+	aggmtransspace = PQgetvalue(res, 0, i_aggmtransspace);
 	agginitval = PQgetvalue(res, 0, i_agginitval);
+	aggminitval = PQgetvalue(res, 0, i_aggminitval);
 	convertok = (PQgetvalue(res, 0, i_convertok)[0] == 't');
 
 	if (fout->remoteVersion >= 80400)
@@ -11751,6 +11793,32 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						  aggfinalfn);
 	}
 
+	if (strcmp(aggmtransfn, "-") != 0)
+	{
+		appendPQExpBuffer(details, ",\n    MSFUNC = %s,\n    MINVFUNC = %s,\n    MSTYPE = %s",
+						  aggmtransfn,
+						  aggminvtransfn,
+						  aggmtranstype);
+	}
+
+	if (strcmp(aggmtransspace, "0") != 0)
+	{
+		appendPQExpBuffer(details, ",\n    MSSPACE = %s",
+						  aggmtransspace);
+	}
+
+	if (!PQgetisnull(res, 0, i_aggminitval))
+	{
+		appendPQExpBufferStr(details, ",\n    MINITCOND = ");
+		appendStringLiteralAH(details, aggminitval, fout);
+	}
+
+	if (strcmp(aggmfinalfn, "-") != 0)
+	{
+		appendPQExpBuffer(details, ",\n    MFINALFUNC = %s",
+						  aggmfinalfn);
+	}
+
 	aggsortconvop = convertOperatorReference(fout, aggsortop);
 	if (aggsortconvop)
 	{
diff --git a/src/include/catalog/catversion.h b/src/include/catalog/catversion.h
index fe6144e..2fb0ce8 100644
--- a/src/include/catalog/catversion.h
+++ b/src/include/catalog/catversion.h
@@ -53,6 +53,6 @@
  */
 
 /*							yyyymmddN */
-#define CATALOG_VERSION_NO	201404082
+#define CATALOG_VERSION_NO	201404121
 
 #endif
diff --git a/src/include/catalog/pg_aggregate.h b/src/include/catalog/pg_aggregate.h
index f189998..3cb0d75 100644
--- a/src/include/catalog/pg_aggregate.h
+++ b/src/include/catalog/pg_aggregate.h
@@ -32,10 +32,16 @@
  *	aggnumdirectargs	number of arguments that are "direct" arguments
  *	aggtransfn			transition function
  *	aggfinalfn			final function (0 if none)
+ *	aggmtransfn			forward function for moving-aggregate mode (0 if none)
+ *	aggminvtransfn		inverse function for moving-aggregate mode (0 if none)
+ *	aggmfinalfn			final function for moving-aggregate mode (0 if none)
  *	aggsortop			associated sort operator (0 if none)
  *	aggtranstype		type of aggregate's transition (state) data
  *	aggtransspace		estimated size of state data (0 for default estimate)
+ *	aggmtranstype		type of moving-aggregate state data (0 if none)
+ *	aggmtransspace		estimated size of moving-agg state (0 for default est)
  *	agginitval			initial value for transition state (can be NULL)
+ *	aggminitval			initial value for moving-agg state (can be NULL)
  * ----------------------------------------------------------------
  */
 #define AggregateRelationId  2600
@@ -47,12 +53,18 @@ CATALOG(pg_aggregate,2600) BKI_WITHOUT_OIDS
 	int16		aggnumdirectargs;
 	regproc		aggtransfn;
 	regproc		aggfinalfn;
+	regproc		aggmtransfn;
+	regproc		aggminvtransfn;
+	regproc		aggmfinalfn;
 	Oid			aggsortop;
 	Oid			aggtranstype;
 	int32		aggtransspace;
+	Oid			aggmtranstype;
+	int32		aggmtransspace;
 
 #ifdef CATALOG_VARLEN			/* variable-length fields start here */
 	text		agginitval;
+	text		aggminitval;
 #endif
 } FormData_pg_aggregate;
 
@@ -68,16 +80,22 @@ typedef FormData_pg_aggregate *Form_pg_aggregate;
  * ----------------
  */
 
-#define Natts_pg_aggregate					9
+#define Natts_pg_aggregate					15
 #define Anum_pg_aggregate_aggfnoid			1
 #define Anum_pg_aggregate_aggkind			2
 #define Anum_pg_aggregate_aggnumdirectargs	3
 #define Anum_pg_aggregate_aggtransfn		4
 #define Anum_pg_aggregate_aggfinalfn		5
-#define Anum_pg_aggregate_aggsortop			6
-#define Anum_pg_aggregate_aggtranstype		7
-#define Anum_pg_aggregate_aggtransspace		8
-#define Anum_pg_aggregate_agginitval		9
+#define Anum_pg_aggregate_aggmtransfn		6
+#define Anum_pg_aggregate_aggminvtransfn	7
+#define Anum_pg_aggregate_aggmfinalfn		8
+#define Anum_pg_aggregate_aggsortop			9
+#define Anum_pg_aggregate_aggtranstype		10
+#define Anum_pg_aggregate_aggtransspace		11
+#define Anum_pg_aggregate_aggmtranstype		12
+#define Anum_pg_aggregate_aggmtransspace	13
+#define Anum_pg_aggregate_agginitval		14
+#define Anum_pg_aggregate_aggminitval		15
 
 /*
  * Symbolic values for aggkind column.	We distinguish normal aggregates
@@ -101,177 +119,177 @@ typedef FormData_pg_aggregate *Form_pg_aggregate;
  */
 
 /* avg */
-DATA(insert ( 2100	n 0 int8_avg_accum	numeric_avg		0	2281	128 _null_ ));
-DATA(insert ( 2101	n 0 int4_avg_accum	int8_avg		0	1016	0	"{0,0}" ));
-DATA(insert ( 2102	n 0 int2_avg_accum	int8_avg		0	1016	0	"{0,0}" ));
-DATA(insert ( 2103	n 0 numeric_avg_accum	numeric_avg 0	2281	128 _null_ ));
-DATA(insert ( 2104	n 0 float4_accum	float8_avg		0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2105	n 0 float8_accum	float8_avg		0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2106	n 0 interval_accum	interval_avg	0	1187	0	"{0 second,0 second}" ));
+DATA(insert ( 2100	n 0 int8_avg_accum	numeric_avg		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2101	n 0 int4_avg_accum	int8_avg		-				-				-				0	1016	0	0	0	"{0,0}" _null_ ));
+DATA(insert ( 2102	n 0 int2_avg_accum	int8_avg		-				-				-				0	1016	0	0	0	"{0,0}" _null_ ));
+DATA(insert ( 2103	n 0 numeric_avg_accum	numeric_avg -				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2104	n 0 float4_accum	float8_avg		-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2105	n 0 float8_accum	float8_avg		-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2106	n 0 interval_accum	interval_avg	-				-				-				0	1187	0	0	0	"{0 second,0 second}" _null_ ));
 
 /* sum */
-DATA(insert ( 2107	n 0 int8_avg_accum	numeric_sum		0	2281	128 _null_ ));
-DATA(insert ( 2108	n 0 int4_sum		-				0	20		0	_null_ ));
-DATA(insert ( 2109	n 0 int2_sum		-				0	20		0	_null_ ));
-DATA(insert ( 2110	n 0 float4pl		-				0	700		0	_null_ ));
-DATA(insert ( 2111	n 0 float8pl		-				0	701		0	_null_ ));
-DATA(insert ( 2112	n 0 cash_pl			-				0	790		0	_null_ ));
-DATA(insert ( 2113	n 0 interval_pl		-				0	1186	0	_null_ ));
-DATA(insert ( 2114	n 0 numeric_avg_accum	numeric_sum 0	2281	128 _null_ ));
+DATA(insert ( 2107	n 0 int8_avg_accum	numeric_sum		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2108	n 0 int4_sum		-				-				-				-				0	20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2109	n 0 int2_sum		-				-				-				-				0	20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2110	n 0 float4pl		-				-				-				-				0	700		0	0	0	_null_ _null_ ));
+DATA(insert ( 2111	n 0 float8pl		-				-				-				-				0	701		0	0	0	_null_ _null_ ));
+DATA(insert ( 2112	n 0 cash_pl			-				-				-				-				0	790		0	0	0	_null_ _null_ ));
+DATA(insert ( 2113	n 0 interval_pl		-				-				-				-				0	1186	0	0	0	_null_ _null_ ));
+DATA(insert ( 2114	n 0 numeric_avg_accum	numeric_sum -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* max */
-DATA(insert ( 2115	n 0 int8larger		-				413		20		0	_null_ ));
-DATA(insert ( 2116	n 0 int4larger		-				521		23		0	_null_ ));
-DATA(insert ( 2117	n 0 int2larger		-				520		21		0	_null_ ));
-DATA(insert ( 2118	n 0 oidlarger		-				610		26		0	_null_ ));
-DATA(insert ( 2119	n 0 float4larger	-				623		700		0	_null_ ));
-DATA(insert ( 2120	n 0 float8larger	-				674		701		0	_null_ ));
-DATA(insert ( 2121	n 0 int4larger		-				563		702		0	_null_ ));
-DATA(insert ( 2122	n 0 date_larger		-				1097	1082	0	_null_ ));
-DATA(insert ( 2123	n 0 time_larger		-				1112	1083	0	_null_ ));
-DATA(insert ( 2124	n 0 timetz_larger	-				1554	1266	0	_null_ ));
-DATA(insert ( 2125	n 0 cashlarger		-				903		790		0	_null_ ));
-DATA(insert ( 2126	n 0 timestamp_larger	-			2064	1114	0	_null_ ));
-DATA(insert ( 2127	n 0 timestamptz_larger	-			1324	1184	0	_null_ ));
-DATA(insert ( 2128	n 0 interval_larger -				1334	1186	0	_null_ ));
-DATA(insert ( 2129	n 0 text_larger		-				666		25		0	_null_ ));
-DATA(insert ( 2130	n 0 numeric_larger	-				1756	1700	0	_null_ ));
-DATA(insert ( 2050	n 0 array_larger	-				1073	2277	0	_null_ ));
-DATA(insert ( 2244	n 0 bpchar_larger	-				1060	1042	0	_null_ ));
-DATA(insert ( 2797	n 0 tidlarger		-				2800	27		0	_null_ ));
-DATA(insert ( 3526	n 0 enum_larger		-				3519	3500	0	_null_ ));
+DATA(insert ( 2115	n 0 int8larger		-				-				-				-				413		20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2116	n 0 int4larger		-				-				-				-				521		23		0	0	0	_null_ _null_ ));
+DATA(insert ( 2117	n 0 int2larger		-				-				-				-				520		21		0	0	0	_null_ _null_ ));
+DATA(insert ( 2118	n 0 oidlarger		-				-				-				-				610		26		0	0	0	_null_ _null_ ));
+DATA(insert ( 2119	n 0 float4larger	-				-				-				-				623		700		0	0	0	_null_ _null_ ));
+DATA(insert ( 2120	n 0 float8larger	-				-				-				-				674		701		0	0	0	_null_ _null_ ));
+DATA(insert ( 2121	n 0 int4larger		-				-				-				-				563		702		0	0	0	_null_ _null_ ));
+DATA(insert ( 2122	n 0 date_larger		-				-				-				-				1097	1082	0	0	0	_null_ _null_ ));
+DATA(insert ( 2123	n 0 time_larger		-				-				-				-				1112	1083	0	0	0	_null_ _null_ ));
+DATA(insert ( 2124	n 0 timetz_larger	-				-				-				-				1554	1266	0	0	0	_null_ _null_ ));
+DATA(insert ( 2125	n 0 cashlarger		-				-				-				-				903		790		0	0	0	_null_ _null_ ));
+DATA(insert ( 2126	n 0 timestamp_larger	-			-				-				-				2064	1114	0	0	0	_null_ _null_ ));
+DATA(insert ( 2127	n 0 timestamptz_larger	-			-				-				-				1324	1184	0	0	0	_null_ _null_ ));
+DATA(insert ( 2128	n 0 interval_larger -				-				-				-				1334	1186	0	0	0	_null_ _null_ ));
+DATA(insert ( 2129	n 0 text_larger		-				-				-				-				666		25		0	0	0	_null_ _null_ ));
+DATA(insert ( 2130	n 0 numeric_larger	-				-				-				-				1756	1700	0	0	0	_null_ _null_ ));
+DATA(insert ( 2050	n 0 array_larger	-				-				-				-				1073	2277	0	0	0	_null_ _null_ ));
+DATA(insert ( 2244	n 0 bpchar_larger	-				-				-				-				1060	1042	0	0	0	_null_ _null_ ));
+DATA(insert ( 2797	n 0 tidlarger		-				-				-				-				2800	27		0	0	0	_null_ _null_ ));
+DATA(insert ( 3526	n 0 enum_larger		-				-				-				-				3519	3500	0	0	0	_null_ _null_ ));
 
 /* min */
-DATA(insert ( 2131	n 0 int8smaller		-				412		20		0	_null_ ));
-DATA(insert ( 2132	n 0 int4smaller		-				97		23		0	_null_ ));
-DATA(insert ( 2133	n 0 int2smaller		-				95		21		0	_null_ ));
-DATA(insert ( 2134	n 0 oidsmaller		-				609		26		0	_null_ ));
-DATA(insert ( 2135	n 0 float4smaller	-				622		700		0	_null_ ));
-DATA(insert ( 2136	n 0 float8smaller	-				672		701		0	_null_ ));
-DATA(insert ( 2137	n 0 int4smaller		-				562		702		0	_null_ ));
-DATA(insert ( 2138	n 0 date_smaller	-				1095	1082	0	_null_ ));
-DATA(insert ( 2139	n 0 time_smaller	-				1110	1083	0	_null_ ));
-DATA(insert ( 2140	n 0 timetz_smaller	-				1552	1266	0	_null_ ));
-DATA(insert ( 2141	n 0 cashsmaller		-				902		790		0	_null_ ));
-DATA(insert ( 2142	n 0 timestamp_smaller	-			2062	1114	0	_null_ ));
-DATA(insert ( 2143	n 0 timestamptz_smaller -			1322	1184	0	_null_ ));
-DATA(insert ( 2144	n 0 interval_smaller	-			1332	1186	0	_null_ ));
-DATA(insert ( 2145	n 0 text_smaller	-				664		25		0	_null_ ));
-DATA(insert ( 2146	n 0 numeric_smaller -				1754	1700	0	_null_ ));
-DATA(insert ( 2051	n 0 array_smaller	-				1072	2277	0	_null_ ));
-DATA(insert ( 2245	n 0 bpchar_smaller	-				1058	1042	0	_null_ ));
-DATA(insert ( 2798	n 0 tidsmaller		-				2799	27		0	_null_ ));
-DATA(insert ( 3527	n 0 enum_smaller	-				3518	3500	0	_null_ ));
+DATA(insert ( 2131	n 0 int8smaller		-				-				-				-				412		20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2132	n 0 int4smaller		-				-				-				-				97		23		0	0	0	_null_ _null_ ));
+DATA(insert ( 2133	n 0 int2smaller		-				-				-				-				95		21		0	0	0	_null_ _null_ ));
+DATA(insert ( 2134	n 0 oidsmaller		-				-				-				-				609		26		0	0	0	_null_ _null_ ));
+DATA(insert ( 2135	n 0 float4smaller	-				-				-				-				622		700		0	0	0	_null_ _null_ ));
+DATA(insert ( 2136	n 0 float8smaller	-				-				-				-				672		701		0	0	0	_null_ _null_ ));
+DATA(insert ( 2137	n 0 int4smaller		-				-				-				-				562		702		0	0	0	_null_ _null_ ));
+DATA(insert ( 2138	n 0 date_smaller	-				-				-				-				1095	1082	0	0	0	_null_ _null_ ));
+DATA(insert ( 2139	n 0 time_smaller	-				-				-				-				1110	1083	0	0	0	_null_ _null_ ));
+DATA(insert ( 2140	n 0 timetz_smaller	-				-				-				-				1552	1266	0	0	0	_null_ _null_ ));
+DATA(insert ( 2141	n 0 cashsmaller		-				-				-				-				902		790		0	0	0	_null_ _null_ ));
+DATA(insert ( 2142	n 0 timestamp_smaller	-			-				-				-				2062	1114	0	0	0	_null_ _null_ ));
+DATA(insert ( 2143	n 0 timestamptz_smaller -			-				-				-				1322	1184	0	0	0	_null_ _null_ ));
+DATA(insert ( 2144	n 0 interval_smaller	-			-				-				-				1332	1186	0	0	0	_null_ _null_ ));
+DATA(insert ( 2145	n 0 text_smaller	-				-				-				-				664		25		0	0	0	_null_ _null_ ));
+DATA(insert ( 2146	n 0 numeric_smaller -				-				-				-				1754	1700	0	0	0	_null_ _null_ ));
+DATA(insert ( 2051	n 0 array_smaller	-				-				-				-				1072	2277	0	0	0	_null_ _null_ ));
+DATA(insert ( 2245	n 0 bpchar_smaller	-				-				-				-				1058	1042	0	0	0	_null_ _null_ ));
+DATA(insert ( 2798	n 0 tidsmaller		-				-				-				-				2799	27		0	0	0	_null_ _null_ ));
+DATA(insert ( 3527	n 0 enum_smaller	-				-				-				-				3518	3500	0	0	0	_null_ _null_ ));
 
 /* count */
-DATA(insert ( 2147	n 0 int8inc_any		-				0		20		0	"0" ));
-DATA(insert ( 2803	n 0 int8inc			-				0		20		0	"0" ));
+DATA(insert ( 2147	n 0 int8inc_any		-				-				-				-				0		20		0	0	0	"0" _null_ ));
+DATA(insert ( 2803	n 0 int8inc			-				-				-				-				0		20		0	0	0	"0" _null_ ));
 
 /* var_pop */
-DATA(insert ( 2718	n 0 int8_accum	numeric_var_pop 0	2281	128 _null_ ));
-DATA(insert ( 2719	n 0 int4_accum	numeric_var_pop 0	2281	128 _null_ ));
-DATA(insert ( 2720	n 0 int2_accum	numeric_var_pop 0	2281	128 _null_ ));
-DATA(insert ( 2721	n 0 float4_accum	float8_var_pop 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2722	n 0 float8_accum	float8_var_pop 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2723	n 0 numeric_accum	numeric_var_pop 0	2281	128 _null_ ));
+DATA(insert ( 2718	n 0 int8_accum	numeric_var_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2719	n 0 int4_accum	numeric_var_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2720	n 0 int2_accum	numeric_var_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2721	n 0 float4_accum	float8_var_pop	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2722	n 0 float8_accum	float8_var_pop	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2723	n 0 numeric_accum	numeric_var_pop -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* var_samp */
-DATA(insert ( 2641	n 0 int8_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2642	n 0 int4_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2643	n 0 int2_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2644	n 0 float4_accum	float8_var_samp 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2645	n 0 float8_accum	float8_var_samp 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2646	n 0 numeric_accum	numeric_var_samp 0	2281	128 _null_ ));
+DATA(insert ( 2641	n 0 int8_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2642	n 0 int4_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2643	n 0 int2_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2644	n 0 float4_accum	float8_var_samp -				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2645	n 0 float8_accum	float8_var_samp -				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2646	n 0 numeric_accum	numeric_var_samp -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* variance: historical Postgres syntax for var_samp */
-DATA(insert ( 2148	n 0 int8_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2149	n 0 int4_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2150	n 0 int2_accum	numeric_var_samp	0	2281	128 _null_ ));
-DATA(insert ( 2151	n 0 float4_accum	float8_var_samp 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2152	n 0 float8_accum	float8_var_samp 0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2153	n 0 numeric_accum	numeric_var_samp 0	2281	128 _null_ ));
+DATA(insert ( 2148	n 0 int8_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2149	n 0 int4_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2150	n 0 int2_accum	numeric_var_samp	-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2151	n 0 float4_accum	float8_var_samp -				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2152	n 0 float8_accum	float8_var_samp -				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2153	n 0 numeric_accum	numeric_var_samp -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* stddev_pop */
-DATA(insert ( 2724	n 0 int8_accum	numeric_stddev_pop		0	2281	128 _null_ ));
-DATA(insert ( 2725	n 0 int4_accum	numeric_stddev_pop		0	2281	128 _null_ ));
-DATA(insert ( 2726	n 0 int2_accum	numeric_stddev_pop		0	2281	128 _null_ ));
-DATA(insert ( 2727	n 0 float4_accum	float8_stddev_pop	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2728	n 0 float8_accum	float8_stddev_pop	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2729	n 0 numeric_accum	numeric_stddev_pop	0	2281	128 _null_ ));
+DATA(insert ( 2724	n 0 int8_accum	numeric_stddev_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2725	n 0 int4_accum	numeric_stddev_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2726	n 0 int2_accum	numeric_stddev_pop		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2727	n 0 float4_accum	float8_stddev_pop	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2728	n 0 float8_accum	float8_stddev_pop	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2729	n 0 numeric_accum	numeric_stddev_pop	-				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* stddev_samp */
-DATA(insert ( 2712	n 0 int8_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2713	n 0 int4_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2714	n 0 int2_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2715	n 0 float4_accum	float8_stddev_samp	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2716	n 0 float8_accum	float8_stddev_samp	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2717	n 0 numeric_accum	numeric_stddev_samp 0	2281	128 _null_ ));
+DATA(insert ( 2712	n 0 int8_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2713	n 0 int4_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2714	n 0 int2_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2715	n 0 float4_accum	float8_stddev_samp	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2716	n 0 float8_accum	float8_stddev_samp	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2717	n 0 numeric_accum	numeric_stddev_samp -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* stddev: historical Postgres syntax for stddev_samp */
-DATA(insert ( 2154	n 0 int8_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2155	n 0 int4_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2156	n 0 int2_accum	numeric_stddev_samp		0	2281	128 _null_ ));
-DATA(insert ( 2157	n 0 float4_accum	float8_stddev_samp	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2158	n 0 float8_accum	float8_stddev_samp	0	1022	0	"{0,0,0}" ));
-DATA(insert ( 2159	n 0 numeric_accum	numeric_stddev_samp 0	2281	128 _null_ ));
+DATA(insert ( 2154	n 0 int8_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2155	n 0 int4_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2156	n 0 int2_accum	numeric_stddev_samp		-				-				-				0	2281	128 0	0	_null_ _null_ ));
+DATA(insert ( 2157	n 0 float4_accum	float8_stddev_samp	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2158	n 0 float8_accum	float8_stddev_samp	-				-				-				0	1022	0	0	0	"{0,0,0}" _null_ ));
+DATA(insert ( 2159	n 0 numeric_accum	numeric_stddev_samp -				-				-				0	2281	128 0	0	_null_ _null_ ));
 
 /* SQL2003 binary regression aggregates */
-DATA(insert ( 2818	n 0 int8inc_float8_float8		-				0	20		0	"0" ));
-DATA(insert ( 2819	n 0 float8_regr_accum	float8_regr_sxx			0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2820	n 0 float8_regr_accum	float8_regr_syy			0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2821	n 0 float8_regr_accum	float8_regr_sxy			0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2822	n 0 float8_regr_accum	float8_regr_avgx		0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2823	n 0 float8_regr_accum	float8_regr_avgy		0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2824	n 0 float8_regr_accum	float8_regr_r2			0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2825	n 0 float8_regr_accum	float8_regr_slope		0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2826	n 0 float8_regr_accum	float8_regr_intercept	0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2827	n 0 float8_regr_accum	float8_covar_pop		0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2828	n 0 float8_regr_accum	float8_covar_samp		0	1022	0	"{0,0,0,0,0,0}" ));
-DATA(insert ( 2829	n 0 float8_regr_accum	float8_corr				0	1022	0	"{0,0,0,0,0,0}" ));
+DATA(insert ( 2818	n 0 int8inc_float8_float8	-					-				-				-				0	20		0	0	0	"0" _null_ ));
+DATA(insert ( 2819	n 0 float8_regr_accum	float8_regr_sxx			-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2820	n 0 float8_regr_accum	float8_regr_syy			-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2821	n 0 float8_regr_accum	float8_regr_sxy			-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2822	n 0 float8_regr_accum	float8_regr_avgx		-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2823	n 0 float8_regr_accum	float8_regr_avgy		-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2824	n 0 float8_regr_accum	float8_regr_r2			-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2825	n 0 float8_regr_accum	float8_regr_slope		-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2826	n 0 float8_regr_accum	float8_regr_intercept	-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2827	n 0 float8_regr_accum	float8_covar_pop		-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2828	n 0 float8_regr_accum	float8_covar_samp		-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
+DATA(insert ( 2829	n 0 float8_regr_accum	float8_corr				-				-				-				0	1022	0	0	0	"{0,0,0,0,0,0}" _null_ ));
 
 /* boolean-and and boolean-or */
-DATA(insert ( 2517	n 0 booland_statefunc	-			58	16		0	_null_ ));
-DATA(insert ( 2518	n 0 boolor_statefunc	-			59	16		0	_null_ ));
-DATA(insert ( 2519	n 0 booland_statefunc	-			58	16		0	_null_ ));
+DATA(insert ( 2517	n 0 booland_statefunc	-			-				-				-				58	16		0	0	0	_null_ _null_ ));
+DATA(insert ( 2518	n 0 boolor_statefunc	-			-				-				-				59	16		0	0	0	_null_ _null_ ));
+DATA(insert ( 2519	n 0 booland_statefunc	-			-				-				-				58	16		0	0	0	_null_ _null_ ));
 
 /* bitwise integer */
-DATA(insert ( 2236	n 0 int2and		-					0	21		0	_null_ ));
-DATA(insert ( 2237	n 0 int2or		-					0	21		0	_null_ ));
-DATA(insert ( 2238	n 0 int4and		-					0	23		0	_null_ ));
-DATA(insert ( 2239	n 0 int4or		-					0	23		0	_null_ ));
-DATA(insert ( 2240	n 0 int8and		-					0	20		0	_null_ ));
-DATA(insert ( 2241	n 0 int8or		-					0	20		0	_null_ ));
-DATA(insert ( 2242	n 0 bitand		-					0	1560	0	_null_ ));
-DATA(insert ( 2243	n 0 bitor		-					0	1560	0	_null_ ));
+DATA(insert ( 2236	n 0 int2and		-					-				-				-				0	21		0	0	0	_null_ _null_ ));
+DATA(insert ( 2237	n 0 int2or		-					-				-				-				0	21		0	0	0	_null_ _null_ ));
+DATA(insert ( 2238	n 0 int4and		-					-				-				-				0	23		0	0	0	_null_ _null_ ));
+DATA(insert ( 2239	n 0 int4or		-					-				-				-				0	23		0	0	0	_null_ _null_ ));
+DATA(insert ( 2240	n 0 int8and		-					-				-				-				0	20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2241	n 0 int8or		-					-				-				-				0	20		0	0	0	_null_ _null_ ));
+DATA(insert ( 2242	n 0 bitand		-					-				-				-				0	1560	0	0	0	_null_ _null_ ));
+DATA(insert ( 2243	n 0 bitor		-					-				-				-				0	1560	0	0	0	_null_ _null_ ));
 
 /* xml */
-DATA(insert ( 2901	n 0 xmlconcat2	-					0	142		0	_null_ ));
+DATA(insert ( 2901	n 0 xmlconcat2	-					-				-				-				0	142		0	0	0	_null_ _null_ ));
 
 /* array */
-DATA(insert ( 2335	n 0 array_agg_transfn	array_agg_finalfn	0	2281	0	_null_ ));
+DATA(insert ( 2335	n 0 array_agg_transfn	array_agg_finalfn	-				-				-				0	2281	0	0	0	_null_ _null_ ));
 
 /* text */
-DATA(insert ( 3538	n 0 string_agg_transfn	string_agg_finalfn	0	2281	0	_null_ ));
+DATA(insert ( 3538	n 0 string_agg_transfn	string_agg_finalfn	-				-				-				0	2281	0	0	0	_null_ _null_ ));
 
 /* bytea */
-DATA(insert ( 3545	n 0 bytea_string_agg_transfn	bytea_string_agg_finalfn	0	2281	0	_null_ ));
+DATA(insert ( 3545	n 0 bytea_string_agg_transfn	bytea_string_agg_finalfn	-				-				-				0	2281	0	0	0	_null_ _null_ ));
 
 /* json */
-DATA(insert ( 3175	n 0 json_agg_transfn	json_agg_finalfn	0	2281	0	_null_ ));
-DATA(insert ( 3197	n 0 json_object_agg_transfn	json_object_agg_finalfn	0	2281	0	_null_ ));
+DATA(insert ( 3175	n 0 json_agg_transfn	json_agg_finalfn			-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3197	n 0 json_object_agg_transfn json_object_agg_finalfn -				-				-				0	2281	0	0	0	_null_ _null_ ));
 
 /* ordered-set and hypothetical-set aggregates */
-DATA(insert ( 3972	o 1 ordered_set_transition			percentile_disc_final					0	2281	0	_null_ ));
-DATA(insert ( 3974	o 1 ordered_set_transition			percentile_cont_float8_final			0	2281	0	_null_ ));
-DATA(insert ( 3976	o 1 ordered_set_transition			percentile_cont_interval_final			0	2281	0	_null_ ));
-DATA(insert ( 3978	o 1 ordered_set_transition			percentile_disc_multi_final				0	2281	0	_null_ ));
-DATA(insert ( 3980	o 1 ordered_set_transition			percentile_cont_float8_multi_final		0	2281	0	_null_ ));
-DATA(insert ( 3982	o 1 ordered_set_transition			percentile_cont_interval_multi_final	0	2281	0	_null_ ));
-DATA(insert ( 3984	o 0 ordered_set_transition			mode_final								0	2281	0	_null_ ));
-DATA(insert ( 3986	h 1 ordered_set_transition_multi	rank_final								0	2281	0	_null_ ));
-DATA(insert ( 3988	h 1 ordered_set_transition_multi	percent_rank_final						0	2281	0	_null_ ));
-DATA(insert ( 3990	h 1 ordered_set_transition_multi	cume_dist_final							0	2281	0	_null_ ));
-DATA(insert ( 3992	h 1 ordered_set_transition_multi	dense_rank_final						0	2281	0	_null_ ));
+DATA(insert ( 3972	o 1 ordered_set_transition			percentile_disc_final					-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3974	o 1 ordered_set_transition			percentile_cont_float8_final			-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3976	o 1 ordered_set_transition			percentile_cont_interval_final			-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3978	o 1 ordered_set_transition			percentile_disc_multi_final				-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3980	o 1 ordered_set_transition			percentile_cont_float8_multi_final		-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3982	o 1 ordered_set_transition			percentile_cont_interval_multi_final	-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3984	o 0 ordered_set_transition			mode_final								-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3986	h 1 ordered_set_transition_multi	rank_final								-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3988	h 1 ordered_set_transition_multi	percent_rank_final						-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3990	h 1 ordered_set_transition_multi	cume_dist_final							-				-				-				0	2281	0	0	0	_null_ _null_ ));
+DATA(insert ( 3992	h 1 ordered_set_transition_multi	dense_rank_final						-				-				-				0	2281	0	0	0	_null_ _null_ ));
 
 
 /*
@@ -290,9 +308,15 @@ extern Oid AggregateCreate(const char *aggName,
 				Oid variadicArgType,
 				List *aggtransfnName,
 				List *aggfinalfnName,
+				List *aggmtransfnName,
+				List *aggminvtransfnName,
+				List *aggmfinalfnName,
 				List *aggsortopName,
 				Oid aggTransType,
 				int32 aggTransSpace,
-				const char *agginitval);
+				Oid aggmTransType,
+				int32 aggmTransSpace,
+				const char *agginitval,
+				const char *aggminitval);
 
 #endif   /* PG_AGGREGATE_H */
diff --git a/src/include/nodes/execnodes.h b/src/include/nodes/execnodes.h
index a301a08..6c94e8a 100644
--- a/src/include/nodes/execnodes.h
+++ b/src/include/nodes/execnodes.h
@@ -1762,7 +1762,8 @@ typedef struct WindowAggState
 	Datum		endOffsetValue; /* result of endOffset evaluation */
 
 	MemoryContext partcontext;	/* context for partition-lifespan data */
-	MemoryContext aggcontext;	/* context for each aggregate data */
+	MemoryContext aggcontext;	/* shared context for aggregate working data */
+	MemoryContext curaggcontext;	/* current aggregate's working data */
 	ExprContext *tmpcontext;	/* short-term evaluation context */
 
 	bool		all_first;		/* true if the scan is starting */
diff --git a/src/include/parser/parse_agg.h b/src/include/parser/parse_agg.h
index 8faf991..938d408 100644
--- a/src/include/parser/parse_agg.h
+++ b/src/include/parser/parse_agg.h
@@ -39,8 +39,10 @@ extern void build_aggregate_fnexprs(Oid *agg_input_types,
 						Oid agg_result_type,
 						Oid agg_input_collation,
 						Oid transfn_oid,
+						Oid invtransfn_oid,
 						Oid finalfn_oid,
 						Expr **transfnexpr,
+						Expr **invtransfnexpr,
 						Expr **finalfnexpr);
 
 #endif   /* PARSE_AGG_H */
diff --git a/src/test/regress/expected/create_aggregate.out b/src/test/regress/expected/create_aggregate.out
index ca908d9..a547ca5 100644
--- a/src/test/regress/expected/create_aggregate.out
+++ b/src/test/regress/expected/create_aggregate.out
@@ -90,3 +90,38 @@ alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
  public | test_rank            | bigint           | VARIADIC "any" ORDER BY VARIADIC "any" | 
 (2 rows)
 
+-- moving-aggregate options
+CREATE AGGREGATE sumdouble (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi
+);
+-- invalid: nonstrict inverse with strict forward function
+CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
+$$ SELECT $1 - $2; $$
+LANGUAGE SQL;
+CREATE AGGREGATE invalidsumdouble (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi_n
+);
+ERROR:  strictness of aggregate's forward and inverse transition functions must match
+-- invalid: non-matching result types
+CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
+$$ SELECT CAST($1 - $2 AS INT); $$
+LANGUAGE SQL;
+CREATE AGGREGATE wrongreturntype (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi_int
+);
+ERROR:  return type of inverse transition function float8mi_int is not double precision
diff --git a/src/test/regress/expected/opr_sanity.out b/src/test/regress/expected/opr_sanity.out
index 118f7e4..93ff18d 100644
--- a/src/test/regress/expected/opr_sanity.out
+++ b/src/test/regress/expected/opr_sanity.out
@@ -735,7 +735,7 @@ WHERE aggfnoid = 0 OR aggtransfn = 0 OR
     aggkind NOT IN ('n', 'o', 'h') OR
     aggnumdirectargs < 0 OR
     (aggkind = 'n' AND aggnumdirectargs > 0) OR
-    aggtranstype = 0 OR aggtransspace < 0;
+    aggtranstype = 0 OR aggtransspace < 0 OR aggmtransspace < 0;
  ctid | aggfnoid 
 ------+----------
 (0 rows)
@@ -827,6 +827,126 @@ WHERE a.aggfnoid = p.oid AND
 ----------+---------+-----+---------
 (0 rows)
 
+-- Check for inconsistent specifications of moving-aggregate columns.
+SELECT ctid, aggfnoid::oid
+FROM pg_aggregate as p1
+WHERE aggmtranstype != 0 AND
+    (aggmtransfn = 0 OR aggminvtransfn = 0);
+ ctid | aggfnoid 
+------+----------
+(0 rows)
+
+SELECT ctid, aggfnoid::oid
+FROM pg_aggregate as p1
+WHERE aggmtranstype = 0 AND
+    (aggmtransfn != 0 OR aggminvtransfn != 0 OR aggmfinalfn != 0 OR
+     aggmtransspace != 0 OR aggminitval IS NOT NULL);
+ ctid | aggfnoid 
+------+----------
+(0 rows)
+
+-- If there is no mfinalfn then the output type must be the mtranstype.
+SELECT a.aggfnoid::oid, p.proname
+FROM pg_aggregate as a, pg_proc as p
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn != 0 AND
+    a.aggmfinalfn = 0 AND p.prorettype != a.aggmtranstype;
+ aggfnoid | proname 
+----------+---------
+(0 rows)
+
+-- Cross-check mtransfn (if present) against its entry in pg_proc.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn = ptr.oid AND
+    (ptr.proretset
+     OR NOT (ptr.pronargs =
+             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1
+             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)
+     OR NOT physically_coercible(ptr.prorettype, a.aggmtranstype)
+     OR NOT physically_coercible(a.aggmtranstype, ptr.proargtypes[0])
+     OR (p.pronargs > 0 AND
+         NOT physically_coercible(p.proargtypes[0], ptr.proargtypes[1]))
+     OR (p.pronargs > 1 AND
+         NOT physically_coercible(p.proargtypes[1], ptr.proargtypes[2]))
+     OR (p.pronargs > 2 AND
+         NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
+     -- we could carry the check further, but 3 args is enough for now
+    );
+ aggfnoid | proname | oid | proname 
+----------+---------+-----+---------
+(0 rows)
+
+-- Cross-check minvtransfn (if present) against its entry in pg_proc.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggminvtransfn = ptr.oid AND
+    (ptr.proretset
+     OR NOT (ptr.pronargs =
+             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1
+             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)
+     OR NOT physically_coercible(ptr.prorettype, a.aggmtranstype)
+     OR NOT physically_coercible(a.aggmtranstype, ptr.proargtypes[0])
+     OR (p.pronargs > 0 AND
+         NOT physically_coercible(p.proargtypes[0], ptr.proargtypes[1]))
+     OR (p.pronargs > 1 AND
+         NOT physically_coercible(p.proargtypes[1], ptr.proargtypes[2]))
+     OR (p.pronargs > 2 AND
+         NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
+     -- we could carry the check further, but 3 args is enough for now
+    );
+ aggfnoid | proname | oid | proname 
+----------+---------+-----+---------
+(0 rows)
+
+-- Cross-check mfinalfn (if present) against its entry in pg_proc.
+SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
+WHERE a.aggfnoid = p.oid AND
+    a.aggmfinalfn = pfn.oid AND
+    (pfn.proretset OR
+     NOT binary_coercible(pfn.prorettype, p.prorettype) OR
+     NOT binary_coercible(a.aggmtranstype, pfn.proargtypes[0]) OR
+     CASE WHEN a.aggkind = 'n' THEN pfn.pronargs != 1
+     ELSE pfn.pronargs != p.pronargs + 1
+       OR (p.pronargs > 0 AND
+         NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))
+       OR (p.pronargs > 1 AND
+         NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))
+       OR (p.pronargs > 2 AND
+         NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
+       -- we could carry the check further, but 3 args is enough for now
+     END);
+ aggfnoid | proname | oid | proname 
+----------+---------+-----+---------
+(0 rows)
+
+-- If mtransfn is strict then either minitval should be non-NULL, or
+-- input type should match mtranstype so that the first non-null input
+-- can be assigned as the state value.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn = ptr.oid AND ptr.proisstrict AND
+    a.aggminitval IS NULL AND
+    NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
+ aggfnoid | proname | oid | proname 
+----------+---------+-----+---------
+(0 rows)
+
+-- transfn and mtransfn should have same strictness setting.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname, mptr.oid, mptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr, pg_proc AS mptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggtransfn = ptr.oid AND
+    a.aggmtransfn = mptr.oid AND
+    ptr.proisstrict != mptr.proisstrict;
+ aggfnoid | proname | oid | proname | oid | proname 
+----------+---------+-----+---------+-----+---------
+(0 rows)
+
 -- Cross-check aggsortop (if present) against pg_operator.
 -- We expect to find entries for bool_and, bool_or, every, max, and min.
 SELECT DISTINCT proname, oprname
diff --git a/src/test/regress/expected/window.out b/src/test/regress/expected/window.out
index 0f21fcb..d9cb0ad 100644
--- a/src/test/regress/expected/window.out
+++ b/src/test/regress/expected/window.out
@@ -1071,3 +1071,226 @@ SELECT nth_value_def(ten) OVER (PARTITION BY four), ten, four
              1 |   3 |    3
 (10 rows)
 
+--
+-- Test the basic moving-aggregate machinery
+--
+-- create aggregates that record the series of transform calls (these are
+-- intentionally not true inverses)
+CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '-' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+CREATE AGGREGATE logging_agg_nonstrict (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_nonstrict,
+	mstype = text,
+	msfunc = logging_msfunc_nonstrict,
+	minvfunc = logging_minvfunc_nonstrict
+);
+CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_nonstrict,
+	mstype = text,
+	msfunc = logging_msfunc_nonstrict,
+	minvfunc = logging_minvfunc_nonstrict,
+	initcond = 'I',
+	minitcond = 'MI'
+);
+CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '*' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '+' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '-' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+CREATE AGGREGATE logging_agg_strict (text)
+(
+	stype = text,
+	sfunc = logging_sfunc_strict,
+	mstype = text,
+	msfunc = logging_msfunc_strict,
+	minvfunc = logging_minvfunc_strict
+);
+CREATE AGGREGATE logging_agg_strict_initcond (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_strict,
+	mstype = text,
+	msfunc = logging_msfunc_strict,
+	minvfunc = logging_minvfunc_strict,
+	initcond = 'I',
+	minitcond = 'MI'
+);
+-- test strict and non-strict cases
+SELECT
+	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row,
+	logging_agg_nonstrict(v) over wnd as nstrict,
+	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init,
+	logging_agg_strict(v::text) over wnd as strict,
+	logging_agg_strict_initcond(v) over wnd as strict_init
+FROM (VALUES
+	(1, 1, NULL),
+	(1, 2, 'a'),
+	(1, 3, 'b'),
+	(1, 4, NULL),
+	(1, 5, NULL),
+	(1, 6, 'c'),
+	(2, 1, NULL),
+	(2, 2, 'x'),
+	(3, 1, 'z')
+) AS t(p, i, v)
+WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY p, i;
+   row    |                    nstrict                    |                  nstrict_init                   |  strict   |  strict_init   
+----------+-----------------------------------------------+-------------------------------------------------+-----------+----------------
+ 1,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
+ 1,2:a    | +NULL+'a'                                     | MI+NULL+'a'                                     | a         | MI+'a'
+ 1,3:b    | +NULL+'a'-NULL+'b'                            | MI+NULL+'a'-NULL+'b'                            | a+'b'     | MI+'a'+'b'
+ 1,4:NULL | +NULL+'a'-NULL+'b'-'a'+NULL                   | MI+NULL+'a'-NULL+'b'-'a'+NULL                   | a+'b'-'a' | MI+'a'+'b'-'a'
+ 1,5:NULL | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL          |           | MI
+ 1,6:c    | +NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | MI+NULL+'a'-NULL+'b'-'a'+NULL-'b'+NULL-NULL+'c' | c         | MI+'c'
+ 2,1:NULL | +NULL                                         | MI+NULL                                         |           | MI
+ 2,2:x    | +NULL+'x'                                     | MI+NULL+'x'                                     | x         | MI+'x'
+ 3,1:z    | +'z'                                          | MI+'z'                                          | z         | MI+'z'
+(9 rows)
+
+-- and again, but with filter
+SELECT
+	p::text || ',' || i::text || ':' ||
+		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row,
+	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt,
+	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt,
+	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt,
+	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filt
+FROM (VALUES
+	(1, 1, true,  NULL),
+	(1, 2, false, 'a'),
+	(1, 3, true,  'b'),
+	(1, 4, false, NULL),
+	(1, 5, false, NULL),
+	(1, 6, false, 'c'),
+	(2, 1, false, NULL),
+	(2, 2, true,  'x'),
+	(3, 1, true,  'z')
+) AS t(p, i, f, v)
+WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY p, i;
+   row    | nstrict_filt | nstrict_init_filt | strict_filt | strict_init_filt 
+----------+--------------+-------------------+-------------+------------------
+ 1,1:NULL | +NULL        | MI+NULL           |             | MI
+ 1,2:-    | +NULL        | MI+NULL           |             | MI
+ 1,3:b    | +'b'         | MI+'b'            | b           | MI+'b'
+ 1,4:-    | +'b'         | MI+'b'            | b           | MI+'b'
+ 1,5:-    |              | MI                |             | MI
+ 1,6:-    |              | MI                |             | MI
+ 2,1:-    |              | MI                |             | MI
+ 2,2:x    | +'x'         | MI+'x'            | x           | MI+'x'
+ 3,1:z    | +'z'         | MI+'z'            | z           | MI+'z'
+(9 rows)
+
+-- test that volatile arguments disable moving-aggregate mode
+SELECT
+	i::text || ':' || COALESCE(v::text, 'NULL') as row,
+	logging_agg_strict(v::text)
+		over wnd as inverse,
+	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END)
+		over wnd as noinverse
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY i;
+ row |    inverse    | noinverse 
+-----+---------------+-----------
+ 1:a | a             | a
+ 2:b | a+'b'         | a*'b'
+ 3:c | a+'b'-'a'+'c' | b*'c'
+(3 rows)
+
+SELECT
+	i::text || ':' || COALESCE(v::text, 'NULL') as row,
+	logging_agg_strict(v::text) filter(where true)
+		over wnd as inverse,
+	logging_agg_strict(v::text) filter(where random() >= 0)
+		over wnd as noinverse
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY i;
+ row |    inverse    | noinverse 
+-----+---------------+-----------
+ 1:a | a             | a
+ 2:b | a+'b'         | a*'b'
+ 3:c | a+'b'-'a'+'c' | b*'c'
+(3 rows)
+
+-- test that non-overlapping windows don't use inverse transitions
+SELECT
+	logging_agg_strict(v::text) OVER wnd
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
+ORDER BY i;
+ logging_agg_strict 
+--------------------
+ a
+ b
+ c
+(3 rows)
+
+-- test that returning NULL from the inverse transition functions
+-- restarts the aggregation from scratch. The second aggregate is supposed
+-- to test cases where only some aggregates restart, the third one checks
+-- that one aggregate restarting doesn't cause others to restart.
+CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS
+$$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$
+LANGUAGE SQL STRICT;
+CREATE AGGREGATE sum_int_randomrestart (int4)
+(
+	stype = int4,
+	sfunc = int4pl,
+	mstype = int4,
+	msfunc = int4pl,
+	minvfunc = sum_int_randrestart_minvfunc
+);
+WITH
+vs AS (
+	SELECT i, (random() * 100)::int4 AS v
+	FROM generate_series(1, 100) AS i
+),
+sum_following AS (
+	SELECT i, SUM(v) OVER
+		(ORDER BY i DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s
+	FROM vs
+)
+SELECT DISTINCT
+	sum_following.s = sum_int_randomrestart(v) OVER fwd AS eq1,
+	-sum_following.s = sum_int_randomrestart(-v) OVER fwd AS eq2,
+	100*3+(vs.i-1)*3 = length(logging_agg_nonstrict(''::text) OVER fwd) AS eq3
+FROM vs
+JOIN sum_following ON sum_following.i = vs.i
+WINDOW fwd AS (
+	ORDER BY vs.i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
+);
+ eq1 | eq2 | eq3 
+-----+-----+-----
+ t   | t   | t
+(1 row)
+
diff --git a/src/test/regress/sql/create_aggregate.sql b/src/test/regress/sql/create_aggregate.sql
index c76882a..2b502ac 100644
--- a/src/test/regress/sql/create_aggregate.sql
+++ b/src/test/regress/sql/create_aggregate.sql
@@ -101,3 +101,44 @@ alter aggregate my_rank(VARIADIC "any" ORDER BY VARIADIC "any")
   rename to test_rank;
 
 \da test_*
+
+-- moving-aggregate options
+
+CREATE AGGREGATE sumdouble (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi
+);
+
+-- invalid: nonstrict inverse with strict forward function
+
+CREATE FUNCTION float8mi_n(float8, float8) RETURNS float8 AS
+$$ SELECT $1 - $2; $$
+LANGUAGE SQL;
+
+CREATE AGGREGATE invalidsumdouble (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi_n
+);
+
+-- invalid: non-matching result types
+
+CREATE FUNCTION float8mi_int(float8, float8) RETURNS int AS
+$$ SELECT CAST($1 - $2 AS INT); $$
+LANGUAGE SQL;
+
+CREATE AGGREGATE wrongreturntype (float8)
+(
+    stype = float8,
+    sfunc = float8pl,
+    mstype = float8,
+    msfunc = float8pl,
+    minvfunc = float8mi_int
+);
diff --git a/src/test/regress/sql/opr_sanity.sql b/src/test/regress/sql/opr_sanity.sql
index ad37178..22998a5 100644
--- a/src/test/regress/sql/opr_sanity.sql
+++ b/src/test/regress/sql/opr_sanity.sql
@@ -592,7 +592,7 @@ WHERE aggfnoid = 0 OR aggtransfn = 0 OR
     aggkind NOT IN ('n', 'o', 'h') OR
     aggnumdirectargs < 0 OR
     (aggkind = 'n' AND aggnumdirectargs > 0) OR
-    aggtranstype = 0 OR aggtransspace < 0;
+    aggtranstype = 0 OR aggtransspace < 0 OR aggmtransspace < 0;
 
 -- Make sure the matching pg_proc entry is sensible, too.
 
@@ -668,6 +668,107 @@ WHERE a.aggfnoid = p.oid AND
     a.agginitval IS NULL AND
     NOT binary_coercible(p.proargtypes[0], a.aggtranstype);
 
+-- Check for inconsistent specifications of moving-aggregate columns.
+
+SELECT ctid, aggfnoid::oid
+FROM pg_aggregate as p1
+WHERE aggmtranstype != 0 AND
+    (aggmtransfn = 0 OR aggminvtransfn = 0);
+
+SELECT ctid, aggfnoid::oid
+FROM pg_aggregate as p1
+WHERE aggmtranstype = 0 AND
+    (aggmtransfn != 0 OR aggminvtransfn != 0 OR aggmfinalfn != 0 OR
+     aggmtransspace != 0 OR aggminitval IS NOT NULL);
+
+-- If there is no mfinalfn then the output type must be the mtranstype.
+
+SELECT a.aggfnoid::oid, p.proname
+FROM pg_aggregate as a, pg_proc as p
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn != 0 AND
+    a.aggmfinalfn = 0 AND p.prorettype != a.aggmtranstype;
+
+-- Cross-check mtransfn (if present) against its entry in pg_proc.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn = ptr.oid AND
+    (ptr.proretset
+     OR NOT (ptr.pronargs =
+             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1
+             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)
+     OR NOT physically_coercible(ptr.prorettype, a.aggmtranstype)
+     OR NOT physically_coercible(a.aggmtranstype, ptr.proargtypes[0])
+     OR (p.pronargs > 0 AND
+         NOT physically_coercible(p.proargtypes[0], ptr.proargtypes[1]))
+     OR (p.pronargs > 1 AND
+         NOT physically_coercible(p.proargtypes[1], ptr.proargtypes[2]))
+     OR (p.pronargs > 2 AND
+         NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
+     -- we could carry the check further, but 3 args is enough for now
+    );
+
+-- Cross-check minvtransfn (if present) against its entry in pg_proc.
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggminvtransfn = ptr.oid AND
+    (ptr.proretset
+     OR NOT (ptr.pronargs =
+             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1
+             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)
+     OR NOT physically_coercible(ptr.prorettype, a.aggmtranstype)
+     OR NOT physically_coercible(a.aggmtranstype, ptr.proargtypes[0])
+     OR (p.pronargs > 0 AND
+         NOT physically_coercible(p.proargtypes[0], ptr.proargtypes[1]))
+     OR (p.pronargs > 1 AND
+         NOT physically_coercible(p.proargtypes[1], ptr.proargtypes[2]))
+     OR (p.pronargs > 2 AND
+         NOT physically_coercible(p.proargtypes[2], ptr.proargtypes[3]))
+     -- we could carry the check further, but 3 args is enough for now
+    );
+
+-- Cross-check mfinalfn (if present) against its entry in pg_proc.
+
+SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
+WHERE a.aggfnoid = p.oid AND
+    a.aggmfinalfn = pfn.oid AND
+    (pfn.proretset OR
+     NOT binary_coercible(pfn.prorettype, p.prorettype) OR
+     NOT binary_coercible(a.aggmtranstype, pfn.proargtypes[0]) OR
+     CASE WHEN a.aggkind = 'n' THEN pfn.pronargs != 1
+     ELSE pfn.pronargs != p.pronargs + 1
+       OR (p.pronargs > 0 AND
+         NOT binary_coercible(p.proargtypes[0], pfn.proargtypes[1]))
+       OR (p.pronargs > 1 AND
+         NOT binary_coercible(p.proargtypes[1], pfn.proargtypes[2]))
+       OR (p.pronargs > 2 AND
+         NOT binary_coercible(p.proargtypes[2], pfn.proargtypes[3]))
+       -- we could carry the check further, but 3 args is enough for now
+     END);
+
+-- If mtransfn is strict then either minitval should be non-NULL, or
+-- input type should match mtranstype so that the first non-null input
+-- can be assigned as the state value.
+
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggmtransfn = ptr.oid AND ptr.proisstrict AND
+    a.aggminitval IS NULL AND
+    NOT binary_coercible(p.proargtypes[0], a.aggmtranstype);
+
+-- transfn and mtransfn should have same strictness setting.
+
+SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname, mptr.oid, mptr.proname
+FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr, pg_proc AS mptr
+WHERE a.aggfnoid = p.oid AND
+    a.aggtransfn = ptr.oid AND
+    a.aggmtransfn = mptr.oid AND
+    ptr.proisstrict != mptr.proisstrict;
+
 -- Cross-check aggsortop (if present) against pg_operator.
 -- We expect to find entries for bool_and, bool_or, every, max, and min.
 
diff --git a/src/test/regress/sql/window.sql b/src/test/regress/sql/window.sql
index 7297e62..5bae12b 100644
--- a/src/test/regress/sql/window.sql
+++ b/src/test/regress/sql/window.sql
@@ -284,3 +284,195 @@ SELECT nth_value_def(n := 2, val := ten) OVER (PARTITION BY four), ten, four
 
 SELECT nth_value_def(ten) OVER (PARTITION BY four), ten, four
   FROM (SELECT * FROM tenk1 WHERE unique2 < 10 ORDER BY four, ten) s;
+
+--
+-- Test the basic moving-aggregate machinery
+--
+
+-- create aggregates that record the series of transform calls (these are
+-- intentionally not true inverses)
+
+CREATE FUNCTION logging_sfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT COALESCE($1, '') || '*' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+
+CREATE FUNCTION logging_msfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT COALESCE($1, '') || '+' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+
+CREATE FUNCTION logging_minvfunc_nonstrict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '-' || quote_nullable($2) $$
+LANGUAGE SQL IMMUTABLE;
+
+CREATE AGGREGATE logging_agg_nonstrict (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_nonstrict,
+	mstype = text,
+	msfunc = logging_msfunc_nonstrict,
+	minvfunc = logging_minvfunc_nonstrict
+);
+
+CREATE AGGREGATE logging_agg_nonstrict_initcond (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_nonstrict,
+	mstype = text,
+	msfunc = logging_msfunc_nonstrict,
+	minvfunc = logging_minvfunc_nonstrict,
+	initcond = 'I',
+	minitcond = 'MI'
+);
+
+CREATE FUNCTION logging_sfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '*' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+
+CREATE FUNCTION logging_msfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '+' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+
+CREATE FUNCTION logging_minvfunc_strict(text, anyelement) RETURNS text AS
+$$ SELECT $1 || '-' || quote_nullable($2) $$
+LANGUAGE SQL STRICT IMMUTABLE;
+
+CREATE AGGREGATE logging_agg_strict (text)
+(
+	stype = text,
+	sfunc = logging_sfunc_strict,
+	mstype = text,
+	msfunc = logging_msfunc_strict,
+	minvfunc = logging_minvfunc_strict
+);
+
+CREATE AGGREGATE logging_agg_strict_initcond (anyelement)
+(
+	stype = text,
+	sfunc = logging_sfunc_strict,
+	mstype = text,
+	msfunc = logging_msfunc_strict,
+	minvfunc = logging_minvfunc_strict,
+	initcond = 'I',
+	minitcond = 'MI'
+);
+
+-- test strict and non-strict cases
+SELECT
+	p::text || ',' || i::text || ':' || COALESCE(v::text, 'NULL') AS row,
+	logging_agg_nonstrict(v) over wnd as nstrict,
+	logging_agg_nonstrict_initcond(v) over wnd as nstrict_init,
+	logging_agg_strict(v::text) over wnd as strict,
+	logging_agg_strict_initcond(v) over wnd as strict_init
+FROM (VALUES
+	(1, 1, NULL),
+	(1, 2, 'a'),
+	(1, 3, 'b'),
+	(1, 4, NULL),
+	(1, 5, NULL),
+	(1, 6, 'c'),
+	(2, 1, NULL),
+	(2, 2, 'x'),
+	(3, 1, 'z')
+) AS t(p, i, v)
+WINDOW wnd AS (PARTITION BY P ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY p, i;
+
+-- and again, but with filter
+SELECT
+	p::text || ',' || i::text || ':' ||
+		CASE WHEN f THEN COALESCE(v::text, 'NULL') ELSE '-' END as row,
+	logging_agg_nonstrict(v) filter(where f) over wnd as nstrict_filt,
+	logging_agg_nonstrict_initcond(v) filter(where f) over wnd as nstrict_init_filt,
+	logging_agg_strict(v::text) filter(where f) over wnd as strict_filt,
+	logging_agg_strict_initcond(v) filter(where f) over wnd as strict_init_filt
+FROM (VALUES
+	(1, 1, true,  NULL),
+	(1, 2, false, 'a'),
+	(1, 3, true,  'b'),
+	(1, 4, false, NULL),
+	(1, 5, false, NULL),
+	(1, 6, false, 'c'),
+	(2, 1, false, NULL),
+	(2, 2, true,  'x'),
+	(3, 1, true,  'z')
+) AS t(p, i, f, v)
+WINDOW wnd AS (PARTITION BY p ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY p, i;
+
+-- test that volatile arguments disable moving-aggregate mode
+SELECT
+	i::text || ':' || COALESCE(v::text, 'NULL') as row,
+	logging_agg_strict(v::text)
+		over wnd as inverse,
+	logging_agg_strict(v::text || CASE WHEN random() < 0 then '?' ELSE '' END)
+		over wnd as noinverse
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY i;
+
+SELECT
+	i::text || ':' || COALESCE(v::text, 'NULL') as row,
+	logging_agg_strict(v::text) filter(where true)
+		over wnd as inverse,
+	logging_agg_strict(v::text) filter(where random() >= 0)
+		over wnd as noinverse
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
+ORDER BY i;
+
+-- test that non-overlapping windows don't use inverse transitions
+SELECT
+	logging_agg_strict(v::text) OVER wnd
+FROM (VALUES
+	(1, 'a'),
+	(2, 'b'),
+	(3, 'c')
+) AS t(i, v)
+WINDOW wnd AS (ORDER BY i ROWS BETWEEN CURRENT ROW AND CURRENT ROW)
+ORDER BY i;
+
+-- test that returning NULL from the inverse transition functions
+-- restarts the aggregation from scratch. The second aggregate is supposed
+-- to test cases where only some aggregates restart, the third one checks
+-- that one aggregate restarting doesn't cause others to restart.
+
+CREATE FUNCTION sum_int_randrestart_minvfunc(int4, int4) RETURNS int4 AS
+$$ SELECT CASE WHEN random() < 0.2 THEN NULL ELSE $1 - $2 END $$
+LANGUAGE SQL STRICT;
+
+CREATE AGGREGATE sum_int_randomrestart (int4)
+(
+	stype = int4,
+	sfunc = int4pl,
+	mstype = int4,
+	msfunc = int4pl,
+	minvfunc = sum_int_randrestart_minvfunc
+);
+
+WITH
+vs AS (
+	SELECT i, (random() * 100)::int4 AS v
+	FROM generate_series(1, 100) AS i
+),
+sum_following AS (
+	SELECT i, SUM(v) OVER
+		(ORDER BY i DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS s
+	FROM vs
+)
+SELECT DISTINCT
+	sum_following.s = sum_int_randomrestart(v) OVER fwd AS eq1,
+	-sum_following.s = sum_int_randomrestart(-v) OVER fwd AS eq2,
+	100*3+(vs.i-1)*3 = length(logging_agg_nonstrict(''::text) OVER fwd) AS eq3
+FROM vs
+JOIN sum_following ON sum_following.i = vs.i
+WINDOW fwd AS (
+	ORDER BY vs.i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
+);
-- 
1.9.1


From 5dce96d3a23667c956a6619e805ea7718ddcf143 Mon Sep 17 00:00:00 2001
From: JavierRivas <javieralejandro.rivas@epfl.ch>
Date: Tue, 10 Jun 2014 08:57:17 +0200
Subject: [PATCH 2/3] project vardinaity injection

---
 .gitignore                              |    7 +
 contrib/auto_explain/auto_explain.c     |  305 ++--
 src/backend/optimizer/path/costsize.c   | 2280 +++++++++++-------------
 src/backend/optimizer/path/indxpath.c   |   11 +-
 src/backend/optimizer/path/joinpath.c   |    8 +-
 src/backend/optimizer/path/joinrels.c   |    1 +
 src/backend/optimizer/plan/createplan.c | 2967 +++++++++++++------------------
 src/backend/optimizer/plan/planmain.c   |    2 +-
 src/backend/optimizer/plan/planner.c    |    9 +-
 src/backend/optimizer/util/pathnode.c   |   71 +
 src/backend/optimizer/util/plancat.c    |    2 +-
 src/backend/optimizer/util/relnode.c    |  469 +++--
 src/backend/utils/misc/guc.c            |   18 +
 src/include/nodes/plannodes.h           |    2 +-
 src/include/nodes/relation.h            |  136 +-
 src/include/optimizer/cost.h            |    3 +
 src/include/optimizer/pathnode.h        |    2 +
 17 files changed, 2861 insertions(+), 3432 deletions(-)

diff --git a/.gitignore b/.gitignore
index 681af08..c2b0123 100644
--- a/.gitignore
+++ b/.gitignore
@@ -34,3 +34,10 @@ lib*.pc
 /pgsql.sln.cache
 /Debug/
 /Release/
+.cproject
+.project
+.settings/
+0001-Create-infrastructure-for-moving-aggregate-optimizat.patch
+0001-test.patch
+fix_empty_poster.patch
+
diff --git a/contrib/auto_explain/auto_explain.c b/contrib/auto_explain/auto_explain.c
index c8ca7c4..0562ee7 100644
--- a/contrib/auto_explain/auto_explain.c
+++ b/contrib/auto_explain/auto_explain.c
@@ -11,35 +11,33 @@
  *-------------------------------------------------------------------------
  */
 #include "postgres.h"
-
 #include <limits.h>
-
+#include <stdio.h>
+#include "optimizer/cost.h"
 #include "commands/explain.h"
 #include "executor/instrument.h"
 #include "utils/guc.h"
-
+#include "optimizer/cost.h"
 PG_MODULE_MAGIC;
 
 /* GUC variables */
-static int	auto_explain_log_min_duration = -1; /* msec or -1 */
+static int auto_explain_log_min_duration = 0; /* msec or -1 */
 static bool auto_explain_log_analyze = false;
+static bool auto_explain_log_memo = false;
 static bool auto_explain_log_verbose = false;
 static bool auto_explain_log_buffers = false;
 static bool auto_explain_log_triggers = false;
 static bool auto_explain_log_timing = false;
-static int	auto_explain_log_format = EXPLAIN_FORMAT_TEXT;
+static int auto_explain_log_format = EXPLAIN_FORMAT_TEXT;
 static bool auto_explain_log_nested_statements = false;
 
-static const struct config_enum_entry format_options[] = {
-	{"text", EXPLAIN_FORMAT_TEXT, false},
-	{"xml", EXPLAIN_FORMAT_XML, false},
-	{"json", EXPLAIN_FORMAT_JSON, false},
-	{"yaml", EXPLAIN_FORMAT_YAML, false},
-	{NULL, 0, false}
-};
+static const struct config_enum_entry format_options[] = { { "text",
+		EXPLAIN_FORMAT_TEXT, false }, { "xml", EXPLAIN_FORMAT_XML, false }, {
+		"json", EXPLAIN_FORMAT_JSON, false }, { "yaml", EXPLAIN_FORMAT_YAML,
+		false }, { NULL, 0, false } };
 
 /* Current nesting depth of ExecutorRun calls */
-static int	nesting_level = 0;
+static int nesting_level = 0;
 
 /* Saved hook values in case of unload */
 static ExecutorStart_hook_type prev_ExecutorStart = NULL;
@@ -51,157 +49,99 @@ static ExecutorEnd_hook_type prev_ExecutorEnd = NULL;
 	(auto_explain_log_min_duration >= 0 && \
 	 (nesting_level == 0 || auto_explain_log_nested_statements))
 
-void		_PG_init(void);
-void		_PG_fini(void);
+void _PG_init(void);
+void _PG_fini(void);
 
 static void explain_ExecutorStart(QueryDesc *queryDesc, int eflags);
-static void explain_ExecutorRun(QueryDesc *queryDesc,
-					ScanDirection direction,
-					long count);
+static void explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction,
+		long count);
 static void explain_ExecutorFinish(QueryDesc *queryDesc);
 static void explain_ExecutorEnd(QueryDesc *queryDesc);
 
-
 /*
  * Module load callback
  */
-void
-_PG_init(void)
-{
+void _PG_init(void) {
 	/* Define custom GUC variables. */
 	DefineCustomIntVariable("auto_explain.log_min_duration",
-		 "Sets the minimum execution time above which plans will be logged.",
-						 "Zero prints all plans. -1 turns this feature off.",
-							&auto_explain_log_min_duration,
-							-1,
-							-1, INT_MAX / 1000,
-							PGC_SUSET,
-							GUC_UNIT_MS,
-							NULL,
-							NULL,
-							NULL);
+			"Sets the minimum execution time above which plans will be logged.",
+			"Zero prints all plans. -1 turns this feature off.",
+			&auto_explain_log_min_duration, -1, -1, INT_MAX / 1000, PGC_SUSET,
+			GUC_UNIT_MS, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_analyze",
-							 "Use EXPLAIN ANALYZE for plan logging.",
-							 NULL,
-							 &auto_explain_log_analyze,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Use EXPLAIN ANALYZE for plan logging.", NULL,
+			&auto_explain_log_analyze, false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_verbose",
-							 "Use EXPLAIN VERBOSE for plan logging.",
-							 NULL,
-							 &auto_explain_log_verbose,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
-
-	DefineCustomBoolVariable("auto_explain.log_buffers",
-							 "Log buffers usage.",
-							 NULL,
-							 &auto_explain_log_buffers,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Use EXPLAIN VERBOSE for plan logging.", NULL,
+			&auto_explain_log_verbose, false, PGC_SUSET, 0, NULL, NULL, NULL);
+	DefineCustomBoolVariable("auto_explain.log_memo",
+			"Use EXPLAIN VERBOSE for plan logging.", NULL,
+			&auto_explain_log_memo, false, PGC_SUSET, 0, NULL, NULL, NULL);
+
+	DefineCustomBoolVariable("auto_explain.log_buffers", "Log buffers usage.",
+			NULL, &auto_explain_log_buffers, false, PGC_SUSET, 0, NULL, NULL,
+			NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_triggers",
-							 "Include trigger statistics in plans.",
-							 "This has no effect unless log_analyze is also set.",
-							 &auto_explain_log_triggers,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Include trigger statistics in plans.",
+			"This has no effect unless log_analyze is also set.",
+			&auto_explain_log_triggers, false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomEnumVariable("auto_explain.log_format",
-							 "EXPLAIN format to be used for plan logging.",
-							 NULL,
-							 &auto_explain_log_format,
-							 EXPLAIN_FORMAT_TEXT,
-							 format_options,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"EXPLAIN format to be used for plan logging.", NULL,
+			&auto_explain_log_format, EXPLAIN_FORMAT_TEXT, format_options,
+			PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_nested_statements",
-							 "Log nested statements.",
-							 NULL,
-							 &auto_explain_log_nested_statements,
-							 false,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Log nested statements.", NULL, &auto_explain_log_nested_statements,
+			false, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	DefineCustomBoolVariable("auto_explain.log_timing",
-							 "Collect timing data, not just row counts.",
-							 NULL,
-							 &auto_explain_log_timing,
-							 true,
-							 PGC_SUSET,
-							 0,
-							 NULL,
-							 NULL,
-							 NULL);
+			"Collect timing data, not just row counts.", NULL,
+			&auto_explain_log_timing, true, PGC_SUSET, 0, NULL, NULL, NULL);
 
 	EmitWarningsOnPlaceholders("auto_explain");
-
-	/* Install hooks. */
-	prev_ExecutorStart = ExecutorStart_hook;
-	ExecutorStart_hook = explain_ExecutorStart;
-	prev_ExecutorRun = ExecutorRun_hook;
-	ExecutorRun_hook = explain_ExecutorRun;
-	prev_ExecutorFinish = ExecutorFinish_hook;
-	ExecutorFinish_hook = explain_ExecutorFinish;
-	prev_ExecutorEnd = ExecutorEnd_hook;
-	ExecutorEnd_hook = explain_ExecutorEnd;
+	if (auto_explain_enabled()) {
+		/* Install hooks. */
+		prev_ExecutorStart = ExecutorStart_hook;
+		ExecutorStart_hook = explain_ExecutorStart;
+		prev_ExecutorRun = ExecutorRun_hook;
+		ExecutorRun_hook = explain_ExecutorRun;
+		prev_ExecutorFinish = ExecutorFinish_hook;
+		ExecutorFinish_hook = explain_ExecutorFinish;
+		prev_ExecutorEnd = ExecutorEnd_hook;
+		ExecutorEnd_hook = explain_ExecutorEnd;
+	}
 }
 
 /*
  * Module unload callback
  */
-void
-_PG_fini(void)
-{
-	/* Uninstall hooks. */
-	ExecutorStart_hook = prev_ExecutorStart;
-	ExecutorRun_hook = prev_ExecutorRun;
-	ExecutorFinish_hook = prev_ExecutorFinish;
-	ExecutorEnd_hook = prev_ExecutorEnd;
+void _PG_fini(void) {
+	if (auto_explain_enabled()) {
+		/* Uninstall hooks. */
+		ExecutorStart_hook = prev_ExecutorStart;
+		ExecutorRun_hook = prev_ExecutorRun;
+		ExecutorFinish_hook = prev_ExecutorFinish;
+		ExecutorEnd_hook = prev_ExecutorEnd;
+	}
 }
 
 /*
  * ExecutorStart hook: start up logging if needed
  */
-static void
-explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
-{
-	if (auto_explain_enabled())
-	{
+static void explain_ExecutorStart(QueryDesc *queryDesc, int eflags) {
+	if (auto_explain_enabled()) {
 		/* Enable per-node instrumentation iff log_analyze is required. */
-		if (auto_explain_log_analyze && (eflags & EXEC_FLAG_EXPLAIN_ONLY) == 0)
-		{
+		if (auto_explain_log_analyze
+				&& (eflags & EXEC_FLAG_EXPLAIN_ONLY) == 0) {
 			if (auto_explain_log_timing)
 				queryDesc->instrument_options |= INSTRUMENT_TIMER;
 			else
 				queryDesc->instrument_options |= INSTRUMENT_ROWS;
 
-
 			if (auto_explain_log_buffers)
 				queryDesc->instrument_options |= INSTRUMENT_BUFFERS;
 		}
@@ -212,15 +152,13 @@ explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
 	else
 		standard_ExecutorStart(queryDesc, eflags);
 
-	if (auto_explain_enabled())
-	{
+	if (auto_explain_enabled()) {
 		/*
 		 * Set up to track total elapsed time in ExecutorRun.  Make sure the
 		 * space is allocated in the per-query context so it will go away at
 		 * ExecutorEnd.
 		 */
-		if (queryDesc->totaltime == NULL)
-		{
+		if (queryDesc->totaltime == NULL) {
 			MemoryContext oldcxt;
 
 			oldcxt = MemoryContextSwitchTo(queryDesc->estate->es_query_cxt);
@@ -233,58 +171,51 @@ explain_ExecutorStart(QueryDesc *queryDesc, int eflags)
 /*
  * ExecutorRun hook: all we need do is track nesting depth
  */
-static void
-explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction, long count)
-{
+static void explain_ExecutorRun(QueryDesc *queryDesc, ScanDirection direction,
+		long count) {
 	nesting_level++;
-	PG_TRY();
-	{
-		if (prev_ExecutorRun)
-			prev_ExecutorRun(queryDesc, direction, count);
-		else
-			standard_ExecutorRun(queryDesc, direction, count);
-		nesting_level--;
-	}
-	PG_CATCH();
-	{
-		nesting_level--;
-		PG_RE_THROW();
-	}
-	PG_END_TRY();
+	PG_TRY()	;
+				{
+					if (prev_ExecutorRun)
+						prev_ExecutorRun(queryDesc, direction, count);
+					else
+						standard_ExecutorRun(queryDesc, direction, count);
+					nesting_level--;
+				}PG_CATCH();
+				{
+					nesting_level--;
+					PG_RE_THROW();
+				}PG_END_TRY();
 }
 
 /*
  * ExecutorFinish hook: all we need do is track nesting depth
  */
-static void
-explain_ExecutorFinish(QueryDesc *queryDesc)
-{
+static void explain_ExecutorFinish(QueryDesc *queryDesc) {
 	nesting_level++;
-	PG_TRY();
-	{
-		if (prev_ExecutorFinish)
-			prev_ExecutorFinish(queryDesc);
-		else
-			standard_ExecutorFinish(queryDesc);
-		nesting_level--;
-	}
-	PG_CATCH();
-	{
-		nesting_level--;
-		PG_RE_THROW();
-	}
-	PG_END_TRY();
+	PG_TRY()	;
+				{
+					if (prev_ExecutorFinish)
+						prev_ExecutorFinish(queryDesc);
+					else
+						standard_ExecutorFinish(queryDesc);
+					nesting_level--;
+				}PG_CATCH();
+				{
+					nesting_level--;
+					PG_RE_THROW();
+				}PG_END_TRY();
 }
 
 /*
  * ExecutorEnd hook: log results if needed
  */
-static void
-explain_ExecutorEnd(QueryDesc *queryDesc)
-{
-	if (queryDesc->totaltime && auto_explain_enabled())
-	{
-		double		msec;
+static void explain_ExecutorEnd(QueryDesc *queryDesc) {
+	FILE *file = fopen("memoTxt.xml", "wb");
+	FILE *file_d = fopen("durations.txt", "a+");
+
+	if (queryDesc->totaltime && auto_explain_enabled()) {
+		double msec;
 
 		/*
 		 * Make sure stats accumulation is done.  (Note: it's okay if several
@@ -294,30 +225,30 @@ explain_ExecutorEnd(QueryDesc *queryDesc)
 
 		/* Log plan if duration is exceeded. */
 		msec = queryDesc->totaltime->total * 1000.0;
-		if (msec >= auto_explain_log_min_duration)
-		{
+		if (msec >= auto_explain_log_min_duration) {
 			ExplainState es;
 
 			ExplainInitState(&es);
-			es.analyze = (queryDesc->instrument_options && auto_explain_log_analyze);
+			es.analyze = (queryDesc->instrument_options
+					&& auto_explain_log_analyze);
 			es.verbose = auto_explain_log_verbose;
 			es.buffers = (es.analyze && auto_explain_log_buffers);
 			es.format = auto_explain_log_format;
 
 			ExplainBeginOutput(&es);
-			ExplainQueryText(&es, queryDesc);
+			
 			ExplainPrintPlan(&es, queryDesc);
-			if (es.analyze && auto_explain_log_triggers)
-				ExplainPrintTriggers(&es, queryDesc);
-			ExplainEndOutput(&es);
 
+			
+			ExplainEndOutput(&es);
+			// update he time to be print
+			msec = queryDesc->totaltime->total * 1000.0;
 			/* Remove last line break */
 			if (es.str->len > 0 && es.str->data[es.str->len - 1] == '\n')
 				es.str->data[--es.str->len] = '\0';
 
 			/* Fix JSON to output an object */
-			if (auto_explain_log_format == EXPLAIN_FORMAT_JSON)
-			{
+			if (auto_explain_log_format == EXPLAIN_FORMAT_JSON) {
 				es.str->data[0] = '{';
 				es.str->data[es.str->len - 1] = '}';
 			}
@@ -328,11 +259,23 @@ explain_ExecutorEnd(QueryDesc *queryDesc)
 			 * reported.  This isn't ideal but trying to do it here would
 			 * often result in duplication.
 			 */
-			ereport(LOG,
-					(errmsg("duration: %.3f ms  plan:\n%s",
-							msec, es.str->data),
-					 errhidestmt(true)));
 
+			else {
+				ereport(LOG,
+						(errmsg("duration: %.3f ms  plan:\n%s", msec, es.str->data), errhidestmt(true)));
+				fprintf(file_d, "%.3f", msec);
+				if (enable_memo)
+					fprintf(file_d, "\n");
+				else
+					fprintf(file_d, "	");
+				fwrite( es.str->data, 1,strlen(es.str->data),file );
+				fclose(file);
+				fclose(file_d);
+				if(auto_explain_log_memo){
+				system("java -jar explain.jar memoTxt.xml memoTxt");
+}
+
+			}
 			pfree(es.str->data);
 		}
 	}
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index 326794a..a8369fc 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -94,67 +94,57 @@
 #include "utils/spccache.h"
 #include "utils/tuplesort.h"
 
-
 #define LOG2(x)  (log(x) / 0.693147180559945)
 
-
-double		seq_page_cost = DEFAULT_SEQ_PAGE_COST;
-double		random_page_cost = DEFAULT_RANDOM_PAGE_COST;
-double		cpu_tuple_cost = DEFAULT_CPU_TUPLE_COST;
-double		cpu_index_tuple_cost = DEFAULT_CPU_INDEX_TUPLE_COST;
-double		cpu_operator_cost = DEFAULT_CPU_OPERATOR_COST;
-
-int			effective_cache_size = -1;	/* will get replaced */
-
-Cost		disable_cost = 1.0e10;
-
-bool		enable_seqscan = true;
-bool		enable_indexscan = true;
-bool		enable_indexonlyscan = true;
-bool		enable_bitmapscan = true;
-bool		enable_tidscan = true;
-bool		enable_sort = true;
-bool		enable_hashagg = true;
-bool		enable_nestloop = true;
-bool		enable_material = true;
-bool		enable_mergejoin = true;
-bool		enable_hashjoin = true;
-
-typedef struct
-{
+double seq_page_cost = DEFAULT_SEQ_PAGE_COST;
+double random_page_cost = DEFAULT_RANDOM_PAGE_COST;
+double cpu_tuple_cost = DEFAULT_CPU_TUPLE_COST;
+double cpu_index_tuple_cost = DEFAULT_CPU_INDEX_TUPLE_COST;
+double cpu_operator_cost = DEFAULT_CPU_OPERATOR_COST;
+
+int effective_cache_size = -1; /* will get replaced */
+
+Cost disable_cost = 1.0e10;
+
+bool enable_seqscan = true;
+bool enable_indexscan = true;
+bool enable_indexonlyscan = true;
+bool enable_bitmapscan = true;
+bool enable_tidscan = true;
+bool enable_sort = true;
+bool enable_hashagg = true;
+bool enable_nestloop = true;
+bool enable_material = true;
+bool enable_mergejoin = true;
+bool enable_hashjoin = true;
+bool enable_memo = false;
+bool mode_cost_check = false;
+
+typedef struct {
 	PlannerInfo *root;
-	QualCost	total;
+	QualCost total;
 } cost_qual_eval_context;
 
-static MergeScanSelCache *cached_scansel(PlannerInfo *root,
-			   RestrictInfo *rinfo,
-			   PathKey *pathkey);
+static MergeScanSelCache *cached_scansel(PlannerInfo *root, RestrictInfo *rinfo,
+		PathKey *pathkey);
 static void cost_rescan(PlannerInfo *root, Path *path,
-			Cost *rescan_startup_cost, Cost *rescan_total_cost);
+		Cost *rescan_startup_cost, Cost *rescan_total_cost);
 static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context);
 static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
-						  ParamPathInfo *param_info,
-						  QualCost *qpqual_cost);
+		ParamPathInfo *param_info, QualCost *qpqual_cost);
 static bool has_indexed_join_quals(NestPath *joinpath);
-static double approx_tuple_count(PlannerInfo *root, JoinPath *path,
-				   List *quals);
-static double calc_joinrel_size_estimate(PlannerInfo *root,
-						   double outer_rows,
-						   double inner_rows,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist);
+static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals);
+static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
+		double inner_rows, SpecialJoinInfo *sjinfo, List *restrictlist);
 static void set_rel_width(PlannerInfo *root, RelOptInfo *rel);
 static double relation_byte_size(double tuples, int width);
 static double page_size(double tuples, int width);
 
-
 /*
  * clamp_row_est
  *		Force a row-count estimate to a sane value.
  */
-double
-clamp_row_est(double nrows)
-{
+double clamp_row_est(double nrows) {
 	/*
 	 * Force estimate to be at least one row, to make explain output look
 	 * better and to avoid possible divide-by-zero when interpolating costs.
@@ -168,7 +158,6 @@ clamp_row_est(double nrows)
 	return nrows;
 }
 
-
 /*
  * cost_seqscan
  *	  Determines and returns the cost of scanning a relation sequentially.
@@ -176,22 +165,28 @@ clamp_row_est(double nrows)
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_seqscan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		spc_seq_page_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double spc_seq_page_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
+
+	/* Should only be applied to base relations
+	 Assert(baserel->relid > 0);
+	 Assert(baserel->rtekind == RTE_RELATION);
+
+	 /* Mark the path with the correct row estimate */
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
 
-	/* Should only be applied to base relations */
-	Assert(baserel->relid > 0);
-	Assert(baserel->rtekind == RTE_RELATION);
-
-	/* Mark the path with the correct row estimate */
-	if (param_info)
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -200,9 +195,7 @@ cost_seqscan(Path *path, PlannerInfo *root,
 		startup_cost += disable_cost;
 
 	/* fetch estimated page cost for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  NULL,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, NULL, &spc_seq_page_cost);
 
 	/*
 	 * disk costs
@@ -214,10 +207,16 @@ cost_seqscan(Path *path, PlannerInfo *root,
 
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
+
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -238,46 +237,54 @@ cost_seqscan(Path *path, PlannerInfo *root,
  * number of returned tuples, but they won't reduce the number of tuples
  * we have to fetch from the table, so they don't reduce the scan cost.
  */
-void
-cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
-{
+void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
 	IndexOptInfo *index = path->indexinfo;
 	RelOptInfo *baserel = index->rel;
-	bool		indexonly = (path->path.pathtype == T_IndexOnlyScan);
-	List	   *allclauses;
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		indexStartupCost;
-	Cost		indexTotalCost;
+	bool indexonly = (path->path.pathtype == T_IndexOnlyScan);
+	List *allclauses;
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost indexStartupCost;
+	Cost indexTotalCost;
 	Selectivity indexSelectivity;
-	double		indexCorrelation,
-				csquared;
-	double		spc_seq_page_cost,
-				spc_random_page_cost;
-	Cost		min_IO_cost,
-				max_IO_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	double		tuples_fetched;
-	double		pages_fetched;
+	double indexCorrelation, csquared;
+	double spc_seq_page_cost, spc_random_page_cost;
+	Cost min_IO_cost, max_IO_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	double tuples_fetched;
+	double pages_fetched;
 
 	/* Should only be applied to base relations */
-	Assert(IsA(baserel, RelOptInfo) &&
-		   IsA(index, IndexOptInfo));
+	Assert(IsA(baserel, RelOptInfo) && IsA(index, IndexOptInfo));
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (path->path.param_info)
-	{
-		path->path.rows = path->path.param_info->ppi_rows;
+
+	if (path->path.param_info) {
+		if (mode_cost_check) {
+			path->path.rows = get_baserel_memo_size(path->path.parent->rel_name,
+					root->query_level);
+			if (path->path.rows >= 0) {
+				path->path.memo_checked = true;
+
+			}
+		} else
+			path->path.rows = path->path.param_info->ppi_rows;
 		/* also get the set of clauses that should be enforced by the scan */
 		allclauses = list_concat(list_copy(path->path.param_info->ppi_clauses),
-								 baserel->baserestrictinfo);
-	}
-	else
-	{
-		path->path.rows = baserel->rows;
+				baserel->baserestrictinfo);
+	} else {
+		if (mode_cost_check) {
+			path->path.rows = get_baserel_memo_size(path->path.parent->rel_name,
+					root->query_level);
+			if (path->path.rows >= 0) {
+				path->path.memo_checked = true;
+
+			}
+		} else
+			path->path.rows = baserel->rows;
 		/* allclauses should just be the rel's restriction clauses */
 		allclauses = baserel->baserestrictinfo;
 	}
@@ -292,14 +299,12 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * the fraction of main-table tuples we will have to retrieve) and its
 	 * correlation to the main-table tuple order.
 	 */
-	OidFunctionCall7(index->amcostestimate,
-					 PointerGetDatum(root),
-					 PointerGetDatum(path),
-					 Float8GetDatum(loop_count),
-					 PointerGetDatum(&indexStartupCost),
-					 PointerGetDatum(&indexTotalCost),
-					 PointerGetDatum(&indexSelectivity),
-					 PointerGetDatum(&indexCorrelation));
+	OidFunctionCall7(index->amcostestimate, PointerGetDatum(root),
+			PointerGetDatum(path), Float8GetDatum(loop_count),
+			PointerGetDatum(&indexStartupCost),
+			PointerGetDatum(&indexTotalCost),
+			PointerGetDatum(&indexSelectivity),
+			PointerGetDatum(&indexCorrelation));
 
 	/*
 	 * Save amcostestimate's results for possible use in bitmap scan planning.
@@ -314,12 +319,12 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	run_cost += indexTotalCost - indexStartupCost;
 
 	/* estimate number of main-table tuples fetched */
+
 	tuples_fetched = clamp_row_est(indexSelectivity * baserel->tuples);
 
 	/* fetch estimated page costs for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			&spc_seq_page_cost);
 
 	/*----------
 	 * Estimate number of main-table pages fetched, and compute I/O cost.
@@ -348,8 +353,7 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * that this query will fetch; but it's not clear how to do better.
 	 *----------
 	 */
-	if (loop_count > 1)
-	{
+	if (loop_count > 1) {
 		/*
 		 * For repeated indexscans, the appropriate estimate for the
 		 * uncorrelated case is to scale up the number of tuples fetched in
@@ -359,9 +363,7 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		 * fetches are random accesses.
 		 */
 		pages_fetched = index_pages_fetched(tuples_fetched * loop_count,
-											baserel->pages,
-											(double) index->pages,
-											root);
+				baserel->pages, (double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
@@ -381,25 +383,19 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		pages_fetched = ceil(indexSelectivity * (double) baserel->pages);
 
 		pages_fetched = index_pages_fetched(pages_fetched * loop_count,
-											baserel->pages,
-											(double) index->pages,
-											root);
+				baserel->pages, (double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
 
 		min_IO_cost = (pages_fetched * spc_random_page_cost) / loop_count;
-	}
-	else
-	{
+	} else {
 		/*
 		 * Normal case: apply the Mackert and Lohman formula, and then
 		 * interpolate between that and the correlation-derived result.
 		 */
-		pages_fetched = index_pages_fetched(tuples_fetched,
-											baserel->pages,
-											(double) index->pages,
-											root);
+		pages_fetched = index_pages_fetched(tuples_fetched, baserel->pages,
+				(double) index->pages, root);
 
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
@@ -413,13 +409,11 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 		if (indexonly)
 			pages_fetched = ceil(pages_fetched * (1.0 - baserel->allvisfrac));
 
-		if (pages_fetched > 0)
-		{
+		if (pages_fetched > 0) {
 			min_IO_cost = spc_random_page_cost;
 			if (pages_fetched > 1)
 				min_IO_cost += (pages_fetched - 1) * spc_seq_page_cost;
-		}
-		else
+		} else
 			min_IO_cost = 0;
 	}
 
@@ -446,16 +440,20 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
 	 * is selected for use.
 	 */
 	cost_qual_eval(&qpqual_cost,
-				   list_difference_ptr(allclauses, path->indexquals),
-				   root);
+			list_difference_ptr(allclauses, path->indexquals), root);
 
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
+	if (mode_cost_check) {
+		path->path.mstartup_cost = startup_cost;
+		path->path.mtotal_cost = startup_cost + run_cost;
 
-	path->path.startup_cost = startup_cost;
-	path->path.total_cost = startup_cost + run_cost;
+	} else {
+		path->path.startup_cost = startup_cost;
+		path->path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -496,14 +494,11 @@ cost_index(IndexPath *path, PlannerInfo *root, double loop_count)
  * and rounded to integer (see clamp_row_est).	The result will likewise be
  * greater than zero and integral.
  */
-double
-index_pages_fetched(double tuples_fetched, BlockNumber pages,
-					double index_pages, PlannerInfo *root)
-{
-	double		pages_fetched;
-	double		total_pages;
-	double		T,
-				b;
+double index_pages_fetched(double tuples_fetched, BlockNumber pages,
+		double index_pages, PlannerInfo *root) {
+	double pages_fetched;
+	double total_pages;
+	double T, b;
 
 	/* T is # pages in table, but don't allow it to be zero */
 	T = (pages > 1) ? (double) pages : 1.0;
@@ -514,7 +509,7 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
 	Assert(T <= total_pages);
 
 	/* b is pro-rated share of effective_cache_size */
-	b = (double) effective_cache_size *T / total_pages;
+	b = (double) effective_cache_size * T / total_pages;
 
 	/* force it positive and integral */
 	if (b <= 1.0)
@@ -523,29 +518,21 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
 		b = ceil(b);
 
 	/* This part is the Mackert and Lohman formula */
-	if (T <= b)
-	{
-		pages_fetched =
-			(2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
+	if (T <= b) {
+		pages_fetched = (2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
 		if (pages_fetched >= T)
 			pages_fetched = T;
 		else
 			pages_fetched = ceil(pages_fetched);
-	}
-	else
-	{
-		double		lim;
+	} else {
+		double lim;
 
 		lim = (2.0 * T * b) / (2.0 * T - b);
-		if (tuples_fetched <= lim)
-		{
-			pages_fetched =
-				(2.0 * T * tuples_fetched) / (2.0 * T + tuples_fetched);
-		}
-		else
-		{
-			pages_fetched =
-				b + (tuples_fetched - lim) * (T - b) / T;
+		if (tuples_fetched <= lim) {
+			pages_fetched = (2.0 * T * tuples_fetched)
+					/ (2.0 * T + tuples_fetched);
+		} else {
+			pages_fetched = b + (tuples_fetched - lim) * (T - b) / T;
 		}
 		pages_fetched = ceil(pages_fetched);
 	}
@@ -561,37 +548,27 @@ index_pages_fetched(double tuples_fetched, BlockNumber pages,
  * not completely clear, and detecting duplicates is difficult, so ignore it
  * for now.
  */
-static double
-get_indexpath_pages(Path *bitmapqual)
-{
-	double		result = 0;
-	ListCell   *l;
+static double get_indexpath_pages(Path *bitmapqual) {
+	double result = 0;
+	ListCell *l;
 
-	if (IsA(bitmapqual, BitmapAndPath))
-	{
+	if (IsA(bitmapqual, BitmapAndPath)) {
 		BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;
 
-		foreach(l, apath->bitmapquals)
-		{
+		foreach(l, apath->bitmapquals) {
 			result += get_indexpath_pages((Path *) lfirst(l));
 		}
-	}
-	else if (IsA(bitmapqual, BitmapOrPath))
-	{
+	} else if (IsA(bitmapqual, BitmapOrPath)) {
 		BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;
 
-		foreach(l, opath->bitmapquals)
-		{
+		foreach(l, opath->bitmapquals) {
 			result += get_indexpath_pages((Path *) lfirst(l));
 		}
-	}
-	else if (IsA(bitmapqual, IndexPath))
-	{
-		IndexPath  *ipath = (IndexPath *) bitmapqual;
+	} else if (IsA(bitmapqual, IndexPath)) {
+		IndexPath *ipath = (IndexPath *) bitmapqual;
 
 		result = (double) ipath->indexinfo->pages;
-	}
-	else
+	} else
 		elog(ERROR, "unrecognized node type: %d", nodeTag(bitmapqual));
 
 	return result;
@@ -611,23 +588,20 @@ get_indexpath_pages(Path *bitmapqual)
  * Note: the component IndexPaths in bitmapqual should have been costed
  * using the same loop_count.
  */
-void
-cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
-					  ParamPathInfo *param_info,
-					  Path *bitmapqual, double loop_count)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		indexTotalCost;
+void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info, Path *bitmapqual, double loop_count) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost indexTotalCost;
 	Selectivity indexSelectivity;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	Cost		cost_per_page;
-	double		tuples_fetched;
-	double		pages_fetched;
-	double		spc_seq_page_cost,
-				spc_random_page_cost;
-	double		T;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	Cost cost_per_page;
+	double tuples_fetched;
+	double pages_fetched;
+	double spc_seq_page_cost, spc_random_page_cost;
+	double T;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations */
 	Assert(IsA(baserel, RelOptInfo));
@@ -635,7 +609,14 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -652,9 +633,8 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	startup_cost += indexTotalCost;
 
 	/* Fetch estimated page costs for tablespace containing table. */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  &spc_seq_page_cost);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			&spc_seq_page_cost);
 
 	/*
 	 * Estimate number of main-table pages fetched.
@@ -663,8 +643,7 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 
 	T = (baserel->pages > 1) ? (double) baserel->pages : 1.0;
 
-	if (loop_count > 1)
-	{
+	if (loop_count > 1) {
 		/*
 		 * For repeated bitmap scans, scale up the number of tuples fetched in
 		 * the Mackert and Lohman formula by the number of scans, so that we
@@ -672,13 +651,9 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 		 * pro-rate for one scan.
 		 */
 		pages_fetched = index_pages_fetched(tuples_fetched * loop_count,
-											baserel->pages,
-											get_indexpath_pages(bitmapqual),
-											root);
+				baserel->pages, get_indexpath_pages(bitmapqual), root);
 		pages_fetched /= loop_count;
-	}
-	else
-	{
+	} else {
 		/*
 		 * For a single scan, the number of heap pages that need to be fetched
 		 * is the same as the Mackert and Lohman formula for the case T <= b
@@ -699,9 +674,9 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	 * determine the cost per page.
 	 */
 	if (pages_fetched >= 2.0)
-		cost_per_page = spc_random_page_cost -
-			(spc_random_page_cost - spc_seq_page_cost)
-			* sqrt(pages_fetched / T);
+		cost_per_page = spc_random_page_cost
+				- (spc_random_page_cost - spc_seq_page_cost)
+						* sqrt(pages_fetched / T);
 	else
 		cost_per_page = spc_random_page_cost;
 
@@ -722,20 +697,22 @@ cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
  * cost_bitmap_tree_node
  *		Extract cost and selectivity from a bitmap tree node (index/and/or)
  */
-void
-cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
-{
-	if (IsA(path, IndexPath))
-	{
+void cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec) {
+	if (IsA(path, IndexPath)) {
 		*cost = ((IndexPath *) path)->indextotalcost;
 		*selec = ((IndexPath *) path)->indexselectivity;
 
@@ -746,21 +723,15 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
 		 * single tuple.
 		 */
 		*cost += 0.1 * cpu_operator_cost * path->rows;
-	}
-	else if (IsA(path, BitmapAndPath))
-	{
+	} else if (IsA(path, BitmapAndPath)) {
 		*cost = path->total_cost;
 		*selec = ((BitmapAndPath *) path)->bitmapselectivity;
-	}
-	else if (IsA(path, BitmapOrPath))
-	{
+	} else if (IsA(path, BitmapOrPath)) {
 		*cost = path->total_cost;
 		*selec = ((BitmapOrPath *) path)->bitmapselectivity;
-	}
-	else
-	{
+	} else {
 		elog(ERROR, "unrecognized node type: %d", nodeTag(path));
-		*cost = *selec = 0;		/* keep compiler quiet */
+		*cost = *selec = 0; /* keep compiler quiet */
 	}
 }
 
@@ -774,12 +745,10 @@ cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec)
  * to warrant treating it as one.  We don't bother to set the path rows field,
  * however.
  */
-void
-cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
-{
-	Cost		totalCost;
+void cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root) {
+	Cost totalCost;
 	Selectivity selec;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * We estimate AND selectivity on the assumption that the inputs are
@@ -792,10 +761,9 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 	 */
 	totalCost = 0.0;
 	selec = 1.0;
-	foreach(l, path->bitmapquals)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
-		Cost		subCost;
+	foreach(l, path->bitmapquals) {
+		Path *subpath = (Path *) lfirst(l);
+		Cost subCost;
 		Selectivity subselec;
 
 		cost_bitmap_tree_node(subpath, &subCost, &subselec);
@@ -807,7 +775,7 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
 			totalCost += 100.0 * cpu_operator_cost;
 	}
 	path->bitmapselectivity = selec;
-	path->path.rows = 0;		/* per above, not used */
+	path->path.rows = 0; /* per above, not used */
 	path->path.startup_cost = totalCost;
 	path->path.total_cost = totalCost;
 }
@@ -818,12 +786,10 @@ cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root)
  *
  * See comments for cost_bitmap_and_node.
  */
-void
-cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
-{
-	Cost		totalCost;
+void cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root) {
+	Cost totalCost;
 	Selectivity selec;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * We estimate OR selectivity on the assumption that the inputs are
@@ -837,10 +803,9 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 	 */
 	totalCost = 0.0;
 	selec = 0.0;
-	foreach(l, path->bitmapquals)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
-		Cost		subCost;
+	foreach(l, path->bitmapquals) {
+		Path *subpath = (Path *) lfirst(l);
+		Cost subCost;
 		Selectivity subselec;
 
 		cost_bitmap_tree_node(subpath, &subCost, &subselec);
@@ -848,12 +813,11 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
 		selec += subselec;
 
 		totalCost += subCost;
-		if (l != list_head(path->bitmapquals) &&
-			!IsA(subpath, IndexPath))
+		if (l != list_head(path->bitmapquals) && !IsA(subpath, IndexPath))
 			totalCost += 100.0 * cpu_operator_cost;
 	}
 	path->bitmapselectivity = Min(selec, 1.0);
-	path->path.rows = 0;		/* per above, not used */
+	path->path.rows = 0; /* per above, not used */
 	path->path.startup_cost = totalCost;
 	path->path.total_cost = totalCost;
 }
@@ -866,50 +830,51 @@ cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root)
  * 'tidquals' is the list of TID-checkable quals
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_tidscan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, List *tidquals, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	bool		isCurrentOf = false;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
-	QualCost	tid_qual_cost;
-	int			ntuples;
-	ListCell   *l;
-	double		spc_random_page_cost;
+void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		List *tidquals, ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	bool isCurrentOf = false;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	QualCost tid_qual_cost;
+	int ntuples;
+	ListCell *l;
+	double spc_random_page_cost;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
 	/* Count how many tuples we expect to retrieve */
 	ntuples = 0;
-	foreach(l, tidquals)
-	{
-		if (IsA(lfirst(l), ScalarArrayOpExpr))
-		{
+
+	foreach(l, tidquals) {
+		if (IsA(lfirst(l), ScalarArrayOpExpr)) {
 			/* Each element of the array yields 1 tuple */
 			ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) lfirst(l);
-			Node	   *arraynode = (Node *) lsecond(saop->args);
+			Node *arraynode = (Node *) lsecond(saop->args);
 
 			ntuples += estimate_array_length(arraynode);
-		}
-		else if (IsA(lfirst(l), CurrentOfExpr))
-		{
+		} else if (IsA(lfirst(l), CurrentOfExpr)) {
 			/* CURRENT OF yields 1 tuple */
 			isCurrentOf = true;
 			ntuples++;
-		}
-		else
-		{
+		} else {
 			/* It's just CTID = something, count 1 tuple */
 			ntuples++;
 		}
@@ -923,12 +888,10 @@ cost_tidscan(Path *path, PlannerInfo *root,
 	 * subtract off here; that's to prevent other plan types such as seqscan
 	 * from winning.
 	 */
-	if (isCurrentOf)
-	{
+	if (isCurrentOf) {
 		Assert(baserel->baserestrictcost.startup >= disable_cost);
 		startup_cost -= disable_cost;
-	}
-	else if (!enable_tidscan)
+	} else if (!enable_tidscan)
 		startup_cost += disable_cost;
 
 	/*
@@ -938,9 +901,8 @@ cost_tidscan(Path *path, PlannerInfo *root,
 	cost_qual_eval(&tid_qual_cost, tidquals, root);
 
 	/* fetch estimated page cost for tablespace containing table */
-	get_tablespace_page_costs(baserel->reltablespace,
-							  &spc_random_page_cost,
-							  NULL);
+	get_tablespace_page_costs(baserel->reltablespace, &spc_random_page_cost,
+			NULL);
 
 	/* disk costs --- assume each tuple on a different page */
 	run_cost += spc_random_page_cost * ntuples;
@@ -950,12 +912,18 @@ cost_tidscan(Path *path, PlannerInfo *root,
 
 	/* XXX currently we assume TID quals are a subset of qpquals */
 	startup_cost += qpqual_cost.startup + tid_qual_cost.per_tuple;
-	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple -
-		tid_qual_cost.per_tuple;
+	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple
+			- tid_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
+
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -965,25 +933,36 @@ cost_tidscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_subqueryscan(Path *path, PlannerInfo *root,
-				  RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost;
-	Cost		run_cost;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_subqueryscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost;
+	Cost run_cost;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are subqueries */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_SUBQUERY);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	/*
 	 * Cost of path is cost of evaluating the subplan, plus cost of evaluating
 	 * any restriction clauses that will be attached to the SubqueryScan node,
@@ -1009,16 +988,14 @@ cost_subqueryscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_functionscan(Path *path, PlannerInfo *root,
-				  RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
 	RangeTblEntry *rte;
-	QualCost	exprcost;
+	QualCost exprcost;
 
 	/* Should only be applied to base relations that are functions */
 	Assert(baserel->relid > 0);
@@ -1044,6 +1021,11 @@ cost_functionscan(Path *path, PlannerInfo *root,
 	 * estimates for functions tend to be, there's not a lot of point in that
 	 * refinement right now.
 	 */
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	cost_qual_eval_node(&exprcost, (Node *) rte->functions, root);
 
 	startup_cost += exprcost.startup + exprcost.per_tuple;
@@ -1054,9 +1036,14 @@ cost_functionscan(Path *path, PlannerInfo *root,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1066,21 +1053,27 @@ cost_functionscan(Path *path, PlannerInfo *root,
  * 'baserel' is the relation to be scanned
  * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
  */
-void
-cost_valuesscan(Path *path, PlannerInfo *root,
-				RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are values lists */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_VALUES);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1089,6 +1082,12 @@ cost_valuesscan(Path *path, PlannerInfo *root,
 	 * For now, estimate list evaluation cost at one operator eval per list
 	 * (probably pretty bogus, but is it worth being smarter?)
 	 */
+
+	if (mode_cost_check) {
+
+		;
+	} else {
+	}
 	cpu_per_tuple = cpu_operator_cost;
 
 	/* Add scanning CPU costs */
@@ -1097,9 +1096,14 @@ cost_valuesscan(Path *path, PlannerInfo *root,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1112,21 +1116,27 @@ cost_valuesscan(Path *path, PlannerInfo *root,
  * referenced CTE query are added into the final plan as initplan costs,
  * and should NOT be counted here.
  */
-void
-cost_ctescan(Path *path, PlannerInfo *root,
-			 RelOptInfo *baserel, ParamPathInfo *param_info)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	QualCost	qpqual_cost;
-	Cost		cpu_per_tuple;
+void cost_ctescan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	QualCost qpqual_cost;
+	Cost cpu_per_tuple;
+	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are CTEs */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_CTE);
 
 	/* Mark the path with the correct row estimate */
-	if (param_info)
+	if (mode_cost_check) {
+		path->rows = get_baserel_memo_size(path->parent->rel_name,
+				root->query_level);
+		if (path->rows >= 0) {
+			path->memo_checked = true;
+
+		}
+	} else if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1141,8 +1151,14 @@ cost_ctescan(Path *path, PlannerInfo *root,
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
 
-	path->startup_cost = startup_cost;
-	path->total_cost = startup_cost + run_cost;
+	if (mode_cost_check) {
+		path->mstartup_cost = startup_cost;
+		path->mtotal_cost = startup_cost + run_cost;
+
+	} else {
+		path->startup_cost = startup_cost;
+		path->total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1156,12 +1172,10 @@ cost_ctescan(Path *path, PlannerInfo *root,
  * the rest of this module.  That's because we don't bother setting up a
  * Path representation for recursive union --- we have only one way to do it.
  */
-void
-cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
-	double		total_rows;
+void cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm) {
+	Cost startup_cost;
+	Cost total_cost;
+	double total_rows;
 
 	/* We probably have decent estimates for the non-recursive term */
 	startup_cost = nrterm->startup_cost;
@@ -1235,18 +1249,15 @@ cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm)
  * (Actually, the thing we'd most likely be interested in is just the number
  * of sort keys, which all callers *could* supply.)
  */
-void
-cost_sort(Path *path, PlannerInfo *root,
-		  List *pathkeys, Cost input_cost, double tuples, int width,
-		  Cost comparison_cost, int sort_mem,
-		  double limit_tuples)
-{
-	Cost		startup_cost = input_cost;
-	Cost		run_cost = 0;
-	double		input_bytes = relation_byte_size(tuples, width);
-	double		output_bytes;
-	double		output_tuples;
-	long		sort_mem_bytes = sort_mem * 1024L;
+void cost_sort(Path *path, PlannerInfo *root, List *pathkeys, Cost input_cost,
+		double tuples, int width, Cost comparison_cost, int sort_mem,
+		double limit_tuples) {
+	Cost startup_cost = input_cost;
+	Cost run_cost = 0;
+	double input_bytes = relation_byte_size(tuples, width);
+	double output_bytes;
+	double output_tuples;
+	long sort_mem_bytes = sort_mem * 1024L;
 
 	if (!enable_sort)
 		startup_cost += disable_cost;
@@ -1264,27 +1275,23 @@ cost_sort(Path *path, PlannerInfo *root,
 	comparison_cost += 2.0 * cpu_operator_cost;
 
 	/* Do we have a useful LIMIT? */
-	if (limit_tuples > 0 && limit_tuples < tuples)
-	{
+	if (limit_tuples > 0 && limit_tuples < tuples) {
 		output_tuples = limit_tuples;
 		output_bytes = relation_byte_size(output_tuples, width);
-	}
-	else
-	{
+	} else {
 		output_tuples = tuples;
 		output_bytes = input_bytes;
 	}
 
-	if (output_bytes > sort_mem_bytes)
-	{
+	if (output_bytes > sort_mem_bytes) {
 		/*
 		 * We'll have to use a disk-based sort of all the tuples
 		 */
-		double		npages = ceil(input_bytes / BLCKSZ);
-		double		nruns = (input_bytes / sort_mem_bytes) * 0.5;
-		double		mergeorder = tuplesort_merge_order(sort_mem_bytes);
-		double		log_runs;
-		double		npageaccesses;
+		double npages = ceil(input_bytes / BLCKSZ);
+		double nruns = (input_bytes / sort_mem_bytes) * 0.5;
+		double mergeorder = tuplesort_merge_order(sort_mem_bytes);
+		double log_runs;
+		double npageaccesses;
 
 		/*
 		 * CPU costs
@@ -1302,11 +1309,9 @@ cost_sort(Path *path, PlannerInfo *root,
 			log_runs = 1.0;
 		npageaccesses = 2.0 * npages * log_runs;
 		/* Assume 3/4ths of accesses are sequential, 1/4th are not */
-		startup_cost += npageaccesses *
-			(seq_page_cost * 0.75 + random_page_cost * 0.25);
-	}
-	else if (tuples > 2 * output_tuples || input_bytes > sort_mem_bytes)
-	{
+		startup_cost += npageaccesses
+				* (seq_page_cost * 0.75 + random_page_cost * 0.25);
+	} else if (tuples > 2 * output_tuples || input_bytes > sort_mem_bytes) {
 		/*
 		 * We'll use a bounded heap-sort keeping just K tuples in memory, for
 		 * a total number of tuple comparisons of N log2 K; but the constant
@@ -1314,9 +1319,7 @@ cost_sort(Path *path, PlannerInfo *root,
 		 * cost curve is continuous at the crossover point.
 		 */
 		startup_cost += comparison_cost * tuples * LOG2(2.0 * output_tuples);
-	}
-	else
-	{
+	} else {
 		/* We'll use plain quicksort on all the input tuples */
 		startup_cost += comparison_cost * tuples * LOG2(tuples);
 	}
@@ -1360,17 +1363,14 @@ cost_sort(Path *path, PlannerInfo *root,
  * 'input_total_cost' is the sum of the input streams' total costs
  * 'tuples' is the number of tuples in all the streams
  */
-void
-cost_merge_append(Path *path, PlannerInfo *root,
-				  List *pathkeys, int n_streams,
-				  Cost input_startup_cost, Cost input_total_cost,
-				  double tuples)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	Cost		comparison_cost;
-	double		N;
-	double		logN;
+void cost_merge_append(Path *path, PlannerInfo *root, List *pathkeys,
+		int n_streams, Cost input_startup_cost, Cost input_total_cost,
+		double tuples) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	Cost comparison_cost;
+	double N;
+	double logN;
 
 	/*
 	 * Avoid log(0)...
@@ -1411,15 +1411,12 @@ cost_merge_append(Path *path, PlannerInfo *root,
  * relation, so the materialization is all overhead --- any savings will
  * occur only on rescan, which is estimated in cost_rescan.
  */
-void
-cost_material(Path *path,
-			  Cost input_startup_cost, Cost input_total_cost,
-			  double tuples, int width)
-{
-	Cost		startup_cost = input_startup_cost;
-	Cost		run_cost = input_total_cost - input_startup_cost;
-	double		nbytes = relation_byte_size(tuples, width);
-	long		work_mem_bytes = work_mem * 1024L;
+void cost_material(Path *path, Cost input_startup_cost, Cost input_total_cost,
+		double tuples, int width) {
+	Cost startup_cost = input_startup_cost;
+	Cost run_cost = input_total_cost - input_startup_cost;
+	double nbytes = relation_byte_size(tuples, width);
+	long work_mem_bytes = work_mem * 1024L;
 
 	path->rows = tuples;
 
@@ -1443,9 +1440,8 @@ cost_material(Path *path,
 	 * which isn't exactly accurate but our cost model doesn't allow for
 	 * nonuniform costs within the run phase.
 	 */
-	if (nbytes > work_mem_bytes)
-	{
-		double		npages = ceil(nbytes / BLCKSZ);
+	if (nbytes > work_mem_bytes) {
+		double npages = ceil(nbytes / BLCKSZ);
 
 		run_cost += seq_page_cost * npages;
 	}
@@ -1465,21 +1461,16 @@ cost_material(Path *path,
  * Note: when aggstrategy == AGG_SORTED, caller must ensure that input costs
  * are for appropriately-sorted input.
  */
-void
-cost_agg(Path *path, PlannerInfo *root,
-		 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
-		 int numGroupCols, double numGroups,
-		 Cost input_startup_cost, Cost input_total_cost,
-		 double input_tuples)
-{
-	double		output_tuples;
-	Cost		startup_cost;
-	Cost		total_cost;
+void cost_agg(Path *path, PlannerInfo *root, AggStrategy aggstrategy,
+		const AggClauseCosts *aggcosts, int numGroupCols, double numGroups,
+		Cost input_startup_cost, Cost input_total_cost, double input_tuples) {
+	double output_tuples;
+	Cost startup_cost;
+	Cost total_cost;
 	AggClauseCosts dummy_aggcosts;
 
 	/* Use all-zero per-aggregate costs if NULL is passed */
-	if (aggcosts == NULL)
-	{
+	if (aggcosts == NULL) {
 		Assert(aggstrategy == AGG_HASHED);
 		MemSet(&dummy_aggcosts, 0, sizeof(AggClauseCosts));
 		aggcosts = &dummy_aggcosts;
@@ -1507,8 +1498,7 @@ cost_agg(Path *path, PlannerInfo *root,
 	 * the computations below form the same intermediate values in the same
 	 * order.
 	 */
-	if (aggstrategy == AGG_PLAIN)
-	{
+	if (aggstrategy == AGG_PLAIN) {
 		startup_cost = input_total_cost;
 		startup_cost += aggcosts->transCost.startup;
 		startup_cost += aggcosts->transCost.per_tuple * input_tuples;
@@ -1516,9 +1506,7 @@ cost_agg(Path *path, PlannerInfo *root,
 		/* we aren't grouping */
 		total_cost = startup_cost + cpu_tuple_cost;
 		output_tuples = 1;
-	}
-	else if (aggstrategy == AGG_SORTED)
-	{
+	} else if (aggstrategy == AGG_SORTED) {
 		/* Here we are able to deliver output on-the-fly */
 		startup_cost = input_startup_cost;
 		total_cost = input_total_cost;
@@ -1529,9 +1517,7 @@ cost_agg(Path *path, PlannerInfo *root,
 		total_cost += aggcosts->finalCost * numGroups;
 		total_cost += cpu_tuple_cost * numGroups;
 		output_tuples = numGroups;
-	}
-	else
-	{
+	} else {
 		/* must be AGG_HASHED */
 		startup_cost = input_total_cost;
 		startup_cost += aggcosts->transCost.startup;
@@ -1555,15 +1541,12 @@ cost_agg(Path *path, PlannerInfo *root,
  *
  * Input is assumed already properly sorted.
  */
-void
-cost_windowagg(Path *path, PlannerInfo *root,
-			   List *windowFuncs, int numPartCols, int numOrderCols,
-			   Cost input_startup_cost, Cost input_total_cost,
-			   double input_tuples)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
-	ListCell   *lc;
+void cost_windowagg(Path *path, PlannerInfo *root, List *windowFuncs,
+		int numPartCols, int numOrderCols, Cost input_startup_cost,
+		Cost input_total_cost, double input_tuples) {
+	Cost startup_cost;
+	Cost total_cost;
+	ListCell *lc;
 
 	startup_cost = input_startup_cost;
 	total_cost = input_total_cost;
@@ -1576,12 +1559,10 @@ cost_windowagg(Path *path, PlannerInfo *root,
 	 * many rows the window function will fetch, it's hard to do better.  In
 	 * any case, it's a good estimate for all the built-in window functions,
 	 * so we'll just do this for now.
-	 */
-	foreach(lc, windowFuncs)
-	{
+	 */foreach(lc, windowFuncs) {
 		WindowFunc *wfunc = (WindowFunc *) lfirst(lc);
-		Cost		wfunccost;
-		QualCost	argcosts;
+		Cost wfunccost;
+		QualCost argcosts;
 
 		Assert(IsA(wfunc, WindowFunc));
 
@@ -1611,7 +1592,8 @@ cost_windowagg(Path *path, PlannerInfo *root,
 	 * XXX this neglects costs of spooling the data to disk when it overflows
 	 * work_mem.  Sooner or later that should get accounted for.
 	 */
-	total_cost += cpu_operator_cost * (numPartCols + numOrderCols) * input_tuples;
+	total_cost += cpu_operator_cost * (numPartCols + numOrderCols)
+			* input_tuples;
 	total_cost += cpu_tuple_cost * input_tuples;
 
 	path->rows = input_tuples;
@@ -1627,14 +1609,11 @@ cost_windowagg(Path *path, PlannerInfo *root,
  * Note: caller must ensure that input costs are for appropriately-sorted
  * input.
  */
-void
-cost_group(Path *path, PlannerInfo *root,
-		   int numGroupCols, double numGroups,
-		   Cost input_startup_cost, Cost input_total_cost,
-		   double input_tuples)
-{
-	Cost		startup_cost;
-	Cost		total_cost;
+void cost_group(Path *path, PlannerInfo *root, int numGroupCols,
+		double numGroups, Cost input_startup_cost, Cost input_total_cost,
+		double input_tuples) {
+	Cost startup_cost;
+	Cost total_cost;
 
 	startup_cost = input_startup_cost;
 	total_cost = input_total_cost;
@@ -1674,25 +1653,21 @@ cost_group(Path *path, PlannerInfo *root,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if jointype is SEMI or ANTI
  */
-void
-initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
-					  JoinType jointype,
-					  Path *outer_path, Path *inner_path,
-					  SpecialJoinInfo *sjinfo,
-					  SemiAntiJoinFactors *semifactors)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	Cost		inner_rescan_start_cost;
-	Cost		inner_rescan_total_cost;
-	Cost		inner_run_cost;
-	Cost		inner_rescan_run_cost;
-
+void initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, Path *outer_path, Path *inner_path,
+		SpecialJoinInfo *sjinfo, SemiAntiJoinFactors *semifactors) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = outer_path->rows;
+	Cost inner_rescan_start_cost;
+	Cost inner_rescan_total_cost;
+	Cost inner_run_cost;
+	Cost inner_rescan_run_cost;
+
+	workspace->semifactors = semifactors;
 	/* estimate costs to rescan the inner relation */
-	cost_rescan(root, inner_path,
-				&inner_rescan_start_cost,
-				&inner_rescan_total_cost);
+	cost_rescan(root, inner_path, &inner_rescan_start_cost,
+			&inner_rescan_total_cost);
 
 	/* cost of source data */
 
@@ -1702,17 +1677,27 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * their sum.  We'll also pay the inner path's rescan startup cost
 	 * multiple times.
 	 */
-	startup_cost += outer_path->startup_cost + inner_path->startup_cost;
-	run_cost += outer_path->total_cost - outer_path->startup_cost;
-	if (outer_path_rows > 1)
-		run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+	if (mode_cost_check) {
+		startup_cost += outer_path->mstartup_cost + inner_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		if (outer_path_rows > 1)
+			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
 
-	inner_run_cost = inner_path->total_cost - inner_path->startup_cost;
+		inner_run_cost = inner_path->mtotal_cost - inner_path->mstartup_cost;
+
+	} else {
+		startup_cost += outer_path->startup_cost + inner_path->startup_cost;
+		run_cost += outer_path->total_cost - outer_path->startup_cost;
+		if (outer_path_rows > 1)
+			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+
+		inner_run_cost = inner_path->total_cost - inner_path->startup_cost;
+
+	}
 	inner_rescan_run_cost = inner_rescan_total_cost - inner_rescan_start_cost;
 
-	if (jointype == JOIN_SEMI || jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows;
+	if (jointype == JOIN_SEMI || jointype == JOIN_ANTI) {
+		double outer_matched_rows;
 		Selectivity inner_scan_frac;
 
 		/*
@@ -1735,12 +1720,14 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 		 */
 		run_cost += inner_run_cost;
 
-		outer_matched_rows = rint(outer_path_rows * semifactors->outer_match_frac);
+		outer_matched_rows = rint(
+				outer_path_rows * semifactors->outer_match_frac);
 		inner_scan_frac = 2.0 / (semifactors->match_count + 1.0);
 
 		/* Add inner run cost for additional outer tuples having matches */
 		if (outer_matched_rows > 1)
-			run_cost += (outer_matched_rows - 1) * inner_rescan_run_cost * inner_scan_frac;
+			run_cost += (outer_matched_rows - 1) * inner_rescan_run_cost
+					* inner_scan_frac;
 
 		/*
 		 * The cost of processing unmatched rows varies depending on the
@@ -1750,9 +1737,7 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 		/* Save private data for final_cost_nestloop */
 		workspace->outer_matched_rows = outer_matched_rows;
 		workspace->inner_scan_frac = inner_scan_frac;
-	}
-	else
-	{
+	} else {
 		/* Normal case; we'll scan whole input rel for each outer row */
 		run_cost += inner_run_cost;
 		if (outer_path_rows > 1)
@@ -1778,25 +1763,30 @@ initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if path->jointype is SEMI or ANTI
  */
-void
-final_cost_nestloop(PlannerInfo *root, NestPath *path,
-					JoinCostWorkspace *workspace,
-					SpecialJoinInfo *sjinfo,
-					SemiAntiJoinFactors *semifactors)
-{
-	Path	   *outer_path = path->outerjoinpath;
-	Path	   *inner_path = path->innerjoinpath;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	Cost		inner_rescan_run_cost = workspace->inner_rescan_run_cost;
-	Cost		cpu_per_tuple;
-	QualCost	restrict_qual_cost;
-	double		ntuples;
+void final_cost_nestloop(PlannerInfo *root, NestPath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+	Path *outer_path = path->outerjoinpath;
+	Path *inner_path = path->innerjoinpath;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	Cost inner_rescan_run_cost = workspace->inner_rescan_run_cost;
+	Cost cpu_per_tuple;
+	QualCost restrict_qual_cost;
+	double ntuples;
+	path->path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (path->path.param_info)
+	if (mode_cost_check) {
+		path->path.rows = get_join_memo_size(path->path.parent->rel_name,
+				root->query_level);
+		if (path->path.rows >= 0) {
+			path->path.memo_checked = true;
+
+		}
+	} else if (path->path.param_info)
 		path->path.rows = path->path.param_info->ppi_rows;
 	else
 		path->path.rows = path->path.parent->rows;
@@ -1811,9 +1801,8 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 
 	/* cost of source data */
 
-	if (path->jointype == JOIN_SEMI || path->jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows = workspace->outer_matched_rows;
+	if (path->jointype == JOIN_SEMI || path->jointype == JOIN_ANTI) {
+		double outer_matched_rows = workspace->outer_matched_rows;
 		Selectivity inner_scan_frac = workspace->inner_scan_frac;
 
 		/*
@@ -1831,26 +1820,20 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 		 * return the first tuple of a nonempty scan.  Otherwise, the executor
 		 * will have to scan the whole inner rel; not so cheap.
 		 */
-		if (has_indexed_join_quals(path))
-		{
-			run_cost += (outer_path_rows - outer_matched_rows) *
-				inner_rescan_run_cost / inner_path_rows;
+		if (has_indexed_join_quals(path)) {
+			run_cost += (outer_path_rows - outer_matched_rows)
+					* inner_rescan_run_cost / inner_path_rows;
 
 			/*
 			 * We won't be evaluating any quals at all for these rows, so
 			 * don't add them to ntuples.
 			 */
+		} else {
+			run_cost += (outer_path_rows - outer_matched_rows)
+					* inner_rescan_run_cost;
+			ntuples += (outer_path_rows - outer_matched_rows) * inner_path_rows;
 		}
-		else
-		{
-			run_cost += (outer_path_rows - outer_matched_rows) *
-				inner_rescan_run_cost;
-			ntuples += (outer_path_rows - outer_matched_rows) *
-				inner_path_rows;
-		}
-	}
-	else
-	{
+	} else {
 		/* Normal-case source costs were included in preliminary estimate */
 
 		/* Compute number of tuples processed (not number emitted!) */
@@ -1862,9 +1845,14 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
 	startup_cost += restrict_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + restrict_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
+	if (mode_cost_check) {
+		path->path.mstartup_cost = startup_cost;
+		path->path.mtotal_cost = startup_cost + run_cost;
 
-	path->path.startup_cost = startup_cost;
-	path->path.total_cost = startup_cost + run_cost;
+	} else {
+		path->path.startup_cost = startup_cost;
+		path->path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
@@ -1897,28 +1885,19 @@ final_cost_nestloop(PlannerInfo *root, NestPath *path,
  * Note: outersortkeys and innersortkeys should be NIL if no explicit
  * sort is needed because the respective source path is already ordered.
  */
-void
-initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
-					   JoinType jointype,
-					   List *mergeclauses,
-					   Path *outer_path, Path *inner_path,
-					   List *outersortkeys, List *innersortkeys,
-					   SpecialJoinInfo *sjinfo)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	Cost		inner_run_cost;
-	double		outer_rows,
-				inner_rows,
-				outer_skip_rows,
-				inner_skip_rows;
-	Selectivity outerstartsel,
-				outerendsel,
-				innerstartsel,
-				innerendsel;
-	Path		sort_path;		/* dummy for result of cost_sort */
+void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, List *mergeclauses, Path *outer_path,
+		Path *inner_path, List *outersortkeys, List *innersortkeys,
+		SpecialJoinInfo *sjinfo) {
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = mode_cost_check ? 0 : outer_path->rows;
+	double inner_path_rows = mode_cost_check ? 0 : inner_path->rows;
+
+	Cost inner_run_cost;
+	double outer_rows, inner_rows, outer_skip_rows, inner_skip_rows;
+	Selectivity outerstartsel, outerendsel, innerstartsel, innerendsel;
+	Path sort_path; /* dummy for result of cost_sort */
 
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (outer_path_rows <= 0 || isnan(outer_path_rows))
@@ -1937,13 +1916,12 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * mergejoinscansel() is a fairly expensive computation, we cache the
 	 * results in the merge clause RestrictInfo.
 	 */
-	if (mergeclauses && jointype != JOIN_FULL)
-	{
+	if (mergeclauses && jointype != JOIN_FULL) {
 		RestrictInfo *firstclause = (RestrictInfo *) linitial(mergeclauses);
-		List	   *opathkeys;
-		List	   *ipathkeys;
-		PathKey    *opathkey;
-		PathKey    *ipathkey;
+		List *opathkeys;
+		List *ipathkeys;
+		PathKey *opathkey;
+		PathKey *ipathkey;
 		MergeScanSelCache *cache;
 
 		/* Get the input pathkeys to determine the sort-order details */
@@ -1954,46 +1932,38 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 		opathkey = (PathKey *) linitial(opathkeys);
 		ipathkey = (PathKey *) linitial(ipathkeys);
 		/* debugging check */
-		if (opathkey->pk_opfamily != ipathkey->pk_opfamily ||
-			opathkey->pk_eclass->ec_collation != ipathkey->pk_eclass->ec_collation ||
-			opathkey->pk_strategy != ipathkey->pk_strategy ||
-			opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
+		if (opathkey->pk_opfamily != ipathkey->pk_opfamily
+				|| opathkey->pk_eclass->ec_collation
+						!= ipathkey->pk_eclass->ec_collation
+				|| opathkey->pk_strategy != ipathkey->pk_strategy
+				|| opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
 			elog(ERROR, "left and right pathkeys do not match in mergejoin");
 
 		/* Get the selectivity with caching */
 		cache = cached_scansel(root, firstclause, opathkey);
 
 		if (bms_is_subset(firstclause->left_relids,
-						  outer_path->parent->relids))
-		{
+				outer_path->parent->relids)) {
 			/* left side of clause is outer */
 			outerstartsel = cache->leftstartsel;
 			outerendsel = cache->leftendsel;
 			innerstartsel = cache->rightstartsel;
 			innerendsel = cache->rightendsel;
-		}
-		else
-		{
+		} else {
 			/* left side of clause is inner */
 			outerstartsel = cache->rightstartsel;
 			outerendsel = cache->rightendsel;
 			innerstartsel = cache->leftstartsel;
 			innerendsel = cache->leftendsel;
 		}
-		if (jointype == JOIN_LEFT ||
-			jointype == JOIN_ANTI)
-		{
+		if (jointype == JOIN_LEFT || jointype == JOIN_ANTI) {
 			outerstartsel = 0.0;
 			outerendsel = 1.0;
-		}
-		else if (jointype == JOIN_RIGHT)
-		{
+		} else if (jointype == JOIN_RIGHT) {
 			innerstartsel = 0.0;
 			innerendsel = 1.0;
 		}
-	}
-	else
-	{
+	} else {
 		/* cope with clauseless or full mergejoin */
 		outerstartsel = innerstartsel = 0.0;
 		outerendsel = innerendsel = 1.0;
@@ -2025,57 +1995,78 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	Assert(innerstartsel <= innerendsel);
 
 	/* cost of source data */
-
-	if (outersortkeys)			/* do we need to sort outer? */
+	if (outersortkeys) /* do we need to sort outer? */
 	{
-		cost_sort(&sort_path,
-				  root,
-				  outersortkeys,
-				  outer_path->total_cost,
-				  outer_path_rows,
-				  outer_path->parent->width,
-				  0.0,
-				  work_mem,
-				  -1.0);
+
+		if (mode_cost_check) {
+			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
+					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
+					-1.0);
+		} else {
+
+			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
+					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
+					-1.0);
+		}
+
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* outerstartsel;
+				* outerstartsel;
 		run_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* (outerendsel - outerstartsel);
-	}
-	else
-	{
-		startup_cost += outer_path->startup_cost;
-		startup_cost += (outer_path->total_cost - outer_path->startup_cost)
-			* outerstartsel;
-		run_cost += (outer_path->total_cost - outer_path->startup_cost)
-			* (outerendsel - outerstartsel);
+				* (outerendsel - outerstartsel);
+
+	} else {
+
+		if (mode_cost_check) {
+			startup_cost += outer_path->mstartup_cost;
+			startup_cost +=
+					(outer_path->mtotal_cost - outer_path->mstartup_cost)
+							* outerstartsel;
+			run_cost += (outer_path->mtotal_cost - outer_path->mstartup_cost)
+					* (outerendsel - outerstartsel);
+		} else {
+			startup_cost += outer_path->startup_cost;
+			startup_cost += (outer_path->total_cost - outer_path->startup_cost)
+					* outerstartsel;
+			run_cost += (outer_path->total_cost - outer_path->startup_cost)
+					* (outerendsel - outerstartsel);
+		}
+
 	}
 
-	if (innersortkeys)			/* do we need to sort inner? */
+	if (innersortkeys) /* do we need to sort inner? */
 	{
-		cost_sort(&sort_path,
-				  root,
-				  innersortkeys,
-				  inner_path->total_cost,
-				  inner_path_rows,
-				  inner_path->parent->width,
-				  0.0,
-				  work_mem,
-				  -1.0);
+		if (mode_cost_check) {
+			cost_sort(&sort_path, root, innersortkeys, inner_path->mtotal_cost,
+					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
+					-1.0);
+		} else {
+			cost_sort(&sort_path, root, innersortkeys, inner_path->total_cost,
+					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
+					-1.0);
+		}
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
-			* innerstartsel;
+				* innerstartsel;
 		inner_run_cost = (sort_path.total_cost - sort_path.startup_cost)
-			* (innerendsel - innerstartsel);
-	}
-	else
-	{
-		startup_cost += inner_path->startup_cost;
-		startup_cost += (inner_path->total_cost - inner_path->startup_cost)
-			* innerstartsel;
-		inner_run_cost = (inner_path->total_cost - inner_path->startup_cost)
-			* (innerendsel - innerstartsel);
+				* (innerendsel - innerstartsel);
+	} else {
+
+		if (mode_cost_check) {
+			startup_cost += inner_path->mstartup_cost;
+			startup_cost +=
+					(inner_path->mtotal_cost - inner_path->mstartup_cost)
+							* innerstartsel;
+			inner_run_cost = (inner_path->mtotal_cost
+					- inner_path->mstartup_cost)
+					* (innerendsel - innerstartsel);
+		} else {
+			startup_cost += inner_path->startup_cost;
+			startup_cost += (inner_path->total_cost - inner_path->startup_cost)
+					* innerstartsel;
+			inner_run_cost = (inner_path->total_cost - inner_path->startup_cost)
+					* (innerendsel - innerstartsel);
+		}
 	}
 
 	/*
@@ -2120,38 +2111,40 @@ initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'workspace' is the result from initial_cost_mergejoin
  * 'sjinfo' is extra info about the join for selectivity estimation
  */
-void
-final_cost_mergejoin(PlannerInfo *root, MergePath *path,
-					 JoinCostWorkspace *workspace,
-					 SpecialJoinInfo *sjinfo)
-{
-	Path	   *outer_path = path->jpath.outerjoinpath;
-	Path	   *inner_path = path->jpath.innerjoinpath;
-	double		inner_path_rows = inner_path->rows;
-	List	   *mergeclauses = path->path_mergeclauses;
-	List	   *innersortkeys = path->innersortkeys;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	Cost		inner_run_cost = workspace->inner_run_cost;
-	double		outer_rows = workspace->outer_rows;
-	double		inner_rows = workspace->inner_rows;
-	double		outer_skip_rows = workspace->outer_skip_rows;
-	double		inner_skip_rows = workspace->inner_skip_rows;
-	Cost		cpu_per_tuple,
-				bare_inner_cost,
-				mat_inner_cost;
-	QualCost	merge_qual_cost;
-	QualCost	qp_qual_cost;
-	double		mergejointuples,
-				rescannedtuples;
-	double		rescanratio;
+void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo) {
+	Path *outer_path = path->jpath.outerjoinpath;
+	Path *inner_path = path->jpath.innerjoinpath;
+	double inner_path_rows = inner_path->rows;
+	List *mergeclauses = path->path_mergeclauses;
+	List *innersortkeys = path->innersortkeys;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	Cost inner_run_cost = workspace->inner_run_cost;
+	double outer_rows = workspace->outer_rows;
+	double inner_rows = workspace->inner_rows;
+	double outer_skip_rows = workspace->outer_skip_rows;
+	double inner_skip_rows = workspace->inner_skip_rows;
+	Cost cpu_per_tuple, bare_inner_cost, mat_inner_cost;
+	QualCost merge_qual_cost;
+	QualCost qp_qual_cost;
+	double mergejointuples, rescannedtuples;
+	double rescanratio;
+	path->jpath.path.memo_checked = false;
 
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (inner_path_rows <= 0 || isnan(inner_path_rows))
 		inner_path_rows = 1;
 
 	/* Mark the path with the correct row estimate */
-	if (path->jpath.path.param_info)
+	if (mode_cost_check) {
+		path->jpath.path.rows = get_join_memo_size(
+				path->jpath.path.parent->rel_name, root->query_level);
+		if (path->jpath.path.rows >= 0) {
+			path->jpath.path.memo_checked = true;
+
+		}
+	} else if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2207,8 +2200,7 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 */
 	if (IsA(outer_path, UniquePath))
 		rescannedtuples = 0;
-	else
-	{
+	else {
 		rescannedtuples = mergejointuples - inner_path_rows;
 		/* Must clamp because of possible underestimate */
 		if (rescannedtuples < 0)
@@ -2241,8 +2233,8 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * Note: keep this estimate in sync with create_mergejoin_plan's labeling
 	 * of the generated Material node.
 	 */
-	mat_inner_cost = inner_run_cost +
-		cpu_operator_cost * inner_path_rows * rescanratio;
+	mat_inner_cost = inner_run_cost
+			+ cpu_operator_cost * inner_path_rows * rescanratio;
 
 	/*
 	 * Prefer materializing if it looks cheaper, unless the user has asked to
@@ -2267,8 +2259,8 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * materialization is required for correctness in this case, and turning
 	 * it off does not entitle us to deliver an invalid plan.
 	 */
-	else if (innersortkeys == NIL &&
-			 !ExecSupportsMarkRestore(inner_path->pathtype))
+	else if (innersortkeys == NIL
+			&& !ExecSupportsMarkRestore(inner_path->pathtype))
 		path->materialize_inner = true;
 
 	/*
@@ -2282,9 +2274,9 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * rather than necessary for correctness, we skip it if enable_material is
 	 * off.
 	 */
-	else if (enable_material && innersortkeys != NIL &&
-			 relation_byte_size(inner_path_rows, inner_path->parent->width) >
-			 (work_mem * 1024L))
+	else if (enable_material && innersortkeys != NIL
+			&& relation_byte_size(inner_path_rows, inner_path->parent->width)
+					> (work_mem * 1024L))
 		path->materialize_inner = true;
 	else
 		path->materialize_inner = false;
@@ -2303,11 +2295,11 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * refine this?).  At each one, we need to evaluate the mergejoin quals.
 	 */
 	startup_cost += merge_qual_cost.startup;
-	startup_cost += merge_qual_cost.per_tuple *
-		(outer_skip_rows + inner_skip_rows * rescanratio);
-	run_cost += merge_qual_cost.per_tuple *
-		((outer_rows - outer_skip_rows) +
-		 (inner_rows - inner_skip_rows) * rescanratio);
+	startup_cost += merge_qual_cost.per_tuple
+			* (outer_skip_rows + inner_skip_rows * rescanratio);
+	run_cost += merge_qual_cost.per_tuple
+			* ((outer_rows - outer_skip_rows)
+					+ (inner_rows - inner_skip_rows) * rescanratio);
 
 	/*
 	 * For each tuple that gets through the mergejoin proper, we charge
@@ -2321,46 +2313,39 @@ final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * mergejointuples;
+	if (mode_cost_check) {
+		path->jpath.path.mstartup_cost = startup_cost;
+		path->jpath.path.mtotal_cost = startup_cost + run_cost;
 
-	path->jpath.path.startup_cost = startup_cost;
-	path->jpath.path.total_cost = startup_cost + run_cost;
+	} else {
+		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.total_cost = startup_cost + run_cost;
+	}
 }
 
 /*
  * run mergejoinscansel() with caching
  */
 static MergeScanSelCache *
-cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey)
-{
+cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey) {
 	MergeScanSelCache *cache;
-	ListCell   *lc;
-	Selectivity leftstartsel,
-				leftendsel,
-				rightstartsel,
-				rightendsel;
+	ListCell *lc;
+	Selectivity leftstartsel, leftendsel, rightstartsel, rightendsel;
 	MemoryContext oldcontext;
 
-	/* Do we have this result already? */
-	foreach(lc, rinfo->scansel_cache)
-	{
+	/* Do we have this result already? */foreach(lc, rinfo->scansel_cache) {
 		cache = (MergeScanSelCache *) lfirst(lc);
-		if (cache->opfamily == pathkey->pk_opfamily &&
-			cache->collation == pathkey->pk_eclass->ec_collation &&
-			cache->strategy == pathkey->pk_strategy &&
-			cache->nulls_first == pathkey->pk_nulls_first)
+		if (cache->opfamily == pathkey->pk_opfamily
+				&& cache->collation == pathkey->pk_eclass->ec_collation
+				&& cache->strategy == pathkey->pk_strategy
+				&& cache->nulls_first == pathkey->pk_nulls_first)
 			return cache;
 	}
 
 	/* Nope, do the computation */
-	mergejoinscansel(root,
-					 (Node *) rinfo->clause,
-					 pathkey->pk_opfamily,
-					 pathkey->pk_strategy,
-					 pathkey->pk_nulls_first,
-					 &leftstartsel,
-					 &leftendsel,
-					 &rightstartsel,
-					 &rightendsel);
+	mergejoinscansel(root, (Node *) rinfo->clause, pathkey->pk_opfamily,
+			pathkey->pk_strategy, pathkey->pk_nulls_first, &leftstartsel,
+			&leftendsel, &rightstartsel, &rightendsel);
 
 	/* Cache the result in suitably long-lived workspace */
 	oldcontext = MemoryContextSwitchTo(root->planner_cxt);
@@ -2407,27 +2392,32 @@ cached_scansel(PlannerInfo *root, RestrictInfo *rinfo, PathKey *pathkey)
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if jointype is SEMI or ANTI
  */
-void
-initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
-					  JoinType jointype,
-					  List *hashclauses,
-					  Path *outer_path, Path *inner_path,
-					  SpecialJoinInfo *sjinfo,
-					  SemiAntiJoinFactors *semifactors)
-{
-	Cost		startup_cost = 0;
-	Cost		run_cost = 0;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	int			num_hashclauses = list_length(hashclauses);
-	int			numbuckets;
-	int			numbatches;
-	int			num_skew_mcvs;
+void initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
+		JoinType jointype, List *hashclauses, Path *outer_path,
+		Path *inner_path, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+
+	Cost startup_cost = 0;
+	Cost run_cost = 0;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	int num_hashclauses = list_length(hashclauses);
+	int numbuckets;
+	int numbatches;
+	int num_skew_mcvs;
+
+	workspace->semifactors = semifactors;
 
 	/* cost of source data */
-	startup_cost += outer_path->startup_cost;
-	run_cost += outer_path->total_cost - outer_path->startup_cost;
-	startup_cost += inner_path->total_cost;
+	if (mode_cost_check) {
+		startup_cost += outer_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		startup_cost += inner_path->total_cost;
+	} else {
+		startup_cost += outer_path->mstartup_cost;
+		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
+		startup_cost += inner_path->mtotal_cost;
+	}
 
 	/*
 	 * Cost of computing hash function: must do it once per input tuple. We
@@ -2440,7 +2430,7 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * appropriate, here.  This seems more work than it's worth at the moment.
 	 */
 	startup_cost += (cpu_operator_cost * num_hashclauses + cpu_tuple_cost)
-		* inner_path_rows;
+			* inner_path_rows;
 	run_cost += cpu_operator_cost * num_hashclauses * outer_path_rows;
 
 	/*
@@ -2453,12 +2443,8 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * XXX at some point it might be interesting to try to account for skew
 	 * optimization in the cost estimate, but for now, we don't.
 	 */
-	ExecChooseHashTableSize(inner_path_rows,
-							inner_path->parent->width,
-							true,		/* useskew */
-							&numbuckets,
-							&numbatches,
-							&num_skew_mcvs);
+	ExecChooseHashTableSize(inner_path_rows, inner_path->parent->width, true, /* useskew */
+	&numbuckets, &numbatches, &num_skew_mcvs);
 
 	/*
 	 * If inner relation is too big then we will need to "batch" the join,
@@ -2467,12 +2453,11 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * sequential.	Writing the inner rel counts as startup cost, all the rest
 	 * as run cost.
 	 */
-	if (numbatches > 1)
-	{
-		double		outerpages = page_size(outer_path_rows,
-										   outer_path->parent->width);
-		double		innerpages = page_size(inner_path_rows,
-										   inner_path->parent->width);
+	if (numbatches > 1) {
+		double outerpages = page_size(outer_path_rows,
+				outer_path->parent->width);
+		double innerpages = page_size(inner_path_rows,
+				inner_path->parent->width);
 
 		startup_cost += seq_page_cost * innerpages;
 		run_cost += seq_page_cost * (innerpages + 2 * outerpages);
@@ -2501,31 +2486,36 @@ initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
  * 'sjinfo' is extra info about the join for selectivity estimation
  * 'semifactors' contains valid data if path->jointype is SEMI or ANTI
  */
-void
-final_cost_hashjoin(PlannerInfo *root, HashPath *path,
-					JoinCostWorkspace *workspace,
-					SpecialJoinInfo *sjinfo,
-					SemiAntiJoinFactors *semifactors)
-{
-	Path	   *outer_path = path->jpath.outerjoinpath;
-	Path	   *inner_path = path->jpath.innerjoinpath;
-	double		outer_path_rows = outer_path->rows;
-	double		inner_path_rows = inner_path->rows;
-	List	   *hashclauses = path->path_hashclauses;
-	Cost		startup_cost = workspace->startup_cost;
-	Cost		run_cost = workspace->run_cost;
-	int			numbuckets = workspace->numbuckets;
-	int			numbatches = workspace->numbatches;
-	Cost		cpu_per_tuple;
-	QualCost	hash_qual_cost;
-	QualCost	qp_qual_cost;
-	double		hashjointuples;
-	double		virtualbuckets;
+void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors) {
+	Path *outer_path = path->jpath.outerjoinpath;
+	Path *inner_path = path->jpath.innerjoinpath;
+	double outer_path_rows = outer_path->rows;
+	double inner_path_rows = inner_path->rows;
+	List *hashclauses = path->path_hashclauses;
+	Cost startup_cost = workspace->startup_cost;
+	Cost run_cost = workspace->run_cost;
+	int numbuckets = workspace->numbuckets;
+	int numbatches = workspace->numbatches;
+	Cost cpu_per_tuple;
+	QualCost hash_qual_cost;
+	QualCost qp_qual_cost;
+	double hashjointuples;
+	double virtualbuckets;
 	Selectivity innerbucketsize;
-	ListCell   *hcl;
+	ListCell *hcl;
+	path->jpath.path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (path->jpath.path.param_info)
+	if (mode_cost_check) {
+		path->jpath.path.rows = get_join_memo_size(
+				path->jpath.path.parent->rel_name, root->query_level);
+		if (path->jpath.path.rows >= 0) {
+			path->jpath.path.memo_checked = true;
+
+		}
+	} else if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2542,7 +2532,7 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	path->num_batches = numbatches;
 
 	/* and compute the number of "virtual" buckets in the whole join */
-	virtualbuckets = (double) numbuckets *(double) numbatches;
+	virtualbuckets = (double) numbuckets * (double) numbatches;
 
 	/*
 	 * Determine bucketsize fraction for inner relation.  We use the smallest
@@ -2556,11 +2546,9 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	 */
 	if (IsA(inner_path, UniquePath))
 		innerbucketsize = 1.0 / virtualbuckets;
-	else
-	{
+	else {
 		innerbucketsize = 1.0;
-		foreach(hcl, hashclauses)
-		{
+		foreach(hcl, hashclauses) {
 			RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(hcl);
 			Selectivity thisbucketsize;
 
@@ -2575,33 +2563,24 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 			 * RestrictInfo node to avoid repeated lookups of statistics.
 			 */
 			if (bms_is_subset(restrictinfo->right_relids,
-							  inner_path->parent->relids))
-			{
+					inner_path->parent->relids)) {
 				/* righthand side is inner */
 				thisbucketsize = restrictinfo->right_bucketsize;
-				if (thisbucketsize < 0)
-				{
+				if (thisbucketsize < 0) {
 					/* not cached yet */
-					thisbucketsize =
-						estimate_hash_bucketsize(root,
-										   get_rightop(restrictinfo->clause),
-												 virtualbuckets);
+					thisbucketsize = estimate_hash_bucketsize(root,
+							get_rightop(restrictinfo->clause), virtualbuckets);
 					restrictinfo->right_bucketsize = thisbucketsize;
 				}
-			}
-			else
-			{
-				Assert(bms_is_subset(restrictinfo->left_relids,
-									 inner_path->parent->relids));
+			} else {
+				Assert(
+						bms_is_subset(restrictinfo->left_relids, inner_path->parent->relids));
 				/* lefthand side is inner */
 				thisbucketsize = restrictinfo->left_bucketsize;
-				if (thisbucketsize < 0)
-				{
+				if (thisbucketsize < 0) {
 					/* not cached yet */
-					thisbucketsize =
-						estimate_hash_bucketsize(root,
-											get_leftop(restrictinfo->clause),
-												 virtualbuckets);
+					thisbucketsize = estimate_hash_bucketsize(root,
+							get_leftop(restrictinfo->clause), virtualbuckets);
 					restrictinfo->left_bucketsize = thisbucketsize;
 				}
 			}
@@ -2622,9 +2601,9 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 
 	/* CPU costs */
 
-	if (path->jpath.jointype == JOIN_SEMI || path->jpath.jointype == JOIN_ANTI)
-	{
-		double		outer_matched_rows;
+	if (path->jpath.jointype == JOIN_SEMI
+			|| path->jpath.jointype == JOIN_ANTI) {
+		double outer_matched_rows;
 		Selectivity inner_scan_frac;
 
 		/*
@@ -2638,12 +2617,15 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * to clamp inner_scan_frac to at most 1.0; but since match_count is
 		 * at least 1, no such clamp is needed now.)
 		 */
-		outer_matched_rows = rint(outer_path_rows * semifactors->outer_match_frac);
+		outer_matched_rows = rint(
+				outer_path_rows * semifactors->outer_match_frac);
 		inner_scan_frac = 2.0 / (semifactors->match_count + 1.0);
 
 		startup_cost += hash_qual_cost.startup;
-		run_cost += hash_qual_cost.per_tuple * outer_matched_rows *
-			clamp_row_est(inner_path_rows * innerbucketsize * inner_scan_frac) * 0.5;
+		run_cost += hash_qual_cost.per_tuple * outer_matched_rows
+				* clamp_row_est(
+						inner_path_rows * innerbucketsize * inner_scan_frac)
+				* 0.5;
 
 		/*
 		 * For unmatched outer-rel rows, the picture is quite a lot different.
@@ -2658,18 +2640,16 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * effective cost per bucket entry is one-tenth what it is for
 		 * matchable tuples.
 		 */
-		run_cost += hash_qual_cost.per_tuple *
-			(outer_path_rows - outer_matched_rows) *
-			clamp_row_est(inner_path_rows / virtualbuckets) * 0.05;
+		run_cost += hash_qual_cost.per_tuple
+				* (outer_path_rows - outer_matched_rows)
+				* clamp_row_est(inner_path_rows / virtualbuckets) * 0.05;
 
 		/* Get # of tuples that will pass the basic join */
 		if (path->jpath.jointype == JOIN_SEMI)
 			hashjointuples = outer_matched_rows;
 		else
 			hashjointuples = outer_path_rows - outer_matched_rows;
-	}
-	else
-	{
+	} else {
 		/*
 		 * The number of tuple comparisons needed is the number of outer
 		 * tuples times the typical number of tuples in a hash bucket, which
@@ -2681,8 +2661,8 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * allow for that.
 		 */
 		startup_cost += hash_qual_cost.startup;
-		run_cost += hash_qual_cost.per_tuple * outer_path_rows *
-			clamp_row_est(inner_path_rows * innerbucketsize) * 0.5;
+		run_cost += hash_qual_cost.per_tuple * outer_path_rows
+				* clamp_row_est(inner_path_rows * innerbucketsize) * 0.5;
 
 		/*
 		 * Get approx # tuples passing the hashquals.  We use
@@ -2701,12 +2681,16 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * hashjointuples;
+	if (mode_cost_check) {
+		path->jpath.path.mstartup_cost = startup_cost;
+		path->jpath.path.mtotal_cost = startup_cost + run_cost;
 
-	path->jpath.path.startup_cost = startup_cost;
-	path->jpath.path.total_cost = startup_cost + run_cost;
+	} else {
+		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.total_cost = startup_cost + run_cost;
+	}
 }
 
-
 /*
  * cost_subplan
  *		Figure the costs for a SubPlan (or initplan).
@@ -2714,26 +2698,22 @@ final_cost_hashjoin(PlannerInfo *root, HashPath *path,
  * Note: we could dig the subplan's Plan out of the root list, but in practice
  * all callers have it handy already, so we make them pass it.
  */
-void
-cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
-{
-	QualCost	sp_cost;
+void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan) {
+	QualCost sp_cost;
 
 	/* Figure any cost for evaluating the testexpr */
-	cost_qual_eval(&sp_cost,
-				   make_ands_implicit((Expr *) subplan->testexpr),
-				   root);
+	cost_qual_eval(&sp_cost, make_ands_implicit((Expr *) subplan->testexpr),
+			root);
 
-	if (subplan->useHashTable)
-	{
+	if (subplan->useHashTable) {
 		/*
 		 * If we are using a hash table for the subquery outputs, then the
 		 * cost of evaluating the query is a one-time cost.  We charge one
 		 * cpu_operator_cost per tuple for the work of loading the hashtable,
 		 * too.
 		 */
-		sp_cost.startup += plan->total_cost +
-			cpu_operator_cost * plan->plan_rows;
+		sp_cost.startup += plan->total_cost
+				+ cpu_operator_cost * plan->plan_rows;
 
 		/*
 		 * The per-tuple costs include the cost of evaluating the lefthand
@@ -2743,9 +2723,7 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * operator.  That is probably too low for the probing cost, but it's
 		 * hard to make a better estimate, so live with it for now.
 		 */
-	}
-	else
-	{
+	} else {
 		/*
 		 * Otherwise we will be rescanning the subplan output on each
 		 * evaluation.	We need to estimate how much of the output we will
@@ -2753,23 +2731,18 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * tuple_fraction estimates used by make_subplan() in
 		 * plan/subselect.c.
 		 */
-		Cost		plan_run_cost = plan->total_cost - plan->startup_cost;
+		Cost plan_run_cost = plan->total_cost - plan->startup_cost;
 
-		if (subplan->subLinkType == EXISTS_SUBLINK)
-		{
+		if (subplan->subLinkType == EXISTS_SUBLINK) {
 			/* we only need to fetch 1 tuple */
 			sp_cost.per_tuple += plan_run_cost / plan->plan_rows;
-		}
-		else if (subplan->subLinkType == ALL_SUBLINK ||
-				 subplan->subLinkType == ANY_SUBLINK)
-		{
+		} else if (subplan->subLinkType == ALL_SUBLINK
+				|| subplan->subLinkType == ANY_SUBLINK) {
 			/* assume we need 50% of the tuples */
 			sp_cost.per_tuple += 0.50 * plan_run_cost;
 			/* also charge a cpu_operator_cost per row examined */
 			sp_cost.per_tuple += 0.50 * plan->plan_rows * cpu_operator_cost;
-		}
-		else
-		{
+		} else {
 			/* assume we need all tuples */
 			sp_cost.per_tuple += plan_run_cost;
 		}
@@ -2781,8 +2754,7 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 		 * its startup cost once; otherwise assume we pay the startup cost
 		 * every time.
 		 */
-		if (subplan->parParam == NIL &&
-			ExecMaterializesOutput(nodeTag(plan)))
+		if (subplan->parParam == NIL && ExecMaterializesOutput(nodeTag(plan)))
 			sp_cost.startup += plan->startup_cost;
 		else
 			sp_cost.per_tuple += plan->startup_cost;
@@ -2792,7 +2764,6 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
 	subplan->per_call_cost = sp_cost.per_tuple;
 }
 
-
 /*
  * cost_rescan
  *		Given a finished Path, estimate the costs of rescanning it after
@@ -2807,94 +2778,98 @@ cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan)
  * plan types wherein the executor caches results explicitly, or doesn't
  * redo startup calculations, etc.
  */
-static void
-cost_rescan(PlannerInfo *root, Path *path,
-			Cost *rescan_startup_cost,	/* output parameters */
-			Cost *rescan_total_cost)
-{
-	switch (path->pathtype)
-	{
-		case T_FunctionScan:
+static void cost_rescan(PlannerInfo *root, Path *path,
+		Cost *rescan_startup_cost, /* output parameters */
+		Cost *rescan_total_cost) {
+	switch (path->pathtype) {
+	case T_FunctionScan:
 
-			/*
-			 * Currently, nodeFunctionscan.c always executes the function to
-			 * completion before returning any rows, and caches the results in
-			 * a tuplestore.  So the function eval cost is all startup cost
-			 * and isn't paid over again on rescans. However, all run costs
-			 * will be paid over again.
-			 */
-			*rescan_startup_cost = 0;
+		/*
+		 * Currently, nodeFunctionscan.c always executes the function to
+		 * completion before returning any rows, and caches the results in
+		 * a tuplestore.  So the function eval cost is all startup cost
+		 * and isn't paid over again on rescans. However, all run costs
+		 * will be paid over again.
+		 */
+		*rescan_startup_cost = 0;
+		if (mode_cost_check) {
+			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
+		} else {
 			*rescan_total_cost = path->total_cost - path->startup_cost;
-			break;
-		case T_HashJoin:
+		}
+		break;
+	case T_HashJoin:
 
-			/*
-			 * Assume that all of the startup cost represents hash table
-			 * building, which we won't have to do over.
-			 */
-			*rescan_startup_cost = 0;
+		/*
+		 * Assume that all of the startup cost represents hash table
+		 * building, which we won't have to do over.
+		 */
+		*rescan_startup_cost = 0;
+		if (mode_cost_check) {
+			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
+		} else {
 			*rescan_total_cost = path->total_cost - path->startup_cost;
-			break;
-		case T_CteScan:
-		case T_WorkTableScan:
-			{
-				/*
-				 * These plan types materialize their final result in a
-				 * tuplestore or tuplesort object.	So the rescan cost is only
-				 * cpu_tuple_cost per tuple, unless the result is large enough
-				 * to spill to disk.
-				 */
-				Cost		run_cost = cpu_tuple_cost * path->rows;
-				double		nbytes = relation_byte_size(path->rows,
-														path->parent->width);
-				long		work_mem_bytes = work_mem * 1024L;
-
-				if (nbytes > work_mem_bytes)
-				{
-					/* It will spill, so account for re-read cost */
-					double		npages = ceil(nbytes / BLCKSZ);
-
-					run_cost += seq_page_cost * npages;
-				}
-				*rescan_startup_cost = 0;
-				*rescan_total_cost = run_cost;
-			}
-			break;
-		case T_Material:
-		case T_Sort:
-			{
-				/*
-				 * These plan types not only materialize their results, but do
-				 * not implement qual filtering or projection.	So they are
-				 * even cheaper to rescan than the ones above.	We charge only
-				 * cpu_operator_cost per tuple.  (Note: keep that in sync with
-				 * the run_cost charge in cost_sort, and also see comments in
-				 * cost_material before you change it.)
-				 */
-				Cost		run_cost = cpu_operator_cost * path->rows;
-				double		nbytes = relation_byte_size(path->rows,
-														path->parent->width);
-				long		work_mem_bytes = work_mem * 1024L;
-
-				if (nbytes > work_mem_bytes)
-				{
-					/* It will spill, so account for re-read cost */
-					double		npages = ceil(nbytes / BLCKSZ);
-
-					run_cost += seq_page_cost * npages;
-				}
-				*rescan_startup_cost = 0;
-				*rescan_total_cost = run_cost;
-			}
-			break;
-		default:
+		}
+		break;
+	case T_CteScan:
+	case T_WorkTableScan: {
+		/*
+		 * These plan types materialize their final result in a
+		 * tuplestore or tuplesort object.	So the rescan cost is only
+		 * cpu_tuple_cost per tuple, unless the result is large enough
+		 * to spill to disk.
+		 */
+		Cost run_cost = cpu_tuple_cost * path->rows;
+		double nbytes = relation_byte_size(path->rows, path->parent->width);
+		long work_mem_bytes = work_mem * 1024L;
+
+		if (nbytes > work_mem_bytes) {
+			/* It will spill, so account for re-read cost */
+			double npages = ceil(nbytes / BLCKSZ);
+
+			run_cost += seq_page_cost * npages;
+		}
+		*rescan_startup_cost = 0;
+		*rescan_total_cost = run_cost;
+	}
+		break;
+	case T_Material:
+	case T_Sort: {
+		/*
+		 * These plan types not only materialize their results, but do
+		 * not implement qual filtering or projection.	So they are
+		 * even cheaper to rescan than the ones above.	We charge only
+		 * cpu_operator_cost per tuple.  (Note: keep that in sync with
+		 * the run_cost charge in cost_sort, and also see comments in
+		 * cost_material before you change it.)
+		 */
+		Cost run_cost = cpu_operator_cost * path->rows;
+		double nbytes = relation_byte_size(path->rows, path->parent->width);
+		long work_mem_bytes = work_mem * 1024L;
+
+		if (nbytes > work_mem_bytes) {
+			/* It will spill, so account for re-read cost */
+			double npages = ceil(nbytes / BLCKSZ);
+
+			run_cost += seq_page_cost * npages;
+		}
+		*rescan_startup_cost = 0;
+		*rescan_total_cost = run_cost;
+	}
+		break;
+	default:
+		if (mode_cost_check) {
+			*rescan_startup_cost = path->mstartup_cost;
+			*rescan_total_cost = path->mtotal_cost;
+		} else {
 			*rescan_startup_cost = path->startup_cost;
 			*rescan_total_cost = path->total_cost;
-			break;
+		}
+
+		break;
 	}
 }
 
-
 /*
  * cost_qual_eval
  *		Estimate the CPU costs of evaluating a WHERE clause.
@@ -2904,11 +2879,9 @@ cost_rescan(PlannerInfo *root, Path *path,
  *		The result includes both a one-time (startup) component,
  *		and a per-evaluation component.
  */
-void
-cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
-{
+void cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root) {
 	cost_qual_eval_context context;
-	ListCell   *l;
+	ListCell *l;
 
 	context.root = root;
 	context.total.startup = 0;
@@ -2916,9 +2889,8 @@ cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
 
 	/* We don't charge any cost for the implicit ANDing at top level ... */
 
-	foreach(l, quals)
-	{
-		Node	   *qual = (Node *) lfirst(l);
+	foreach(l, quals) {
+		Node *qual = (Node *) lfirst(l);
 
 		cost_qual_eval_walker(qual, &context);
 	}
@@ -2930,9 +2902,7 @@ cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root)
  * cost_qual_eval_node
  *		As above, for a single RestrictInfo or expression.
  */
-void
-cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root)
-{
+void cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root) {
 	cost_qual_eval_context context;
 
 	context.root = root;
@@ -2944,9 +2914,7 @@ cost_qual_eval_node(QualCost *cost, Node *qual, PlannerInfo *root)
 	*cost = context.total;
 }
 
-static bool
-cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
-{
+static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context) {
 	if (node == NULL)
 		return false;
 
@@ -2956,12 +2924,10 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 	 * cost more than once.  If the clause's cost hasn't been computed yet,
 	 * the field's startup value will contain -1.
 	 */
-	if (IsA(node, RestrictInfo))
-	{
+	if (IsA(node, RestrictInfo)) {
 		RestrictInfo *rinfo = (RestrictInfo *) node;
 
-		if (rinfo->eval_cost.startup < 0)
-		{
+		if (rinfo->eval_cost.startup < 0) {
 			cost_qual_eval_context locContext;
 
 			locContext.root = context->root;
@@ -2981,8 +2947,7 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 			 * If the RestrictInfo is marked pseudoconstant, it will be tested
 			 * only once, so treat its cost as all startup cost.
 			 */
-			if (rinfo->pseudoconstant)
-			{
+			if (rinfo->pseudoconstant) {
 				/* count one execution during startup */
 				locContext.total.startup += locContext.total.per_tuple;
 				locContext.total.per_tuple = 0;
@@ -3017,36 +2982,27 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 	 * moreover, since our rowcount estimates for functions tend to be pretty
 	 * phony, the results would also be pretty phony.
 	 */
-	if (IsA(node, FuncExpr))
-	{
-		context->total.per_tuple +=
-			get_func_cost(((FuncExpr *) node)->funcid) * cpu_operator_cost;
-	}
-	else if (IsA(node, OpExpr) ||
-			 IsA(node, DistinctExpr) ||
-			 IsA(node, NullIfExpr))
-	{
+	if (IsA(node, FuncExpr)) {
+		context->total.per_tuple += get_func_cost(((FuncExpr *) node)->funcid)
+				* cpu_operator_cost;
+	} else if (IsA(node, OpExpr) || IsA(node, DistinctExpr)
+			|| IsA(node, NullIfExpr)) {
 		/* rely on struct equivalence to treat these all alike */
 		set_opfuncid((OpExpr *) node);
-		context->total.per_tuple +=
-			get_func_cost(((OpExpr *) node)->opfuncid) * cpu_operator_cost;
-	}
-	else if (IsA(node, ScalarArrayOpExpr))
-	{
+		context->total.per_tuple += get_func_cost(((OpExpr *) node)->opfuncid)
+				* cpu_operator_cost;
+	} else if (IsA(node, ScalarArrayOpExpr)) {
 		/*
 		 * Estimate that the operator will be applied to about half of the
 		 * array elements before the answer is determined.
 		 */
 		ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) node;
-		Node	   *arraynode = (Node *) lsecond(saop->args);
+		Node *arraynode = (Node *) lsecond(saop->args);
 
 		set_sa_opfuncid(saop);
-		context->total.per_tuple += get_func_cost(saop->opfuncid) *
-			cpu_operator_cost * estimate_array_length(arraynode) * 0.5;
-	}
-	else if (IsA(node, Aggref) ||
-			 IsA(node, WindowFunc))
-	{
+		context->total.per_tuple += get_func_cost(saop->opfuncid)
+				* cpu_operator_cost * estimate_array_length(arraynode) * 0.5;
+	} else if (IsA(node, Aggref) || IsA(node, WindowFunc)) {
 		/*
 		 * Aggref and WindowFunc nodes are (and should be) treated like Vars,
 		 * ie, zero execution cost in the current model, because they behave
@@ -3056,66 +3012,52 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		 * be factored into plan-node-specific costing of the Agg or WindowAgg
 		 * plan node.
 		 */
-		return false;			/* don't recurse into children */
-	}
-	else if (IsA(node, CoerceViaIO))
-	{
+		return false; /* don't recurse into children */
+	} else if (IsA(node, CoerceViaIO)) {
 		CoerceViaIO *iocoerce = (CoerceViaIO *) node;
-		Oid			iofunc;
-		Oid			typioparam;
-		bool		typisvarlena;
+		Oid iofunc;
+		Oid typioparam;
+		bool typisvarlena;
 
 		/* check the result type's input function */
-		getTypeInputInfo(iocoerce->resulttype,
-						 &iofunc, &typioparam);
+		getTypeInputInfo(iocoerce->resulttype, &iofunc, &typioparam);
 		context->total.per_tuple += get_func_cost(iofunc) * cpu_operator_cost;
 		/* check the input type's output function */
-		getTypeOutputInfo(exprType((Node *) iocoerce->arg),
-						  &iofunc, &typisvarlena);
+		getTypeOutputInfo(exprType((Node *) iocoerce->arg), &iofunc,
+				&typisvarlena);
 		context->total.per_tuple += get_func_cost(iofunc) * cpu_operator_cost;
-	}
-	else if (IsA(node, ArrayCoerceExpr))
-	{
+	} else if (IsA(node, ArrayCoerceExpr)) {
 		ArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;
-		Node	   *arraynode = (Node *) acoerce->arg;
+		Node *arraynode = (Node *) acoerce->arg;
 
 		if (OidIsValid(acoerce->elemfuncid))
-			context->total.per_tuple += get_func_cost(acoerce->elemfuncid) *
-				cpu_operator_cost * estimate_array_length(arraynode);
-	}
-	else if (IsA(node, RowCompareExpr))
-	{
+			context->total.per_tuple += get_func_cost(acoerce->elemfuncid)
+					* cpu_operator_cost * estimate_array_length(arraynode);
+	} else if (IsA(node, RowCompareExpr)) {
 		/* Conservatively assume we will check all the columns */
 		RowCompareExpr *rcexpr = (RowCompareExpr *) node;
-		ListCell   *lc;
+		ListCell *lc;
 
-		foreach(lc, rcexpr->opnos)
-		{
-			Oid			opid = lfirst_oid(lc);
+		foreach(lc, rcexpr->opnos) {
+			Oid opid = lfirst_oid(lc);
 
-			context->total.per_tuple += get_func_cost(get_opcode(opid)) *
-				cpu_operator_cost;
+			context->total.per_tuple += get_func_cost(get_opcode(opid))
+					* cpu_operator_cost;
 		}
-	}
-	else if (IsA(node, CurrentOfExpr))
-	{
+	} else if (IsA(node, CurrentOfExpr)) {
 		/* Report high cost to prevent selection of anything but TID scan */
 		context->total.startup += disable_cost;
-	}
-	else if (IsA(node, SubLink))
-	{
+	} else if (IsA(node, SubLink)) {
 		/* This routine should not be applied to un-planned expressions */
 		elog(ERROR, "cannot handle unplanned sub-select");
-	}
-	else if (IsA(node, SubPlan))
-	{
+	} else if (IsA(node, SubPlan)) {
 		/*
 		 * A subplan node in an expression typically indicates that the
 		 * subplan will be executed on each evaluation, so charge accordingly.
 		 * (Sub-selects that can be executed as InitPlans have already been
 		 * removed from the expression.)
 		 */
-		SubPlan    *subplan = (SubPlan *) node;
+		SubPlan *subplan = (SubPlan *) node;
 
 		context->total.startup += subplan->startup_cost;
 		context->total.per_tuple += subplan->per_call_cost;
@@ -3125,9 +3067,7 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		 * counted in the SubPlan node's costs.  So we're done.
 		 */
 		return false;
-	}
-	else if (IsA(node, AlternativeSubPlan))
-	{
+	} else if (IsA(node, AlternativeSubPlan)) {
 		/*
 		 * Arbitrarily use the first alternative plan for costing.	(We should
 		 * certainly only include one alternative, and we don't yet have
@@ -3137,12 +3077,11 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
 		AlternativeSubPlan *asplan = (AlternativeSubPlan *) node;
 
 		return cost_qual_eval_walker((Node *) linitial(asplan->subplans),
-									 context);
+				context);
 	}
 
 	/* recurse into children */
-	return expression_tree_walker(node, cost_qual_eval_walker,
-								  (void *) context);
+	return expression_tree_walker(node, cost_qual_eval_walker, (void *) context);
 }
 
 /*
@@ -3157,24 +3096,18 @@ cost_qual_eval_walker(Node *node, cost_qual_eval_context *context)
  * some of the quals.  We assume baserestrictcost was previously set by
  * set_baserel_size_estimates().
  */
-static void
-get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
-						  ParamPathInfo *param_info,
-						  QualCost *qpqual_cost)
-{
-	if (param_info)
-	{
+static void get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
+		ParamPathInfo *param_info, QualCost *qpqual_cost) {
+	if (param_info) {
 		/* Include costs of pushed-down clauses */
 		cost_qual_eval(qpqual_cost, param_info->ppi_clauses, root);
 
 		qpqual_cost->startup += baserel->baserestrictcost.startup;
 		qpqual_cost->per_tuple += baserel->baserestrictcost.per_tuple;
-	}
-	else
+	} else
 		*qpqual_cost = baserel->baserestrictcost;
 }
 
-
 /*
  * compute_semi_anti_join_factors
  *	  Estimate how much of the inner input a SEMI or ANTI join
@@ -3197,21 +3130,15 @@ get_restriction_qual_cost(PlannerInfo *root, RelOptInfo *baserel,
  * Output parameters:
  *	*semifactors is filled in (see relation.h for field definitions)
  */
-void
-compute_semi_anti_join_factors(PlannerInfo *root,
-							   RelOptInfo *outerrel,
-							   RelOptInfo *innerrel,
-							   JoinType jointype,
-							   SpecialJoinInfo *sjinfo,
-							   List *restrictlist,
-							   SemiAntiJoinFactors *semifactors)
-{
+void compute_semi_anti_join_factors(PlannerInfo *root, RelOptInfo *outerrel,
+		RelOptInfo *innerrel, JoinType jointype, SpecialJoinInfo *sjinfo,
+		List *restrictlist, SemiAntiJoinFactors *semifactors) {
 	Selectivity jselec;
 	Selectivity nselec;
 	Selectivity avgmatch;
 	SpecialJoinInfo norm_sjinfo;
-	List	   *joinquals;
-	ListCell   *l;
+	List *joinquals;
+	ListCell *l;
 
 	/* Should only be called in these cases */
 	Assert(jointype == JOIN_SEMI || jointype == JOIN_ANTI);
@@ -3222,29 +3149,22 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	 * distinguish joinquals from "pushed down" quals, so just use the whole
 	 * restrictinfo list.
 	 */
-	if (jointype == JOIN_ANTI)
-	{
+	if (jointype == JOIN_ANTI) {
 		joinquals = NIL;
-		foreach(l, restrictlist)
-		{
+		foreach(l, restrictlist) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			Assert(IsA(rinfo, RestrictInfo));
 			if (!rinfo->is_pushed_down)
 				joinquals = lappend(joinquals, rinfo);
 		}
-	}
-	else
+	} else
 		joinquals = restrictlist;
 
 	/*
 	 * Get the JOIN_SEMI or JOIN_ANTI selectivity of the join clauses.
 	 */
-	jselec = clauselist_selectivity(root,
-									joinquals,
-									0,
-									jointype,
-									sjinfo);
+	jselec = clauselist_selectivity(root, joinquals, 0, jointype, sjinfo);
 
 	/*
 	 * Also get the normal inner-join selectivity of the join clauses.
@@ -3260,11 +3180,8 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	norm_sjinfo.delay_upper_joins = false;
 	norm_sjinfo.join_quals = NIL;
 
-	nselec = clauselist_selectivity(root,
-									joinquals,
-									0,
-									JOIN_INNER,
-									&norm_sjinfo);
+	nselec = clauselist_selectivity(root, joinquals, 0, JOIN_INNER,
+			&norm_sjinfo);
 
 	/* Avoid leaking a lot of ListCells */
 	if (jointype == JOIN_ANTI)
@@ -3282,13 +3199,12 @@ compute_semi_anti_join_factors(PlannerInfo *root,
 	 * fewer rows.	This is because we have included all the join clauses in
 	 * the selectivity estimate.
 	 */
-	if (jselec > 0)				/* protect against zero divide */
+	if (jselec > 0) /* protect against zero divide */
 	{
 		avgmatch = nselec * innerrel->rows / jselec;
 		/* Clamp to sane range */
 		avgmatch = Max(1.0, avgmatch);
-	}
-	else
+	} else
 		avgmatch = 1.0;
 
 	semifactors->outer_match_frac = jselec;
@@ -3305,14 +3221,12 @@ compute_semi_anti_join_factors(PlannerInfo *root,
  * unmatched outer tuple is cheap to process, whereas otherwise it's probably
  * expensive.
  */
-static bool
-has_indexed_join_quals(NestPath *joinpath)
-{
-	Relids		joinrelids = joinpath->path.parent->relids;
-	Path	   *innerpath = joinpath->innerjoinpath;
-	List	   *indexclauses;
-	bool		found_one;
-	ListCell   *lc;
+static bool has_indexed_join_quals(NestPath *joinpath) {
+	Relids joinrelids = joinpath->path.parent->relids;
+	Path *innerpath = joinpath->innerjoinpath;
+	List *indexclauses;
+	bool found_one;
+	ListCell *lc;
 
 	/* If join still has quals to evaluate, it's not fast */
 	if (joinpath->joinrestrictinfo != NIL)
@@ -3322,31 +3236,29 @@ has_indexed_join_quals(NestPath *joinpath)
 		return false;
 
 	/* Find the indexclauses list for the inner scan */
-	switch (innerpath->pathtype)
-	{
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-			indexclauses = ((IndexPath *) innerpath)->indexclauses;
-			break;
-		case T_BitmapHeapScan:
-			{
-				/* Accept only a simple bitmap scan, not AND/OR cases */
-				Path	   *bmqual = ((BitmapHeapPath *) innerpath)->bitmapqual;
-
-				if (IsA(bmqual, IndexPath))
-					indexclauses = ((IndexPath *) bmqual)->indexclauses;
-				else
-					return false;
-				break;
-			}
-		default:
-
-			/*
-			 * If it's not a simple indexscan, it probably doesn't run quickly
-			 * for zero rows out, even if it's a parameterized path using all
-			 * the joinquals.
-			 */
+	switch (innerpath->pathtype) {
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+		indexclauses = ((IndexPath *) innerpath)->indexclauses;
+		break;
+	case T_BitmapHeapScan: {
+		/* Accept only a simple bitmap scan, not AND/OR cases */
+		Path *bmqual = ((BitmapHeapPath *) innerpath)->bitmapqual;
+
+		if (IsA(bmqual, IndexPath))
+			indexclauses = ((IndexPath *) bmqual)->indexclauses;
+		else
 			return false;
+		break;
+	}
+	default:
+
+		/*
+		 * If it's not a simple indexscan, it probably doesn't run quickly
+		 * for zero rows out, even if it's a parameterized path using all
+		 * the joinquals.
+		 */
+		return false;
 	}
 
 	/*
@@ -3356,16 +3268,13 @@ has_indexed_join_quals(NestPath *joinpath)
 	 * one such clause, else it's a clauseless join which isn't fast.
 	 */
 	found_one = false;
-	foreach(lc, innerpath->param_info->ppi_clauses)
-	{
+	foreach(lc, innerpath->param_info->ppi_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										innerpath->parent->relids,
-										joinrelids))
-		{
-			if (!(list_member_ptr(indexclauses, rinfo) ||
-				  is_redundant_derived_clause(rinfo, indexclauses)))
+		if (join_clause_is_movable_into(rinfo, innerpath->parent->relids,
+				joinrelids)) {
+			if (!(list_member_ptr(indexclauses, rinfo)
+					|| is_redundant_derived_clause(rinfo, indexclauses)))
 				return false;
 			found_one = true;
 		}
@@ -3373,7 +3282,6 @@ has_indexed_join_quals(NestPath *joinpath)
 	return found_one;
 }
 
-
 /*
  * approx_tuple_count
  *		Quick-and-dirty estimation of the number of join rows passing
@@ -3398,15 +3306,13 @@ has_indexed_join_quals(NestPath *joinpath)
  * output tuples are generated and passed through qpqual checking, it
  * seems OK to live with the approximation.
  */
-static double
-approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
-{
-	double		tuples;
-	double		outer_tuples = path->outerjoinpath->rows;
-	double		inner_tuples = path->innerjoinpath->rows;
+static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals) {
+	double tuples;
+	double outer_tuples = path->outerjoinpath->rows;
+	double inner_tuples = path->innerjoinpath->rows;
 	SpecialJoinInfo sjinfo;
 	Selectivity selec = 1.0;
-	ListCell   *l;
+	ListCell *l;
 
 	/*
 	 * Make up a SpecialJoinInfo for JOIN_INNER semantics.
@@ -3422,10 +3328,8 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 	sjinfo.delay_upper_joins = false;
 	sjinfo.join_quals = NIL;
 
-	/* Get the approximate selectivity */
-	foreach(l, quals)
-	{
-		Node	   *qual = (Node *) lfirst(l);
+	/* Get the approximate selectivity */foreach(l, quals) {
+		Node *qual = (Node *) lfirst(l);
 
 		/* Note that clause_selectivity will be able to cache its result */
 		selec *= clause_selectivity(root, qual, 0, JOIN_INNER, &sjinfo);
@@ -3437,7 +3341,6 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
 	return clamp_row_est(tuples);
 }
 
-
 /*
  * set_baserel_size_estimates
  *		Set the size estimates for the given base relation.
@@ -3451,22 +3354,20 @@ approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
  *	width: the estimated average output tuple width in bytes.
  *	baserestrictcost: estimated cost of evaluating baserestrictinfo clauses.
  */
-void
-set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
-	double		nrows;
+void set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
+	double nrows;
 
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	nrows = rel->tuples *
-		clauselist_selectivity(root,
-							   rel->baserestrictinfo,
-							   0,
-							   JOIN_INNER,
-							   NULL);
+	//maybe memo hacked
+	if (!enable_memo || rel->rows == -1) {
+		nrows = rel->tuples
+				* clauselist_selectivity(root, rel->baserestrictinfo, 0,
+						JOIN_INNER, NULL);
 
-	rel->rows = clamp_row_est(nrows);
+		rel->rows = clamp_row_est(nrows);
+	}
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
@@ -3481,12 +3382,10 @@ set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * set_baserel_size_estimates must have been applied already.
  */
-double
-get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
-							   List *param_clauses)
-{
-	List	   *allclauses;
-	double		nrows;
+double get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
+		List *param_clauses) {
+	List *allclauses;
+	double nrows;
 
 	/*
 	 * Estimate the number of rows returned by the parameterized scan, knowing
@@ -3494,14 +3393,9 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * restriction clauses.  Note that we force the clauses to be treated as
 	 * non-join clauses during selectivity estimation.
 	 */
-	allclauses = list_concat(list_copy(param_clauses),
-							 rel->baserestrictinfo);
-	nrows = rel->tuples *
-		clauselist_selectivity(root,
-							   allclauses,
-							   rel->relid,		/* do not use 0! */
-							   JOIN_INNER,
-							   NULL);
+	allclauses = list_concat(list_copy(param_clauses), rel->baserestrictinfo);
+	nrows = rel->tuples * clauselist_selectivity(root, allclauses, rel->relid, /* do not use 0! */
+	JOIN_INNER, NULL);
 	nrows = clamp_row_est(nrows);
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
@@ -3531,18 +3425,12 @@ get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
  * We set only the rows field here.  The width field was already set by
  * build_joinrel_tlist, and baserestrictcost is not used for join rels.
  */
-void
-set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist)
-{
-	rel->rows = calc_joinrel_size_estimate(root,
-										   outer_rel->rows,
-										   inner_rel->rows,
-										   sjinfo,
-										   restrictlist);
+void set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo,
+		List *restrictlist) {
+	if (!enable_memo || rel->rows == -1)
+		rel->rows = calc_joinrel_size_estimate(root, outer_rel->rows,
+				inner_rel->rows, sjinfo, restrictlist);
 }
 
 /*
@@ -3560,14 +3448,10 @@ set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
  *
  * set_joinrel_size_estimates must have been applied already.
  */
-double
-get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
-							   double outer_rows,
-							   double inner_rows,
-							   SpecialJoinInfo *sjinfo,
-							   List *restrict_clauses)
-{
-	double		nrows;
+double get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
+		double outer_rows, double inner_rows, SpecialJoinInfo *sjinfo,
+		List *restrict_clauses) {
+	double nrows;
 
 	/*
 	 * Estimate the number of rows returned by the parameterized join as the
@@ -3578,11 +3462,8 @@ get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * on the pair of input paths provided, though ideally we'd get the same
 	 * estimate for any pair with the same parameterization.
 	 */
-	nrows = calc_joinrel_size_estimate(root,
-									   outer_rows,
-									   inner_rows,
-									   sjinfo,
-									   restrict_clauses);
+	nrows = calc_joinrel_size_estimate(root, outer_rows, inner_rows, sjinfo,
+			restrict_clauses);
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
 		nrows = rel->rows;
@@ -3594,17 +3475,12 @@ get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
  *		Workhorse for set_joinrel_size_estimates and
  *		get_parameterized_joinrel_size.
  */
-static double
-calc_joinrel_size_estimate(PlannerInfo *root,
-						   double outer_rows,
-						   double inner_rows,
-						   SpecialJoinInfo *sjinfo,
-						   List *restrictlist)
-{
-	JoinType	jointype = sjinfo->jointype;
+static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
+		double inner_rows, SpecialJoinInfo *sjinfo, List *restrictlist) {
+	JoinType jointype = sjinfo->jointype;
 	Selectivity jselec;
 	Selectivity pselec;
-	double		nrows;
+	double nrows;
 
 	/*
 	 * Compute joinclause selectivity.	Note that we are only considering
@@ -3616,15 +3492,12 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 	 * own clauses (JOIN/ON conditions) from any clauses that were "pushed
 	 * down".  For inner joins we just count them all as joinclauses.
 	 */
-	if (IS_OUTER_JOIN(jointype))
-	{
-		List	   *joinquals = NIL;
-		List	   *pushedquals = NIL;
-		ListCell   *l;
+	if (IS_OUTER_JOIN(jointype)) {
+		List *joinquals = NIL;
+		List *pushedquals = NIL;
+		ListCell *l;
 
-		/* Grovel through the clauses to separate into two lists */
-		foreach(l, restrictlist)
-		{
+		/* Grovel through the clauses to separate into two lists */foreach(l, restrictlist) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			Assert(IsA(rinfo, RestrictInfo));
@@ -3635,29 +3508,16 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 		}
 
 		/* Get the separate selectivities */
-		jselec = clauselist_selectivity(root,
-										joinquals,
-										0,
-										jointype,
-										sjinfo);
-		pselec = clauselist_selectivity(root,
-										pushedquals,
-										0,
-										jointype,
-										sjinfo);
+		jselec = clauselist_selectivity(root, joinquals, 0, jointype, sjinfo);
+		pselec = clauselist_selectivity(root, pushedquals, 0, jointype, sjinfo);
 
 		/* Avoid leaking a lot of ListCells */
 		list_free(joinquals);
 		list_free(pushedquals);
-	}
-	else
-	{
-		jselec = clauselist_selectivity(root,
-										restrictlist,
-										0,
-										jointype,
-										sjinfo);
-		pselec = 0.0;			/* not used, keep compiler quiet */
+	} else {
+		jselec = clauselist_selectivity(root, restrictlist, 0, jointype,
+				sjinfo);
+		pselec = 0.0; /* not used, keep compiler quiet */
 	}
 
 	/*
@@ -3672,38 +3532,37 @@ calc_joinrel_size_estimate(PlannerInfo *root,
 	 * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the fraction
 	 * of LHS rows that have matches, and we apply that straightforwardly.
 	 */
-	switch (jointype)
-	{
-		case JOIN_INNER:
-			nrows = outer_rows * inner_rows * jselec;
-			break;
-		case JOIN_LEFT:
-			nrows = outer_rows * inner_rows * jselec;
-			if (nrows < outer_rows)
-				nrows = outer_rows;
-			nrows *= pselec;
-			break;
-		case JOIN_FULL:
-			nrows = outer_rows * inner_rows * jselec;
-			if (nrows < outer_rows)
-				nrows = outer_rows;
-			if (nrows < inner_rows)
-				nrows = inner_rows;
-			nrows *= pselec;
-			break;
-		case JOIN_SEMI:
-			nrows = outer_rows * jselec;
-			/* pselec not used */
-			break;
-		case JOIN_ANTI:
-			nrows = outer_rows * (1.0 - jselec);
-			nrows *= pselec;
-			break;
-		default:
-			/* other values not expected here */
-			elog(ERROR, "unrecognized join type: %d", (int) jointype);
-			nrows = 0;			/* keep compiler quiet */
-			break;
+	switch (jointype) {
+	case JOIN_INNER:
+		nrows = outer_rows * inner_rows * jselec;
+		break;
+	case JOIN_LEFT:
+		nrows = outer_rows * inner_rows * jselec;
+		if (nrows < outer_rows)
+			nrows = outer_rows;
+		nrows *= pselec;
+		break;
+	case JOIN_FULL:
+		nrows = outer_rows * inner_rows * jselec;
+		if (nrows < outer_rows)
+			nrows = outer_rows;
+		if (nrows < inner_rows)
+			nrows = inner_rows;
+		nrows *= pselec;
+		break;
+	case JOIN_SEMI:
+		nrows = outer_rows * jselec;
+		/* pselec not used */
+		break;
+	case JOIN_ANTI:
+		nrows = outer_rows * (1.0 - jselec);
+		nrows *= pselec;
+		break;
+	default:
+		/* other values not expected here */
+		elog(ERROR, "unrecognized join type: %d", (int ) jointype);
+		nrows = 0; /* keep compiler quiet */
+		break;
 	}
 
 	return clamp_row_est(nrows);
@@ -3719,12 +3578,10 @@ calc_joinrel_size_estimate(PlannerInfo *root,
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	PlannerInfo *subroot = rel->subroot;
 	RangeTblEntry *rte PG_USED_FOR_ASSERTS_ONLY;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Should only be applied to base relations that are subqueries */
 	Assert(rel->relid > 0);
@@ -3739,12 +3596,10 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 	 * targetlist.	For any output that is a plain Var, get the width estimate
 	 * that was made while planning the subquery.  Otherwise, we leave it to
 	 * set_rel_width to fill in a datatype-based default estimate.
-	 */
-	foreach(lc, subroot->parse->targetList)
-	{
+	 */foreach(lc, subroot->parse->targetList) {
 		TargetEntry *te = (TargetEntry *) lfirst(lc);
-		Node	   *texpr = (Node *) te->expr;
-		int32		item_width = 0;
+		Node *texpr = (Node *) te->expr;
+		int32 item_width = 0;
 
 		Assert(IsA(te, TargetEntry));
 		/* junk columns aren't visible to upper query */
@@ -3773,10 +3628,8 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 		 * In either case, we just leave the width estimate zero until
 		 * set_rel_width fixes it.
 		 */
-		if (IsA(texpr, Var) &&
-			subroot->parse->setOperations == NULL)
-		{
-			Var		   *var = (Var *) texpr;
+		if (IsA(texpr, Var) && subroot->parse->setOperations == NULL) {
+			Var *var = (Var *) texpr;
 			RelOptInfo *subrel = find_base_rel(subroot, var->varno);
 
 			item_width = subrel->attr_widths[var->varattno - subrel->min_attr];
@@ -3797,11 +3650,9 @@ set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	RangeTblEntry *rte;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Should only be applied to base relations that are functions */
 	Assert(rel->relid > 0);
@@ -3813,10 +3664,9 @@ set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
 	 * node is that of the largest function result.
 	 */
 	rel->tuples = 0;
-	foreach(lc, rte->functions)
-	{
+	foreach(lc, rte->functions) {
 		RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);
-		double		ntup = expression_returns_set_rows(rtfunc->funcexpr);
+		double ntup = expression_returns_set_rows(rtfunc->funcexpr);
 
 		if (ntup > rel->tuples)
 			rel->tuples = ntup;
@@ -3835,9 +3685,7 @@ set_function_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	RangeTblEntry *rte;
 
 	/* Should only be applied to base relations that are values lists */
@@ -3867,9 +3715,7 @@ set_values_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  *
  * We set the same fields as set_baserel_size_estimates.
  */
-void
-set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
-{
+void set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan) {
 	RangeTblEntry *rte;
 
 	/* Should only be applied to base relations that are CTE references */
@@ -3877,16 +3723,13 @@ set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
 	rte = planner_rt_fetch(rel->relid, root);
 	Assert(rte->rtekind == RTE_CTE);
 
-	if (rte->self_reference)
-	{
+	if (rte->self_reference) {
 		/*
 		 * In a self-reference, arbitrarily assume the average worktable size
 		 * is about 10 times the nonrecursive term's size.
 		 */
 		rel->tuples = 10 * cteplan->plan_rows;
-	}
-	else
-	{
+	} else {
 		/* Otherwise just believe the CTE plan's output estimate */
 		rel->tuples = cteplan->plan_rows;
 	}
@@ -3910,20 +3753,17 @@ set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan)
  * The rel's targetlist and restrictinfo list must have been constructed
  * already.
  */
-void
-set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel)
-{
+void set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
-	rel->rows = 1000;			/* entirely bogus default estimate */
+	rel->rows = 1000; /* entirely bogus default estimate */
 
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
 	set_rel_width(root, rel);
 }
 
-
 /*
  * set_rel_width
  *		Set the estimated output width of a base relation.
@@ -3943,17 +3783,14 @@ set_foreign_size_estimates(PlannerInfo *root, RelOptInfo *rel)
  * The per-attribute width estimates are cached for possible re-use while
  * building join relations.
  */
-static void
-set_rel_width(PlannerInfo *root, RelOptInfo *rel)
-{
-	Oid			reloid = planner_rt_fetch(rel->relid, root)->relid;
-	int32		tuple_width = 0;
-	bool		have_wholerow_var = false;
-	ListCell   *lc;
-
-	foreach(lc, rel->reltargetlist)
-	{
-		Node	   *node = (Node *) lfirst(lc);
+static void set_rel_width(PlannerInfo *root, RelOptInfo *rel) {
+	Oid reloid = planner_rt_fetch(rel->relid, root)->relid;
+	int32 tuple_width = 0;
+	bool have_wholerow_var = false;
+	ListCell *lc;
+
+	foreach(lc, rel->reltargetlist) {
+		Node *node = (Node *) lfirst(lc);
 
 		/*
 		 * Ordinarily, a Var in a rel's reltargetlist must belong to that rel;
@@ -3961,12 +3798,10 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 		 * isn't so.  If the Var has the wrong varno, fall through to the
 		 * generic case (it doesn't seem worth the trouble to be any smarter).
 		 */
-		if (IsA(node, Var) &&
-			((Var *) node)->varno == rel->relid)
-		{
-			Var		   *var = (Var *) node;
-			int			ndx;
-			int32		item_width;
+		if (IsA(node, Var) && ((Var *) node)->varno == rel->relid) {
+			Var *var = (Var *) node;
+			int ndx;
+			int32 item_width;
 
 			Assert(var->varattno >= rel->min_attr);
 			Assert(var->varattno <= rel->max_attr);
@@ -3977,8 +3812,7 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			 * If it's a whole-row Var, we'll deal with it below after we have
 			 * already cached as many attr widths as possible.
 			 */
-			if (var->varattno == 0)
-			{
+			if (var->varattno == 0) {
 				have_wholerow_var = true;
 				continue;
 			}
@@ -3987,18 +3821,15 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			 * The width may have been cached already (especially if it's a
 			 * subquery), so don't duplicate effort.
 			 */
-			if (rel->attr_widths[ndx] > 0)
-			{
+			if (rel->attr_widths[ndx] > 0) {
 				tuple_width += rel->attr_widths[ndx];
 				continue;
 			}
 
 			/* Try to get column width from statistics */
-			if (reloid != InvalidOid && var->varattno > 0)
-			{
+			if (reloid != InvalidOid && var->varattno > 0) {
 				item_width = get_attavgwidth(reloid, var->varattno);
-				if (item_width > 0)
-				{
+				if (item_width > 0) {
 					rel->attr_widths[ndx] = item_width;
 					tuple_width += item_width;
 					continue;
@@ -4013,22 +3844,18 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 			Assert(item_width > 0);
 			rel->attr_widths[ndx] = item_width;
 			tuple_width += item_width;
-		}
-		else if (IsA(node, PlaceHolderVar))
-		{
+		} else if (IsA(node, PlaceHolderVar)) {
 			PlaceHolderVar *phv = (PlaceHolderVar *) node;
 			PlaceHolderInfo *phinfo = find_placeholder_info(root, phv, false);
 
 			tuple_width += phinfo->ph_width;
-		}
-		else
-		{
+		} else {
 			/*
 			 * We could be looking at an expression pulled up from a subquery,
 			 * or a ROW() representing a whole-row child Var, etc.	Do what we
 			 * can using the expression type information.
 			 */
-			int32		item_width;
+			int32 item_width;
 
 			item_width = get_typavgwidth(exprType(node), exprTypmod(node));
 			Assert(item_width > 0);
@@ -4040,20 +3867,16 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
 	 * If we have a whole-row reference, estimate its width as the sum of
 	 * per-column widths plus sizeof(HeapTupleHeaderData).
 	 */
-	if (have_wholerow_var)
-	{
-		int32		wholerow_width = sizeof(HeapTupleHeaderData);
+	if (have_wholerow_var) {
+		int32 wholerow_width = sizeof(HeapTupleHeaderData);
 
-		if (reloid != InvalidOid)
-		{
+		if (reloid != InvalidOid) {
 			/* Real relation, so estimate true tuple width */
 			wholerow_width += get_relation_data_width(reloid,
-										   rel->attr_widths - rel->min_attr);
-		}
-		else
-		{
+					rel->attr_widths - rel->min_attr);
+		} else {
 			/* Do what we can with info for a phony rel */
-			AttrNumber	i;
+			AttrNumber i;
 
 			for (i = 1; i <= rel->max_attr; i++)
 				wholerow_width += rel->attr_widths[i - rel->min_attr];
@@ -4077,9 +3900,7 @@ set_rel_width(PlannerInfo *root, RelOptInfo *rel)
  *	  Estimate the storage space in bytes for a given number of tuples
  *	  of a given width (size in bytes).
  */
-static double
-relation_byte_size(double tuples, int width)
-{
+static double relation_byte_size(double tuples, int width) {
 	return tuples * (MAXALIGN(width) + MAXALIGN(sizeof(HeapTupleHeaderData)));
 }
 
@@ -4088,24 +3909,19 @@ relation_byte_size(double tuples, int width)
  *	  Returns an estimate of the number of pages covered by a given
  *	  number of tuples of a given width (size in bytes).
  */
-static double
-page_size(double tuples, int width)
-{
+static double page_size(double tuples, int width) {
 	return ceil(relation_byte_size(tuples, width) / BLCKSZ);
 }
 
 /*
  * GUC check_hook for effective_cache_size
  */
-bool
-check_effective_cache_size(int *newval, void **extra, GucSource source)
-{
+bool check_effective_cache_size(int *newval, void **extra, GucSource source) {
 	/*
 	 * -1 is the documented way of requesting auto-tune, but we also treat
 	 * zero as meaning that, since we don't consider zero a valid setting.
 	 */
-	if (*newval <= 0)
-	{
+	if (*newval <= 0) {
 		/*
 		 * Substitute the auto-tune value, being wary of overflow.
 		 */
@@ -4128,15 +3944,13 @@ check_effective_cache_size(int *newval, void **extra, GucSource source)
  * was installed, but we will not have known the final value of NBuffers at
  * that time, which is why this has to be called at the end of GUC startup.
  */
-void
-set_default_effective_cache_size(void)
-{
+void set_default_effective_cache_size(void) {
 	/*
 	 * We let check_effective_cache_size() compute the actual setting.	Note
 	 * that this call is a no-op if the user has supplied a setting (since
 	 * that will have a higher priority than PGC_S_DYNAMIC_DEFAULT).
 	 */
-	SetConfigOption("effective_cache_size", "-1",
-					PGC_POSTMASTER, PGC_S_DYNAMIC_DEFAULT);
+	SetConfigOption("effective_cache_size", "-1", PGC_POSTMASTER,
+			PGC_S_DYNAMIC_DEFAULT);
 	Assert(effective_cache_size > 0);
 }
diff --git a/src/backend/optimizer/path/indxpath.c b/src/backend/optimizer/path/indxpath.c
index a912174..ec8b9f2 100644
--- a/src/backend/optimizer/path/indxpath.c
+++ b/src/backend/optimizer/path/indxpath.c
@@ -828,7 +828,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 	List	   *index_clauses;
 	List	   *clause_columns;
 	Relids		outer_relids;
-	double		loop_count;
+	double		*loop_count =&index->loop_count;
 	List	   *orderbyclauses;
 	List	   *orderbyclausecols;
 	List	   *index_pathkeys;
@@ -935,7 +935,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 		outer_relids = NULL;
 
 	/* Compute loop_count for cost estimation purposes */
-	loop_count = get_loop_count(root, outer_relids);
+	*loop_count = get_loop_count(root, outer_relids);
 
 	/*
 	 * 2. Compute pathkeys describing index's ordering, if any, then see how
@@ -1002,7 +1002,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 								  NoMovementScanDirection,
 								  index_only_scan,
 								  outer_relids,
-								  loop_count);
+								  *loop_count);
 		result = lappend(result, ipath);
 	}
 
@@ -1026,7 +1026,7 @@ build_index_paths(PlannerInfo *root, RelOptInfo *rel,
 									  BackwardScanDirection,
 									  index_only_scan,
 									  outer_relids,
-									  loop_count);
+									  *loop_count);
 			result = lappend(result, ipath);
 		}
 	}
@@ -1513,11 +1513,12 @@ bitmap_scan_cost_est(PlannerInfo *root, RelOptInfo *rel, Path *ipath)
 													  required_outer);
 	bpath.path.pathkeys = NIL;
 	bpath.bitmapqual = ipath;
+	bpath.loop = get_loop_count(root, required_outer);
 
 	cost_bitmap_heap_scan(&bpath.path, root, rel,
 						  bpath.path.param_info,
 						  ipath,
-						  get_loop_count(root, required_outer));
+						  bpath.loop);
 
 	return bpath.path.total_cost;
 }
diff --git a/src/backend/optimizer/path/joinpath.c b/src/backend/optimizer/path/joinpath.c
index a996116..4a7585d 100644
--- a/src/backend/optimizer/path/joinpath.c
+++ b/src/backend/optimizer/path/joinpath.c
@@ -224,7 +224,7 @@ add_paths_to_joinrel(PlannerInfo *root,
 	 * joins at all, so it wouldn't work in the prohibited cases either.)
 	 */
 	if (mergejoin_allowed)
-		match_unsorted_outer(root, joinrel, outerrel, innerrel,
+		 match_unsorted_outer(root, joinrel, outerrel, innerrel,
 							 restrictlist, mergeclause_list, jointype,
 							 sjinfo, &semifactors,
 							 param_source_rels, extra_lateral_rels);
@@ -337,6 +337,7 @@ try_nestloop_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
@@ -425,6 +426,7 @@ try_mergejoin_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
@@ -446,8 +448,7 @@ try_hashjoin_path(PlannerInfo *root,
 				  List *hashclauses)
 {
 	Relids		required_outer;
-	JoinCostWorkspace workspace;
-
+	JoinCostWorkspace workspace ;
 	/*
 	 * Check to see if proposed path is still parameterized, and reject if the
 	 * parameterization wouldn't be sensible.
@@ -498,6 +499,7 @@ try_hashjoin_path(PlannerInfo *root,
 		/* Waste no memory when we reject a path here */
 		bms_free(required_outer);
 	}
+	joinrel->workspace = &workspace;
 }
 
 /*
diff --git a/src/backend/optimizer/path/joinrels.c b/src/backend/optimizer/path/joinrels.c
index 05eaef5..b3d936c 100644
--- a/src/backend/optimizer/path/joinrels.c
+++ b/src/backend/optimizer/path/joinrels.c
@@ -634,6 +634,7 @@ make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)
 	joinrel = build_join_rel(root, joinrelids, rel1, rel2, sjinfo,
 							 &restrictlist);
 
+
 	/*
 	 * If we've already proven this join is empty, we needn't consider any
 	 * more paths for it.
diff --git a/src/backend/optimizer/plan/createplan.c b/src/backend/optimizer/plan/createplan.c
index 784805f..48b4177 100644
--- a/src/backend/optimizer/plan/createplan.c
+++ b/src/backend/optimizer/plan/createplan.c
@@ -28,6 +28,7 @@
 #include "optimizer/clauses.h"
 #include "optimizer/cost.h"
 #include "optimizer/paths.h"
+#include "optimizer/pathnode.h"
 #include "optimizer/placeholder.h"
 #include "optimizer/plancat.h"
 #include "optimizer/planmain.h"
@@ -40,8 +41,9 @@
 #include "parser/parse_clause.h"
 #include "parser/parsetree.h"
 #include "utils/lsyscache.h"
+#include "storage/fd.h"
 
-
+bool enable_cost_check = false;
 static Plan *create_plan_recurse(PlannerInfo *root, Path *best_path);
 static Plan *create_scan_plan(PlannerInfo *root, Path *best_path);
 static List *build_path_tlist(PlannerInfo *root, Path *path);
@@ -50,123 +52,103 @@ static void disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path);
 static Plan *create_gating_plan(PlannerInfo *root, Plan *plan, List *quals);
 static Plan *create_join_plan(PlannerInfo *root, JoinPath *best_path);
 static Plan *create_append_plan(PlannerInfo *root, AppendPath *best_path);
-static Plan *create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path);
+static Plan *create_merge_append_plan(PlannerInfo *root,
+		MergeAppendPath *best_path);
 static Result *create_result_plan(PlannerInfo *root, ResultPath *best_path);
-static Material *create_material_plan(PlannerInfo *root, MaterialPath *best_path);
+static Material *create_material_plan(PlannerInfo *root,
+		MaterialPath *best_path);
 static Plan *create_unique_plan(PlannerInfo *root, UniquePath *best_path);
 static SeqScan *create_seqscan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
 static Scan *create_indexscan_plan(PlannerInfo *root, IndexPath *best_path,
-					  List *tlist, List *scan_clauses, bool indexonly);
+		List *tlist, List *scan_clauses, bool indexonly);
 static BitmapHeapScan *create_bitmap_scan_plan(PlannerInfo *root,
-						BitmapHeapPath *best_path,
-						List *tlist, List *scan_clauses);
+		BitmapHeapPath *best_path, List *tlist, List *scan_clauses);
 static Plan *create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
-					  List **qual, List **indexqual, List **indexECs);
+		List **qual, List **indexqual, List **indexECs);
 static TidScan *create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
-					List *tlist, List *scan_clauses);
-static SubqueryScan *create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses);
-static FunctionScan *create_functionscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
+static SubqueryScan *create_subqueryscan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
+static FunctionScan *create_functionscan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
 static ValuesScan *create_valuesscan_plan(PlannerInfo *root, Path *best_path,
-					   List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
 static CteScan *create_ctescan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses);
-static WorkTableScan *create_worktablescan_plan(PlannerInfo *root, Path *best_path,
-						  List *tlist, List *scan_clauses);
-static ForeignScan *create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
-						List *tlist, List *scan_clauses);
+		List *tlist, List *scan_clauses);
+static WorkTableScan *create_worktablescan_plan(PlannerInfo *root,
+		Path *best_path, List *tlist, List *scan_clauses);
+static ForeignScan *create_foreignscan_plan(PlannerInfo *root,
+		ForeignPath *best_path, List *tlist, List *scan_clauses);
 static NestLoop *create_nestloop_plan(PlannerInfo *root, NestPath *best_path,
-					 Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static MergeJoin *create_mergejoin_plan(PlannerInfo *root, MergePath *best_path,
-					  Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static HashJoin *create_hashjoin_plan(PlannerInfo *root, HashPath *best_path,
-					 Plan *outer_plan, Plan *inner_plan);
+		Plan *outer_plan, Plan *inner_plan);
 static Node *replace_nestloop_params(PlannerInfo *root, Node *expr);
 static Node *replace_nestloop_params_mutator(Node *node, PlannerInfo *root);
 static void process_subquery_nestloop_params(PlannerInfo *root,
-								 List *subplan_params);
+		List *subplan_params);
 static List *fix_indexqual_references(PlannerInfo *root, IndexPath *index_path);
-static List *fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path);
-static Node *fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol);
+static List *fix_indexorderby_references(PlannerInfo *root,
+		IndexPath *index_path);
+static Node *fix_indexqual_operand(Node *node, IndexOptInfo *index,
+		int indexcol);
 static List *get_switched_clauses(List *clauses, Relids outerrelids);
 static List *order_qual_clauses(PlannerInfo *root, List *clauses);
 static void copy_path_costsize(Plan *dest, Path *src);
 static void copy_plan_costsize(Plan *dest, Plan *src);
 static SeqScan *make_seqscan(List *qptlist, List *qpqual, Index scanrelid);
 static IndexScan *make_indexscan(List *qptlist, List *qpqual, Index scanrelid,
-			   Oid indexid, List *indexqual, List *indexqualorig,
-			   List *indexorderby, List *indexorderbyorig,
-			   ScanDirection indexscandir);
+		Oid indexid, List *indexqual, List *indexqualorig, List *indexorderby,
+		List *indexorderbyorig, ScanDirection indexscandir);
 static IndexOnlyScan *make_indexonlyscan(List *qptlist, List *qpqual,
-				   Index scanrelid, Oid indexid,
-				   List *indexqual, List *indexorderby,
-				   List *indextlist,
-				   ScanDirection indexscandir);
+		Index scanrelid, Oid indexid, List *indexqual, List *indexorderby,
+		List *indextlist, ScanDirection indexscandir);
 static BitmapIndexScan *make_bitmap_indexscan(Index scanrelid, Oid indexid,
-					  List *indexqual,
-					  List *indexqualorig);
-static BitmapHeapScan *make_bitmap_heapscan(List *qptlist,
-					 List *qpqual,
-					 Plan *lefttree,
-					 List *bitmapqualorig,
-					 Index scanrelid);
+		List *indexqual, List *indexqualorig);
+static BitmapHeapScan *make_bitmap_heapscan(List *qptlist, List *qpqual,
+		Plan *lefttree, List *bitmapqualorig, Index scanrelid);
 static TidScan *make_tidscan(List *qptlist, List *qpqual, Index scanrelid,
-			 List *tidquals);
+		List *tidquals);
 static FunctionScan *make_functionscan(List *qptlist, List *qpqual,
-				  Index scanrelid, List *functions, bool funcordinality);
-static ValuesScan *make_valuesscan(List *qptlist, List *qpqual,
-				Index scanrelid, List *values_lists);
-static CteScan *make_ctescan(List *qptlist, List *qpqual,
-			 Index scanrelid, int ctePlanId, int cteParam);
+		Index scanrelid, List *functions, bool funcordinality);
+static ValuesScan *make_valuesscan(List *qptlist, List *qpqual, Index scanrelid,
+		List *values_lists);
+static CteScan *make_ctescan(List *qptlist, List *qpqual, Index scanrelid,
+		int ctePlanId, int cteParam);
 static WorkTableScan *make_worktablescan(List *qptlist, List *qpqual,
-				   Index scanrelid, int wtParam);
+		Index scanrelid, int wtParam);
 static BitmapAnd *make_bitmap_and(List *bitmapplans);
 static BitmapOr *make_bitmap_or(List *bitmapplans);
-static NestLoop *make_nestloop(List *tlist,
-			  List *joinclauses, List *otherclauses, List *nestParams,
-			  Plan *lefttree, Plan *righttree,
-			  JoinType jointype);
-static HashJoin *make_hashjoin(List *tlist,
-			  List *joinclauses, List *otherclauses,
-			  List *hashclauses,
-			  Plan *lefttree, Plan *righttree,
-			  JoinType jointype);
-static Hash *make_hash(Plan *lefttree,
-		  Oid skewTable,
-		  AttrNumber skewColumn,
-		  bool skewInherit,
-		  Oid skewColType,
-		  int32 skewColTypmod);
-static MergeJoin *make_mergejoin(List *tlist,
-			   List *joinclauses, List *otherclauses,
-			   List *mergeclauses,
-			   Oid *mergefamilies,
-			   Oid *mergecollations,
-			   int *mergestrategies,
-			   bool *mergenullsfirst,
-			   Plan *lefttree, Plan *righttree,
-			   JoinType jointype);
+static NestLoop *make_nestloop(List *tlist, List *joinclauses,
+		List *otherclauses, List *nestParams, Plan *lefttree, Plan *righttree,
+		JoinType jointype);
+static HashJoin *make_hashjoin(List *tlist, List *joinclauses,
+		List *otherclauses, List *hashclauses, Plan *lefttree, Plan *righttree,
+		JoinType jointype);
+static Hash *make_hash(Plan *lefttree, Oid skewTable, AttrNumber skewColumn,
+		bool skewInherit, Oid skewColType, int32 skewColTypmod);
+static MergeJoin *make_mergejoin(List *tlist, List *joinclauses,
+		List *otherclauses, List *mergeclauses, Oid *mergefamilies,
+		Oid *mergecollations, int *mergestrategies, bool *mergenullsfirst,
+		Plan *lefttree, Plan *righttree, JoinType jointype);
 static Sort *make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
-		  AttrNumber *sortColIdx, Oid *sortOperators,
-		  Oid *collations, bool *nullsFirst,
-		  double limit_tuples);
-static Plan *prepare_sort_from_pathkeys(PlannerInfo *root,
-						   Plan *lefttree, List *pathkeys,
-						   Relids relids,
-						   const AttrNumber *reqColIdx,
-						   bool adjust_tlist_in_place,
-						   int *p_numsortkeys,
-						   AttrNumber **p_sortColIdx,
-						   Oid **p_sortOperators,
-						   Oid **p_collations,
-						   bool **p_nullsFirst);
+		AttrNumber *sortColIdx, Oid *sortOperators, Oid *collations,
+		bool *nullsFirst, double limit_tuples);
+static Plan *prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree,
+		List *pathkeys, Relids relids, const AttrNumber *reqColIdx,
+		bool adjust_tlist_in_place, int *p_numsortkeys,
+		AttrNumber **p_sortColIdx, Oid **p_sortOperators, Oid **p_collations,
+		bool **p_nullsFirst);
 static EquivalenceMember *find_ec_member_for_tle(EquivalenceClass *ec,
-					   TargetEntry *tle,
-					   Relids relids);
+		TargetEntry *tle, Relids relids);
 static Material *make_material(Plan *lefttree);
-
+static void print_injected_cost(const char *rel, int rows,double old_cost,  double cost_result);
+static int get_base_rows_from_memo(char *name, int level);
+static int get_join_rows_from_memo(char *name, int level);
+FILE *file;
 
 /*
  * create_plan
@@ -184,9 +166,8 @@ static Material *make_material(Plan *lefttree);
  *	  Returns a Plan tree.
  */
 Plan *
-create_plan(PlannerInfo *root, Path *best_path)
-{
-	Plan	   *plan;
+create_plan(PlannerInfo *root, Path *best_path) {
+	Plan *plan;
 
 	/* plan_params should not be in use in current query level */
 	Assert(root->plan_params == NIL);
@@ -195,9 +176,14 @@ create_plan(PlannerInfo *root, Path *best_path)
 	root->curOuterRels = NULL;
 	root->curOuterParams = NIL;
 
+	mode_cost_check = enable_cost_check;
+	if (enable_cost_check)
+
+		file = AllocateFile("injected_durations.txt", "ab");
+
 	/* Recursively process the path tree */
 	plan = create_plan_recurse(root, best_path);
-
+	mode_cost_check = false; // reset cost var
 	/* Check we successfully assigned all NestLoopParams to plan nodes */
 	if (root->curOuterParams != NIL)
 		elog(ERROR, "failed to assign all NestLoopParams to plan nodes");
@@ -206,6 +192,7 @@ create_plan(PlannerInfo *root, Path *best_path)
 	 * Reset plan_params to ensure param IDs used for nestloop params are not
 	 * re-used later
 	 */
+
 	root->plan_params = NIL;
 
 	return plan;
@@ -216,56 +203,47 @@ create_plan(PlannerInfo *root, Path *best_path)
  *	  Recursive guts of create_plan().
  */
 static Plan *
-create_plan_recurse(PlannerInfo *root, Path *best_path)
-{
-	Plan	   *plan;
-
-	switch (best_path->pathtype)
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			plan = create_scan_plan(root, best_path);
-			break;
-		case T_HashJoin:
-		case T_MergeJoin:
-		case T_NestLoop:
-			plan = create_join_plan(root,
-									(JoinPath *) best_path);
-			break;
-		case T_Append:
-			plan = create_append_plan(root,
-									  (AppendPath *) best_path);
-			break;
-		case T_MergeAppend:
-			plan = create_merge_append_plan(root,
-											(MergeAppendPath *) best_path);
-			break;
-		case T_Result:
-			plan = (Plan *) create_result_plan(root,
-											   (ResultPath *) best_path);
-			break;
-		case T_Material:
-			plan = (Plan *) create_material_plan(root,
-												 (MaterialPath *) best_path);
-			break;
-		case T_Unique:
-			plan = create_unique_plan(root,
-									  (UniquePath *) best_path);
-			break;
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
+create_plan_recurse(PlannerInfo *root, Path *best_path) {
+	Plan *plan;
+
+	switch (best_path->pathtype) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		plan = create_scan_plan(root, best_path);
+		break;
+	case T_HashJoin:
+	case T_MergeJoin:
+	case T_NestLoop:
+		plan = create_join_plan(root, (JoinPath *) best_path);
+		break;
+	case T_Append:
+		plan = create_append_plan(root, (AppendPath *) best_path);
+		break;
+	case T_MergeAppend:
+		plan = create_merge_append_plan(root, (MergeAppendPath *) best_path);
+		break;
+	case T_Result:
+		plan = (Plan *) create_result_plan(root, (ResultPath *) best_path);
+		break;
+	case T_Material:
+		plan = (Plan *) create_material_plan(root, (MaterialPath *) best_path);
+		break;
+	case T_Unique:
+		plan = create_unique_plan(root, (UniquePath *) best_path);
+		break;
+	default:
+		elog(ERROR, "unrecognized node type: %d", (int) best_path->pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 	}
 
 	return plan;
@@ -276,12 +254,15 @@ create_plan_recurse(PlannerInfo *root, Path *best_path)
  *	 Create a scan plan for the parent relation of 'best_path'.
  */
 static Plan *
-create_scan_plan(PlannerInfo *root, Path *best_path)
-{
+create_scan_plan(PlannerInfo *root, Path *best_path) {
+
+	List *tlist;
+	List *scan_clauses;
+	Plan *plan;
 	RelOptInfo *rel = best_path->parent;
-	List	   *tlist;
-	List	   *scan_clauses;
-	Plan	   *plan;
+	int nrows;
+	double mcost = -1;
+
 
 	/*
 	 * For table scans, rather than using the relation targetlist (which is
@@ -291,23 +272,18 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 * planner.c may replace the tlist we generate here, forcing projection to
 	 * occur.)
 	 */
-	if (use_physical_tlist(root, rel))
-	{
-		if (best_path->pathtype == T_IndexOnlyScan)
-		{
+	if (use_physical_tlist(root, rel)) {
+		if (best_path->pathtype == T_IndexOnlyScan) {
 			/* For index-only scan, the preferred tlist is the index's */
-			tlist = copyObject(((IndexPath *) best_path)->indexinfo->indextlist);
-		}
-		else
-		{
+			tlist = copyObject(
+					((IndexPath *) best_path)->indexinfo->indextlist);
+		} else {
 			tlist = build_physical_tlist(root, rel);
 			/* if fail because of dropped cols, use regular method */
 			if (tlist == NIL)
 				tlist = build_path_tlist(root, best_path);
 		}
-	}
-	else
-	{
+	} else {
 		tlist = build_path_tlist(root, best_path);
 	}
 
@@ -326,94 +302,123 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 */
 	if (best_path->param_info)
 		scan_clauses = list_concat(list_copy(scan_clauses),
-								   best_path->param_info->ppi_clauses);
-
-	switch (best_path->pathtype)
-	{
-		case T_SeqScan:
-			plan = (Plan *) create_seqscan_plan(root,
-												best_path,
-												tlist,
-												scan_clauses);
-			break;
-
-		case T_IndexScan:
-			plan = (Plan *) create_indexscan_plan(root,
-												  (IndexPath *) best_path,
-												  tlist,
-												  scan_clauses,
-												  false);
-			break;
-
-		case T_IndexOnlyScan:
-			plan = (Plan *) create_indexscan_plan(root,
-												  (IndexPath *) best_path,
-												  tlist,
-												  scan_clauses,
-												  true);
-			break;
+				best_path->param_info->ppi_clauses);
+	if (enable_cost_check) {
+		nrows = get_base_rows_from_memo(rel->rel_name, root->query_level);
+	}
 
-		case T_BitmapHeapScan:
-			plan = (Plan *) create_bitmap_scan_plan(root,
-												(BitmapHeapPath *) best_path,
-													tlist,
-													scan_clauses);
-			break;
+	switch (best_path->pathtype) {
+	case T_SeqScan:
+		plan = (Plan *) create_seqscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_seqscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
 
-		case T_TidScan:
-			plan = (Plan *) create_tidscan_plan(root,
-												(TidPath *) best_path,
-												tlist,
-												scan_clauses);
-			break;
+		}
+		break;
+
+	case T_IndexScan:
+		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
+				tlist, scan_clauses, false);
+		if (enable_cost_check) {
+			cost_index((IndexPath *) best_path, root,
+					((IndexPath *) best_path)->indexinfo->loop_count);
+			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
+		}
+		break;
+
+	case T_IndexOnlyScan:
+		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
+				tlist, scan_clauses, true);
+		if (enable_cost_check) {
+			cost_index((IndexPath *) best_path, root,
+					((IndexPath *) best_path)->indexinfo->loop_count);
+			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
+		}
+		break;
+
+	case T_BitmapHeapScan:
+		plan = (Plan *) create_bitmap_scan_plan(root,
+				(BitmapHeapPath *) best_path, tlist, scan_clauses);
+		if (enable_cost_check) {
+			cost_bitmap_heap_scan(best_path, root, rel,
+					((BitmapHeapPath *) best_path)->path.param_info,
+					((BitmapHeapPath *) best_path)->bitmapqual,
+					((BitmapHeapPath *) best_path)->loop);
+			mcost = best_path->mtotal_cost;
+		}
 
-		case T_SubqueryScan:
-			plan = (Plan *) create_subqueryscan_plan(root,
-													 best_path,
-													 tlist,
-													 scan_clauses);
-			break;
+		break;
 
-		case T_FunctionScan:
-			plan = (Plan *) create_functionscan_plan(root,
-													 best_path,
-													 tlist,
-													 scan_clauses);
-			break;
+	case T_TidScan:
+		plan = (Plan *) create_tidscan_plan(root, (TidPath *) best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_tidscan(best_path, root, rel,
+					((TidPath *) best_path)->tidquals,
+					((TidPath *) best_path)->path.param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_SubqueryScan:
+		plan = (Plan *) create_subqueryscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_subqueryscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_FunctionScan:
+		plan = (Plan *) create_functionscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_functionscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
 
-		case T_ValuesScan:
-			plan = (Plan *) create_valuesscan_plan(root,
-												   best_path,
-												   tlist,
-												   scan_clauses);
-			break;
+	case T_ValuesScan:
+		plan = (Plan *) create_valuesscan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_valuesscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
 
-		case T_CteScan:
-			plan = (Plan *) create_ctescan_plan(root,
-												best_path,
-												tlist,
-												scan_clauses);
-			break;
+		}
+		break;
+
+	case T_CteScan:
+		plan = (Plan *) create_ctescan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_ctescan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
+
+	case T_WorkTableScan:
+		plan = (Plan *) create_worktablescan_plan(root, best_path, tlist,
+				scan_clauses);
+		if (enable_cost_check) {
+			cost_ctescan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->mtotal_cost;
+		}
+		break;
 
-		case T_WorkTableScan:
-			plan = (Plan *) create_worktablescan_plan(root,
-													  best_path,
-													  tlist,
-													  scan_clauses);
-			break;
+	case T_ForeignScan:
+		plan = (Plan *) create_foreignscan_plan(root, (ForeignPath *) best_path,
+				tlist, scan_clauses);
+		//costs ???
+		break;
 
-		case T_ForeignScan:
-			plan = (Plan *) create_foreignscan_plan(root,
-													(ForeignPath *) best_path,
-													tlist,
-													scan_clauses);
-			break;
+	default:
+		elog(ERROR, "unrecognized node type: %d", (int) best_path->pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
 	}
 
 	/*
@@ -423,7 +428,9 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
 	 */
 	if (root->hasPseudoConstantQuals)
 		plan = create_gating_plan(root, plan, scan_clauses);
-
+	if (enable_cost_check) {
+		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+	}
 	return plan;
 }
 
@@ -431,17 +438,15 @@ create_scan_plan(PlannerInfo *root, Path *best_path)
  * Build a target list (ie, a list of TargetEntry) for the Path's output.
  */
 static List *
-build_path_tlist(PlannerInfo *root, Path *path)
-{
+build_path_tlist(PlannerInfo *root, Path *path) {
 	RelOptInfo *rel = path->parent;
-	List	   *tlist = NIL;
-	int			resno = 1;
-	ListCell   *v;
+	List *tlist = NIL;
+	int resno = 1;
+	ListCell *v;
 
-	foreach(v, rel->reltargetlist)
-	{
+	foreach(v, rel->reltargetlist) {
 		/* Do we really need to copy here?	Not sure */
-		Node	   *node = (Node *) copyObject(lfirst(v));
+		Node *node = (Node *) copyObject(lfirst(v));
 
 		/*
 		 * If it's a parameterized path, there might be lateral references in
@@ -452,10 +457,8 @@ build_path_tlist(PlannerInfo *root, Path *path)
 		if (path->param_info)
 			node = replace_nestloop_params(root, node);
 
-		tlist = lappend(tlist, makeTargetEntry((Expr *) node,
-											   resno,
-											   NULL,
-											   false));
+		tlist = lappend(tlist,
+				makeTargetEntry((Expr *) node, resno, NULL, false));
 		resno++;
 	}
 	return tlist;
@@ -466,21 +469,17 @@ build_path_tlist(PlannerInfo *root, Path *path)
  *		Decide whether to use a tlist matching relation structure,
  *		rather than only those Vars actually referenced.
  */
-static bool
-use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
-{
-	int			i;
-	ListCell   *lc;
+static bool use_physical_tlist(PlannerInfo *root, RelOptInfo *rel) {
+	int i;
+	ListCell *lc;
 
 	/*
 	 * We can do this for real relation scans, subquery scans, function scans,
 	 * values scans, and CTE scans (but not for, eg, joins).
 	 */
-	if (rel->rtekind != RTE_RELATION &&
-		rel->rtekind != RTE_SUBQUERY &&
-		rel->rtekind != RTE_FUNCTION &&
-		rel->rtekind != RTE_VALUES &&
-		rel->rtekind != RTE_CTE)
+	if (rel->rtekind != RTE_RELATION && rel->rtekind != RTE_SUBQUERY
+			&& rel->rtekind != RTE_FUNCTION && rel->rtekind != RTE_VALUES
+			&& rel->rtekind != RTE_CTE)
 		return false;
 
 	/*
@@ -495,8 +494,7 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
 	 * (This could possibly be fixed but would take some fragile assumptions
 	 * in setrefs.c, I think.)
 	 */
-	for (i = rel->min_attr; i <= 0; i++)
-	{
+	for (i = rel->min_attr; i <= 0; i++) {
 		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr]))
 			return false;
 	}
@@ -504,13 +502,11 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
 	/*
 	 * Can't do it if the rel is required to emit any placeholder expressions,
 	 * either.
-	 */
-	foreach(lc, root->placeholder_list)
-	{
+	 */foreach(lc, root->placeholder_list) {
 		PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);
 
-		if (bms_nonempty_difference(phinfo->ph_needed, rel->relids) &&
-			bms_is_subset(phinfo->ph_eval_at, rel->relids))
+		if (bms_nonempty_difference(phinfo->ph_needed, rel->relids)
+				&& bms_is_subset(phinfo->ph_eval_at, rel->relids))
 			return false;
 	}
 
@@ -526,27 +522,24 @@ use_physical_tlist(PlannerInfo *root, RelOptInfo *rel)
  * undo the decision made by use_physical_tlist().	Currently, Hash, Sort,
  * and Material nodes want this, so they don't have to store useless columns.
  */
-static void
-disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path)
-{
+static void disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path) {
 	/* Only need to undo it for path types handled by create_scan_plan() */
-	switch (path->pathtype)
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			plan->targetlist = build_path_tlist(root, path);
-			break;
-		default:
-			break;
+	switch (path->pathtype) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		plan->targetlist = build_path_tlist(root, path);
+		break;
+	default:
+		break;
 	}
 }
 
@@ -570,9 +563,8 @@ disuse_physical_tlist(PlannerInfo *root, Plan *plan, Path *path)
  * qual being true.
  */
 static Plan *
-create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
-{
-	List	   *pseudoconstants;
+create_gating_plan(PlannerInfo *root, Plan *plan, List *quals) {
+	List *pseudoconstants;
 
 	/* Sort into desirable execution order while still in RestrictInfo form */
 	quals = order_qual_clauses(root, quals);
@@ -583,10 +575,8 @@ create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
 	if (!pseudoconstants)
 		return plan;
 
-	return (Plan *) make_result(root,
-								plan->targetlist,
-								(Node *) pseudoconstants,
-								plan);
+	return (Plan *) make_result(root, plan->targetlist,
+			(Node *) pseudoconstants, plan);
 }
 
 /*
@@ -595,51 +585,82 @@ create_gating_plan(PlannerInfo *root, Plan *plan, List *quals)
  *	  inner and outer paths.
  */
 static Plan *
-create_join_plan(PlannerInfo *root, JoinPath *best_path)
-{
-	Plan	   *outer_plan;
-	Plan	   *inner_plan;
-	Plan	   *plan;
-	Relids		saveOuterRels = root->curOuterRels;
+create_join_plan(PlannerInfo *root, JoinPath *best_path) {
+	Plan *outer_plan;
+	Plan *inner_plan;
+	Plan *plan;
+	Relids saveOuterRels = root->curOuterRels;
+	RelOptInfo *rel = best_path->path.parent;
+	int nrows;
+	double mcost = -1;
 
 	outer_plan = create_plan_recurse(root, best_path->outerjoinpath);
 
 	/* For a nestloop, include outer relids in curOuterRels for inner side */
 	if (best_path->path.pathtype == T_NestLoop)
 		root->curOuterRels = bms_union(root->curOuterRels,
-								   best_path->outerjoinpath->parent->relids);
+				best_path->outerjoinpath->parent->relids);
 
 	inner_plan = create_plan_recurse(root, best_path->innerjoinpath);
+	if (enable_cost_check) {
+		nrows = get_join_rows_from_memo(rel->rel_name, root->query_level);
+	}
+	switch (best_path->path.pathtype) {
+	case T_MergeJoin:
+		plan = (Plan *) create_mergejoin_plan(root, (MergePath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check) {
+			initial_cost_mergejoin(root, rel->workspace,
+					((MergePath *) best_path)->jpath.jointype,
+					((MergePath *) best_path)->path_mergeclauses,
+					((MergePath *) best_path)->jpath.outerjoinpath,
+					((MergePath *) best_path)->jpath.innerjoinpath,
+					((MergePath *) best_path)->outersortkeys,
+					((MergePath *) best_path)->innersortkeys, NULL);
+			final_cost_mergejoin(root, (MergePath *) best_path, rel->workspace,
+					NULL);
+			mcost = ((MergePath *) best_path)->jpath.path.mtotal_cost;
 
-	switch (best_path->path.pathtype)
-	{
-		case T_MergeJoin:
-			plan = (Plan *) create_mergejoin_plan(root,
-												  (MergePath *) best_path,
-												  outer_plan,
-												  inner_plan);
-			break;
-		case T_HashJoin:
-			plan = (Plan *) create_hashjoin_plan(root,
-												 (HashPath *) best_path,
-												 outer_plan,
-												 inner_plan);
-			break;
-		case T_NestLoop:
-			/* Restore curOuterRels */
-			bms_free(root->curOuterRels);
-			root->curOuterRels = saveOuterRels;
-
-			plan = (Plan *) create_nestloop_plan(root,
-												 (NestPath *) best_path,
-												 outer_plan,
-												 inner_plan);
-			break;
-		default:
-			elog(ERROR, "unrecognized node type: %d",
-				 (int) best_path->path.pathtype);
-			plan = NULL;		/* keep compiler quiet */
-			break;
+		}
+		break;
+	case T_HashJoin:
+		plan = (Plan *) create_hashjoin_plan(root, (HashPath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check ) {
+			initial_cost_hashjoin(root, rel->workspace,
+					((HashPath *) best_path)->jpath.jointype,
+					((HashPath *) best_path)->path_hashclauses,
+					((HashPath *) best_path)->jpath.outerjoinpath,
+					((HashPath *) best_path)->jpath.innerjoinpath, NULL,
+					rel->workspace->semifactors);
+			final_cost_hashjoin(root, (HashPath *) best_path, rel->workspace,
+					NULL, rel->workspace->semifactors);
+
+			mcost = ((HashPath *) best_path)->jpath.path.mtotal_cost;
+		}
+		break;
+	case T_NestLoop:
+		/* Restore curOuterRels */
+		bms_free(root->curOuterRels);
+		root->curOuterRels = saveOuterRels;
+
+		plan = (Plan *) create_nestloop_plan(root, (NestPath *) best_path,
+				outer_plan, inner_plan);
+		if (enable_cost_check ) {
+			initial_cost_nestloop(root, rel->workspace, best_path->jointype,
+					best_path->outerjoinpath, best_path->innerjoinpath, NULL,
+					rel->workspace->semifactors);
+			final_cost_nestloop(root, best_path, rel->workspace, NULL,
+					rel->workspace->semifactors);
+
+			mcost = best_path->path.mtotal_cost;
+		}
+		break;
+	default:
+		elog(ERROR,
+				"unrecognized node type: %d", (int) best_path->path.pathtype);
+		plan = NULL; /* keep compiler quiet */
+		break;
 	}
 
 	/*
@@ -658,11 +679,14 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path)
 	 * 6/15/92
 	 */
 	if (get_loc_restrictinfo(best_path) != NIL)
-		set_qpqual((Plan) plan,
-				   list_concat(get_qpqual((Plan) plan),
-					   get_actual_clauses(get_loc_restrictinfo(best_path))));
+	set_qpqual((Plan) plan,
+			list_concat(get_qpqual((Plan) plan),
+					get_actual_clauses(get_loc_restrictinfo(best_path))));
 #endif
 
+	if (enable_cost_check) {
+		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+	}
 	return plan;
 }
 
@@ -674,12 +698,12 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_append_plan(PlannerInfo *root, AppendPath *best_path)
-{
-	Append	   *plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *subplans = NIL;
-	ListCell   *subpaths;
+create_append_plan(PlannerInfo *root, AppendPath *best_path) {
+	Append *plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *subplans = NIL;
+	ListCell *subpaths;
+//	RelOptInfo *rel = best_path->path.parent;
 
 	/*
 	 * The subpaths list could be empty, if every child was proven empty by
@@ -690,20 +714,15 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
 	 * cases where there was no appending construct at all, but we know the
 	 * relation is empty (see set_dummy_rel_pathlist).
 	 */
-	if (best_path->subpaths == NIL)
-	{
+	if (best_path->subpaths == NIL) {
 		/* Generate a Result plan with constant-FALSE gating qual */
-		return (Plan *) make_result(root,
-									tlist,
-									(Node *) list_make1(makeBoolConst(false,
-																	  false)),
-									NULL);
+		return (Plan *) make_result(root, tlist,
+				(Node *) list_make1(makeBoolConst(false,
+								false)), NULL);
 	}
 
-	/* Build the plan for each child */
-	foreach(subpaths, best_path->subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(subpaths);
+	/* Build the plan for each child */foreach(subpaths, best_path->subpaths) {
+		Path *subpath = (Path *) lfirst(subpaths);
 
 		subplans = lappend(subplans, create_plan_recurse(root, subpath));
 	}
@@ -717,6 +736,7 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
 
 	plan = make_append(subplans, tlist);
 
+
 	return (Plan *) plan;
 }
 
@@ -728,14 +748,13 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
-{
+create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path) {
 	MergeAppend *node = makeNode(MergeAppend);
-	Plan	   *plan = &node->plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *pathkeys = best_path->path.pathkeys;
-	List	   *subplans = NIL;
-	ListCell   *subpaths;
+	Plan *plan = &node->plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *pathkeys = best_path->path.pathkeys;
+	List *subplans = NIL;
+	ListCell *subpaths;
 
 	/*
 	 * We don't have the actual creation of the MergeAppend node split out
@@ -751,43 +770,30 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
 
 	/* Compute sort column info, and adjust MergeAppend's tlist as needed */
 	(void) prepare_sort_from_pathkeys(root, plan, pathkeys,
-									  best_path->path.parent->relids,
-									  NULL,
-									  true,
-									  &node->numCols,
-									  &node->sortColIdx,
-									  &node->sortOperators,
-									  &node->collations,
-									  &node->nullsFirst);
+			best_path->path.parent->relids, NULL, true, &node->numCols,
+			&node->sortColIdx, &node->sortOperators, &node->collations,
+			&node->nullsFirst);
 
 	/*
 	 * Now prepare the child plans.  We must apply prepare_sort_from_pathkeys
 	 * even to subplans that don't need an explicit sort, to make sure they
 	 * are returning the same sort key columns the MergeAppend expects.
-	 */
-	foreach(subpaths, best_path->subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(subpaths);
-		Plan	   *subplan;
-		int			numsortkeys;
+	 */foreach(subpaths, best_path->subpaths) {
+		Path *subpath = (Path *) lfirst(subpaths);
+		Plan *subplan;
+		int numsortkeys;
 		AttrNumber *sortColIdx;
-		Oid		   *sortOperators;
-		Oid		   *collations;
-		bool	   *nullsFirst;
+		Oid *sortOperators;
+		Oid *collations;
+		bool *nullsFirst;
 
 		/* Build the child plan */
 		subplan = create_plan_recurse(root, subpath);
 
 		/* Compute sort column info, and adjust subplan's tlist as needed */
 		subplan = prepare_sort_from_pathkeys(root, subplan, pathkeys,
-											 subpath->parent->relids,
-											 node->sortColIdx,
-											 false,
-											 &numsortkeys,
-											 &sortColIdx,
-											 &sortOperators,
-											 &collations,
-											 &nullsFirst);
+				subpath->parent->relids, node->sortColIdx, false, &numsortkeys,
+				&sortColIdx, &sortOperators, &collations, &nullsFirst);
 
 		/*
 		 * Check that we got the same sort key information.  We just Assert
@@ -797,27 +803,28 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
 		 */
 		Assert(numsortkeys == node->numCols);
 		if (memcmp(sortColIdx, node->sortColIdx,
-				   numsortkeys * sizeof(AttrNumber)) != 0)
-			elog(ERROR, "MergeAppend child's targetlist doesn't match MergeAppend");
-		Assert(memcmp(sortOperators, node->sortOperators,
-					  numsortkeys * sizeof(Oid)) == 0);
-		Assert(memcmp(collations, node->collations,
-					  numsortkeys * sizeof(Oid)) == 0);
-		Assert(memcmp(nullsFirst, node->nullsFirst,
-					  numsortkeys * sizeof(bool)) == 0);
+				numsortkeys * sizeof(AttrNumber)) != 0)
+			elog(ERROR,
+					"MergeAppend child's targetlist doesn't match MergeAppend");
+		Assert(
+				memcmp(sortOperators, node->sortOperators, numsortkeys * sizeof(Oid)) == 0);
+		Assert(
+				memcmp(collations, node->collations, numsortkeys * sizeof(Oid)) == 0);
+		Assert(
+				memcmp(nullsFirst, node->nullsFirst, numsortkeys * sizeof(bool)) == 0);
 
 		/* Now, insert a Sort node if subplan isn't sufficiently ordered */
 		if (!pathkeys_contained_in(pathkeys, subpath->pathkeys))
-			subplan = (Plan *) make_sort(root, subplan, numsortkeys,
-										 sortColIdx, sortOperators,
-										 collations, nullsFirst,
-										 best_path->limit_tuples);
+			subplan = (Plan *) make_sort(root, subplan, numsortkeys, sortColIdx,
+					sortOperators, collations, nullsFirst,
+					best_path->limit_tuples);
 
 		subplans = lappend(subplans, subplan);
 	}
 
 	node->mergeplans = subplans;
 
+
 	return (Plan *) node;
 }
 
@@ -829,10 +836,9 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path)
  *	  Returns a Plan node.
  */
 static Result *
-create_result_plan(PlannerInfo *root, ResultPath *best_path)
-{
-	List	   *tlist;
-	List	   *quals;
+create_result_plan(PlannerInfo *root, ResultPath *best_path) {
+	List *tlist;
+	List *quals;
 
 	/* The tlist will be installed later, since we have no RelOptInfo */
 	Assert(best_path->path.parent == NULL);
@@ -842,6 +848,7 @@ create_result_plan(PlannerInfo *root, ResultPath *best_path)
 
 	quals = order_qual_clauses(root, best_path->quals);
 
+
 	return make_result(root, tlist, (Node *) quals, NULL);
 }
 
@@ -853,10 +860,9 @@ create_result_plan(PlannerInfo *root, ResultPath *best_path)
  *	  Returns a Plan node.
  */
 static Material *
-create_material_plan(PlannerInfo *root, MaterialPath *best_path)
-{
-	Material   *plan;
-	Plan	   *subplan;
+create_material_plan(PlannerInfo *root, MaterialPath *best_path) {
+	Material *plan;
+	Plan *subplan;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
 
@@ -878,19 +884,18 @@ create_material_plan(PlannerInfo *root, MaterialPath *best_path)
  *	  Returns a Plan node.
  */
 static Plan *
-create_unique_plan(PlannerInfo *root, UniquePath *best_path)
-{
-	Plan	   *plan;
-	Plan	   *subplan;
-	List	   *in_operators;
-	List	   *uniq_exprs;
-	List	   *newtlist;
-	int			nextresno;
-	bool		newitems;
-	int			numGroupCols;
+create_unique_plan(PlannerInfo *root, UniquePath *best_path) {
+	Plan *plan;
+	Plan *subplan;
+	List *in_operators;
+	List *uniq_exprs;
+	List *newtlist;
+	int nextresno;
+	bool newitems;
+	int numGroupCols;
 	AttrNumber *groupColIdx;
-	int			groupColPos;
-	ListCell   *l;
+	int groupColPos;
+	ListCell *l;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
 
@@ -922,33 +927,27 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	nextresno = list_length(newtlist) + 1;
 	newitems = false;
 
-	foreach(l, uniq_exprs)
-	{
-		Node	   *uniqexpr = lfirst(l);
+	foreach(l, uniq_exprs) {
+		Node *uniqexpr = lfirst(l);
 		TargetEntry *tle;
 
 		tle = tlist_member(uniqexpr, newtlist);
-		if (!tle)
-		{
-			tle = makeTargetEntry((Expr *) uniqexpr,
-								  nextresno,
-								  NULL,
-								  false);
+		if (!tle) {
+			tle = makeTargetEntry((Expr *) uniqexpr, nextresno, NULL, false);
 			newtlist = lappend(newtlist, tle);
 			nextresno++;
 			newitems = true;
 		}
 	}
 
-	if (newitems || best_path->umethod == UNIQUE_PATH_SORT)
-	{
+	if (newitems || best_path->umethod == UNIQUE_PATH_SORT) {
 		/*
 		 * If the top plan node can't do projections and its existing target
 		 * list isn't already what we need, we need to add a Result node to
 		 * help it along.
 		 */
-		if (!is_projection_capable_plan(subplan) &&
-			!tlist_same_exprs(newtlist, subplan->targetlist))
+		if (!is_projection_capable_plan(subplan)
+				&& !tlist_same_exprs(newtlist, subplan->targetlist))
 			subplan = (Plan *) make_result(root, newtlist, NULL, subplan);
 		else
 			subplan->targetlist = newtlist;
@@ -965,21 +964,19 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	groupColIdx = (AttrNumber *) palloc(numGroupCols * sizeof(AttrNumber));
 
 	groupColPos = 0;
-	foreach(l, uniq_exprs)
-	{
-		Node	   *uniqexpr = lfirst(l);
+	foreach(l, uniq_exprs) {
+		Node *uniqexpr = lfirst(l);
 		TargetEntry *tle;
 
 		tle = tlist_member(uniqexpr, newtlist);
-		if (!tle)				/* shouldn't happen */
+		if (!tle) /* shouldn't happen */
 			elog(ERROR, "failed to find unique expression in subplan tlist");
 		groupColIdx[groupColPos++] = tle->resno;
 	}
 
-	if (best_path->umethod == UNIQUE_PATH_HASH)
-	{
-		long		numGroups;
-		Oid		   *groupOperators;
+	if (best_path->umethod == UNIQUE_PATH_HASH) {
+		long numGroups;
+		Oid *groupOperators;
 
 		numGroups = (long) Min(best_path->path.rows, (double) LONG_MAX);
 
@@ -991,14 +988,13 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 		 */
 		groupOperators = (Oid *) palloc(numGroupCols * sizeof(Oid));
 		groupColPos = 0;
-		foreach(l, in_operators)
-		{
-			Oid			in_oper = lfirst_oid(l);
-			Oid			eq_oper;
+		foreach(l, in_operators) {
+			Oid in_oper = lfirst_oid(l);
+			Oid eq_oper;
 
 			if (!get_compatible_hash_operators(in_oper, NULL, &eq_oper))
-				elog(ERROR, "could not find compatible hash operator for operator %u",
-					 in_oper);
+				elog(ERROR,
+						"could not find compatible hash operator for operator %u", in_oper);
 			groupOperators[groupColPos++] = eq_oper;
 		}
 
@@ -1007,35 +1003,25 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 		 * minimum output tlist, without any stuff we might have added to the
 		 * subplan tlist.
 		 */
-		plan = (Plan *) make_agg(root,
-								 build_path_tlist(root, &best_path->path),
-								 NIL,
-								 AGG_HASHED,
-								 NULL,
-								 numGroupCols,
-								 groupColIdx,
-								 groupOperators,
-								 numGroups,
-								 subplan);
-	}
-	else
-	{
-		List	   *sortList = NIL;
+		plan = (Plan *) make_agg(root, build_path_tlist(root, &best_path->path),
+				NIL, AGG_HASHED, NULL, numGroupCols, groupColIdx,
+				groupOperators, numGroups, subplan);
+	} else {
+		List *sortList = NIL;
 
 		/* Create an ORDER BY list to sort the input compatibly */
 		groupColPos = 0;
-		foreach(l, in_operators)
-		{
-			Oid			in_oper = lfirst_oid(l);
-			Oid			sortop;
-			Oid			eqop;
+		foreach(l, in_operators) {
+			Oid in_oper = lfirst_oid(l);
+			Oid sortop;
+			Oid eqop;
 			TargetEntry *tle;
 			SortGroupClause *sortcl;
 
 			sortop = get_ordering_op_for_equality_op(in_oper, false);
-			if (!OidIsValid(sortop))	/* shouldn't happen */
-				elog(ERROR, "could not find ordering operator for equality operator %u",
-					 in_oper);
+			if (!OidIsValid(sortop)) /* shouldn't happen */
+				elog(ERROR,
+						"could not find ordering operator for equality operator %u", in_oper);
 
 			/*
 			 * The Unique node will need equality operators.  Normally these
@@ -1044,21 +1030,21 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 			 * for the IN clause operators' RHS datatype.
 			 */
 			eqop = get_equality_op_for_ordering_op(sortop, NULL);
-			if (!OidIsValid(eqop))		/* shouldn't happen */
-				elog(ERROR, "could not find equality operator for ordering operator %u",
-					 sortop);
+			if (!OidIsValid(eqop)) /* shouldn't happen */
+				elog(ERROR,
+						"could not find equality operator for ordering operator %u", sortop);
 
 			tle = get_tle_by_resno(subplan->targetlist,
-								   groupColIdx[groupColPos]);
+					groupColIdx[groupColPos]);
 			Assert(tle != NULL);
 
 			sortcl = makeNode(SortGroupClause);
 			sortcl->tleSortGroupRef = assignSortGroupRef(tle,
-														 subplan->targetlist);
+					subplan->targetlist);
 			sortcl->eqop = eqop;
 			sortcl->sortop = sortop;
 			sortcl->nulls_first = false;
-			sortcl->hashable = false;	/* no need to make this accurate */
+			sortcl->hashable = false; /* no need to make this accurate */
 			sortList = lappend(sortList, sortcl);
 			groupColPos++;
 		}
@@ -1072,25 +1058,23 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path)
 	return plan;
 }
 
-
 /*****************************************************************************
  *
  *	BASE-RELATION SCAN METHODS
  *
  *****************************************************************************/
 
-
 /*
  * create_seqscan_plan
  *	 Returns a seqscan plan for the base relation scanned by 'best_path'
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static SeqScan *
-create_seqscan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses)
-{
-	SeqScan    *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+create_seqscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
+	SeqScan *scan_plan;
+	Index scan_relid = best_path->parent->relid;
+	RelOptInfo *rel = best_path->parent;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1103,15 +1087,13 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
-	scan_plan = make_seqscan(tlist,
-							 scan_clauses,
-							 scan_relid);
+	scan_plan = make_seqscan(tlist, scan_clauses, scan_relid);
+	cost_seqscan(best_path, root, rel, best_path->param_info);
 
 	copy_path_costsize(&scan_plan->plan, best_path);
 
@@ -1129,22 +1111,18 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
  * create_bitmap_subplan needs to be able to override the prior decision.
  */
 static Scan *
-create_indexscan_plan(PlannerInfo *root,
-					  IndexPath *best_path,
-					  List *tlist,
-					  List *scan_clauses,
-					  bool indexonly)
-{
-	Scan	   *scan_plan;
-	List	   *indexquals = best_path->indexquals;
-	List	   *indexorderbys = best_path->indexorderbys;
-	Index		baserelid = best_path->path.parent->relid;
-	Oid			indexoid = best_path->indexinfo->indexoid;
-	List	   *qpqual;
-	List	   *stripped_indexquals;
-	List	   *fixed_indexquals;
-	List	   *fixed_indexorderbys;
-	ListCell   *l;
+create_indexscan_plan(PlannerInfo *root, IndexPath *best_path, List *tlist,
+		List *scan_clauses, bool indexonly) {
+	Scan *scan_plan;
+	List *indexquals = best_path->indexquals;
+	List *indexorderbys = best_path->indexorderbys;
+	Index baserelid = best_path->path.parent->relid;
+	Oid indexoid = best_path->indexinfo->indexoid;
+	List *qpqual;
+	List *stripped_indexquals;
+	List *fixed_indexquals;
+	List *fixed_indexorderbys;
+	ListCell *l;
 
 	/* it should be a base rel... */
 	Assert(baserelid > 0);
@@ -1198,30 +1176,26 @@ create_indexscan_plan(PlannerInfo *root,
 	 * plan so that they'll be properly rechecked by EvalPlanQual testing.
 	 */
 	qpqual = NIL;
-	foreach(l, scan_clauses)
-	{
+	foreach(l, scan_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 		Assert(IsA(rinfo, RestrictInfo));
 		if (rinfo->pseudoconstant)
-			continue;			/* we may drop pseudoconstants here */
+			continue; /* we may drop pseudoconstants here */
 		if (list_member_ptr(indexquals, rinfo))
-			continue;			/* simple duplicate */
+			continue; /* simple duplicate */
 		if (is_redundant_derived_clause(rinfo, indexquals))
-			continue;			/* derived from same EquivalenceClass */
-		if (!contain_mutable_functions((Node *) rinfo->clause))
-		{
-			List	   *clausel = list_make1(rinfo->clause);
+			continue; /* derived from same EquivalenceClass */
+		if (!contain_mutable_functions((Node *) rinfo->clause)) {
+			List *clausel = list_make1(rinfo->clause);
 
 			if (predicate_implied_by(clausel, indexquals))
-				continue;		/* provably implied by indexquals */
-			if (best_path->indexinfo->indpred)
-			{
-				if (baserelid != root->parse->resultRelation &&
-					get_parse_rowmark(root->parse, baserelid) == NULL)
-					if (predicate_implied_by(clausel,
-											 best_path->indexinfo->indpred))
-						continue;		/* implied by index predicate */
+				continue; /* provably implied by indexquals */
+			if (best_path->indexinfo->indpred) {
+				if (baserelid != root->parse->resultRelation&&
+				get_parse_rowmark(root->parse, baserelid) == NULL)if (predicate_implied_by(clausel,
+								best_path->indexinfo->indpred))
+				continue; /* implied by index predicate */
 			}
 		}
 		qpqual = lappend(qpqual, rinfo);
@@ -1242,37 +1216,25 @@ create_indexscan_plan(PlannerInfo *root,
 	 * it'd break the comparisons to predicates above ... (or would it?  Those
 	 * wouldn't have outer refs)
 	 */
-	if (best_path->path.param_info)
-	{
-		stripped_indexquals = (List *)
-			replace_nestloop_params(root, (Node *) stripped_indexquals);
-		qpqual = (List *)
-			replace_nestloop_params(root, (Node *) qpqual);
-		indexorderbys = (List *)
-			replace_nestloop_params(root, (Node *) indexorderbys);
+	if (best_path->path.param_info) {
+		stripped_indexquals = (List *) replace_nestloop_params(root,
+				(Node *) stripped_indexquals);
+		qpqual = (List *) replace_nestloop_params(root, (Node *) qpqual);
+		indexorderbys = (List *) replace_nestloop_params(root,
+				(Node *) indexorderbys);
 	}
 
 	/* Finally ready to build the plan node */
 	if (indexonly)
-		scan_plan = (Scan *) make_indexonlyscan(tlist,
-												qpqual,
-												baserelid,
-												indexoid,
-												fixed_indexquals,
-												fixed_indexorderbys,
-											best_path->indexinfo->indextlist,
-												best_path->indexscandir);
+		scan_plan = (Scan *) make_indexonlyscan(tlist, qpqual, baserelid,
+				indexoid, fixed_indexquals, fixed_indexorderbys,
+				best_path->indexinfo->indextlist, best_path->indexscandir);
 	else
-		scan_plan = (Scan *) make_indexscan(tlist,
-											qpqual,
-											baserelid,
-											indexoid,
-											fixed_indexquals,
-											stripped_indexquals,
-											fixed_indexorderbys,
-											indexorderbys,
-											best_path->indexscandir);
+		scan_plan = (Scan *) make_indexscan(tlist, qpqual, baserelid, indexoid,
+				fixed_indexquals, stripped_indexquals, fixed_indexorderbys,
+				indexorderbys, best_path->indexscandir);
 
+	cost_index(best_path, root, best_path->indexinfo->loop_count);
 	copy_path_costsize(&scan_plan->plan, &best_path->path);
 
 	return scan_plan;
@@ -1284,18 +1246,15 @@ create_indexscan_plan(PlannerInfo *root,
  *	  with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static BitmapHeapScan *
-create_bitmap_scan_plan(PlannerInfo *root,
-						BitmapHeapPath *best_path,
-						List *tlist,
-						List *scan_clauses)
-{
-	Index		baserelid = best_path->path.parent->relid;
-	Plan	   *bitmapqualplan;
-	List	   *bitmapqualorig;
-	List	   *indexquals;
-	List	   *indexECs;
-	List	   *qpqual;
-	ListCell   *l;
+create_bitmap_scan_plan(PlannerInfo *root, BitmapHeapPath *best_path,
+		List *tlist, List *scan_clauses) {
+	Index baserelid = best_path->path.parent->relid;
+	Plan *bitmapqualplan;
+	List *bitmapqualorig;
+	List *indexquals;
+	List *indexECs;
+	List *qpqual;
+	ListCell *l;
 	BitmapHeapScan *scan_plan;
 
 	/* it should be a base rel... */
@@ -1304,8 +1263,7 @@ create_bitmap_scan_plan(PlannerInfo *root,
 
 	/* Process the bitmapqual tree into a Plan tree and qual lists */
 	bitmapqualplan = create_bitmap_subplan(root, best_path->bitmapqual,
-										   &bitmapqualorig, &indexquals,
-										   &indexECs);
+			&bitmapqualorig, &indexquals, &indexECs);
 
 	/*
 	 * The qpqual list must contain all restrictions not automatically handled
@@ -1333,24 +1291,22 @@ create_bitmap_scan_plan(PlannerInfo *root,
 	 * the scan becomes lossy, so they have to be included in bitmapqualorig.
 	 */
 	qpqual = NIL;
-	foreach(l, scan_clauses)
-	{
+	foreach(l, scan_clauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
-		Node	   *clause = (Node *) rinfo->clause;
+		Node *clause = (Node *) rinfo->clause;
 
 		Assert(IsA(rinfo, RestrictInfo));
 		if (rinfo->pseudoconstant)
-			continue;			/* we may drop pseudoconstants here */
+			continue; /* we may drop pseudoconstants here */
 		if (list_member(indexquals, clause))
-			continue;			/* simple duplicate */
+			continue; /* simple duplicate */
 		if (rinfo->parent_ec && list_member_ptr(indexECs, rinfo->parent_ec))
-			continue;			/* derived from same EquivalenceClass */
-		if (!contain_mutable_functions(clause))
-		{
-			List	   *clausel = list_make1(clause);
+			continue; /* derived from same EquivalenceClass */
+		if (!contain_mutable_functions(clause)) {
+			List *clausel = list_make1(clause);
 
 			if (predicate_implied_by(clausel, indexquals))
-				continue;		/* provably implied by indexquals */
+				continue; /* provably implied by indexquals */
 		}
 		qpqual = lappend(qpqual, rinfo);
 	}
@@ -1374,20 +1330,15 @@ create_bitmap_scan_plan(PlannerInfo *root,
 	 * the qpqual and bitmapqualorig expressions.  (This was already done for
 	 * expressions attached to plan nodes in the bitmapqualplan tree.)
 	 */
-	if (best_path->path.param_info)
-	{
-		qpqual = (List *)
-			replace_nestloop_params(root, (Node *) qpqual);
-		bitmapqualorig = (List *)
-			replace_nestloop_params(root, (Node *) bitmapqualorig);
+	if (best_path->path.param_info) {
+		qpqual = (List *) replace_nestloop_params(root, (Node *) qpqual);
+		bitmapqualorig = (List *) replace_nestloop_params(root,
+				(Node *) bitmapqualorig);
 	}
 
 	/* Finally ready to build the plan node */
-	scan_plan = make_bitmap_heapscan(tlist,
-									 qpqual,
-									 bitmapqualplan,
-									 bitmapqualorig,
-									 baserelid);
+	scan_plan = make_bitmap_heapscan(tlist, qpqual, bitmapqualplan,
+			bitmapqualorig, baserelid);
 
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
 
@@ -1415,19 +1366,17 @@ create_bitmap_scan_plan(PlannerInfo *root,
  * messy, since we'd have to build new RestrictInfos in many cases.)
  */
 static Plan *
-create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
-					  List **qual, List **indexqual, List **indexECs)
-{
-	Plan	   *plan;
+create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual, List **qual,
+		List **indexqual, List **indexECs) {
+	Plan *plan;
 
-	if (IsA(bitmapqual, BitmapAndPath))
-	{
+	if (IsA(bitmapqual, BitmapAndPath)) {
 		BitmapAndPath *apath = (BitmapAndPath *) bitmapqual;
-		List	   *subplans = NIL;
-		List	   *subquals = NIL;
-		List	   *subindexquals = NIL;
-		List	   *subindexECs = NIL;
-		ListCell   *l;
+		List *subplans = NIL;
+		List *subquals = NIL;
+		List *subindexquals = NIL;
+		List *subindexECs = NIL;
+		ListCell *l;
 
 		/*
 		 * There may well be redundant quals among the subplans, since a
@@ -1435,17 +1384,14 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		 * different index quals.  We don't try exceedingly hard to eliminate
 		 * redundancies, but we do eliminate obvious duplicates by using
 		 * list_concat_unique.
-		 */
-		foreach(l, apath->bitmapquals)
-		{
-			Plan	   *subplan;
-			List	   *subqual;
-			List	   *subindexqual;
-			List	   *subindexEC;
-
-			subplan = create_bitmap_subplan(root, (Path *) lfirst(l),
-											&subqual, &subindexqual,
-											&subindexEC);
+		 */foreach(l, apath->bitmapquals) {
+			Plan *subplan;
+			List *subqual;
+			List *subindexqual;
+			List *subindexEC;
+
+			subplan = create_bitmap_subplan(root, (Path *) lfirst(l), &subqual,
+					&subindexqual, &subindexEC);
 			subplans = lappend(subplans, subplan);
 			subquals = list_concat_unique(subquals, subqual);
 			subindexquals = list_concat_unique(subindexquals, subindexqual);
@@ -1455,22 +1401,20 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		plan = (Plan *) make_bitmap_and(subplans);
 		plan->startup_cost = apath->path.startup_cost;
 		plan->total_cost = apath->path.total_cost;
-		plan->plan_rows =
-			clamp_row_est(apath->bitmapselectivity * apath->path.parent->tuples);
-		plan->plan_width = 0;	/* meaningless */
+		plan->plan_rows = clamp_row_est(
+				apath->bitmapselectivity * apath->path.parent->tuples);
+		plan->plan_width = 0; /* meaningless */
 		*qual = subquals;
 		*indexqual = subindexquals;
 		*indexECs = subindexECs;
-	}
-	else if (IsA(bitmapqual, BitmapOrPath))
-	{
+	} else if (IsA(bitmapqual, BitmapOrPath)) {
 		BitmapOrPath *opath = (BitmapOrPath *) bitmapqual;
-		List	   *subplans = NIL;
-		List	   *subquals = NIL;
-		List	   *subindexquals = NIL;
-		bool		const_true_subqual = false;
-		bool		const_true_subindexqual = false;
-		ListCell   *l;
+		List *subplans = NIL;
+		List *subquals = NIL;
+		List *subindexquals = NIL;
+		bool const_true_subqual = false;
+		bool const_true_subindexqual = false;
+		ListCell *l;
 
 		/*
 		 * Here, we only detect qual-free subplans.  A qual-free subplan would
@@ -1480,46 +1424,39 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		 * well be working with hundreds or even thousands of OR conditions,
 		 * perhaps from a long IN list.  The performance of list_append_unique
 		 * would be unacceptable.
-		 */
-		foreach(l, opath->bitmapquals)
-		{
-			Plan	   *subplan;
-			List	   *subqual;
-			List	   *subindexqual;
-			List	   *subindexEC;
-
-			subplan = create_bitmap_subplan(root, (Path *) lfirst(l),
-											&subqual, &subindexqual,
-											&subindexEC);
+		 */foreach(l, opath->bitmapquals) {
+			Plan *subplan;
+			List *subqual;
+			List *subindexqual;
+			List *subindexEC;
+
+			subplan = create_bitmap_subplan(root, (Path *) lfirst(l), &subqual,
+					&subindexqual, &subindexEC);
 			subplans = lappend(subplans, subplan);
 			if (subqual == NIL)
 				const_true_subqual = true;
 			else if (!const_true_subqual)
-				subquals = lappend(subquals,
-								   make_ands_explicit(subqual));
+				subquals = lappend(subquals, make_ands_explicit(subqual));
 			if (subindexqual == NIL)
 				const_true_subindexqual = true;
 			else if (!const_true_subindexqual)
 				subindexquals = lappend(subindexquals,
-										make_ands_explicit(subindexqual));
+						make_ands_explicit(subindexqual));
 		}
 
 		/*
 		 * In the presence of ScalarArrayOpExpr quals, we might have built
 		 * BitmapOrPaths with just one subpath; don't add an OR step.
 		 */
-		if (list_length(subplans) == 1)
-		{
+		if (list_length(subplans) == 1) {
 			plan = (Plan *) linitial(subplans);
-		}
-		else
-		{
+		} else {
 			plan = (Plan *) make_bitmap_or(subplans);
 			plan->startup_cost = opath->path.startup_cost;
 			plan->total_cost = opath->path.total_cost;
-			plan->plan_rows =
-				clamp_row_est(opath->bitmapselectivity * opath->path.parent->tuples);
-			plan->plan_width = 0;		/* meaningless */
+			plan->plan_rows = clamp_row_est(
+					opath->bitmapselectivity * opath->path.parent->tuples);
+			plan->plan_width = 0; /* meaningless */
 		}
 
 		/*
@@ -1540,33 +1477,28 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 		else
 			*indexqual = list_make1(make_orclause(subindexquals));
 		*indexECs = NIL;
-	}
-	else if (IsA(bitmapqual, IndexPath))
-	{
-		IndexPath  *ipath = (IndexPath *) bitmapqual;
-		IndexScan  *iscan;
-		List	   *subindexECs;
-		ListCell   *l;
+	} else if (IsA(bitmapqual, IndexPath)) {
+		IndexPath *ipath = (IndexPath *) bitmapqual;
+		IndexScan *iscan;
+		List *subindexECs;
+		ListCell *l;
 
 		/* Use the regular indexscan plan build machinery... */
-		iscan = (IndexScan *) create_indexscan_plan(root, ipath,
-													NIL, NIL, false);
+		iscan = (IndexScan *) create_indexscan_plan(root, ipath, NIL, NIL,
+				false);
 		Assert(IsA(iscan, IndexScan));
 		/* then convert to a bitmap indexscan */
 		plan = (Plan *) make_bitmap_indexscan(iscan->scan.scanrelid,
-											  iscan->indexid,
-											  iscan->indexqual,
-											  iscan->indexqualorig);
+				iscan->indexid, iscan->indexqual, iscan->indexqualorig);
 		plan->startup_cost = 0.0;
 		plan->total_cost = ipath->indextotalcost;
-		plan->plan_rows =
-			clamp_row_est(ipath->indexselectivity * ipath->path.parent->tuples);
-		plan->plan_width = 0;	/* meaningless */
+		plan->plan_rows = clamp_row_est(
+				ipath->indexselectivity * ipath->path.parent->tuples);
+		plan->plan_width = 0; /* meaningless */
 		*qual = get_actual_clauses(ipath->indexclauses);
 		*indexqual = get_actual_clauses(ipath->indexquals);
-		foreach(l, ipath->indexinfo->indpred)
-		{
-			Expr	   *pred = (Expr *) lfirst(l);
+		foreach(l, ipath->indexinfo->indpred) {
+			Expr *pred = (Expr *) lfirst(l);
 
 			/*
 			 * We know that the index predicate must have been implied by the
@@ -1574,26 +1506,22 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
 			 * the conditions that got pushed into the bitmapqual.	Avoid
 			 * generating redundant conditions.
 			 */
-			if (!predicate_implied_by(list_make1(pred), ipath->indexclauses))
-			{
+			if (!predicate_implied_by(list_make1(pred), ipath->indexclauses)) {
 				*qual = lappend(*qual, pred);
 				*indexqual = lappend(*indexqual, pred);
 			}
 		}
 		subindexECs = NIL;
-		foreach(l, ipath->indexquals)
-		{
+		foreach(l, ipath->indexquals) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 			if (rinfo->parent_ec)
 				subindexECs = lappend(subindexECs, rinfo->parent_ec);
 		}
 		*indexECs = subindexECs;
-	}
-	else
-	{
+	} else {
 		elog(ERROR, "unrecognized node type: %d", nodeTag(bitmapqual));
-		plan = NULL;			/* keep compiler quiet */
+		plan = NULL; /* keep compiler quiet */
 	}
 
 	return plan;
@@ -1605,13 +1533,13 @@ create_bitmap_subplan(PlannerInfo *root, Path *bitmapqual,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static TidScan *
-create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
-					List *tlist, List *scan_clauses)
-{
-	TidScan    *scan_plan;
-	Index		scan_relid = best_path->path.parent->relid;
-	List	   *tidquals = best_path->tidquals;
-	List	   *ortidquals;
+create_tidscan_plan(PlannerInfo *root, TidPath *best_path, List *tlist,
+		List *scan_clauses) {
+	TidScan *scan_plan;
+	Index scan_relid = best_path->path.parent->relid;
+	List *tidquals = best_path->tidquals;
+	List *ortidquals;
+	;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1624,12 +1552,10 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->path.param_info)
-	{
-		tidquals = (List *)
-			replace_nestloop_params(root, (Node *) tidquals);
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->path.param_info) {
+		tidquals = (List *) replace_nestloop_params(root, (Node *) tidquals);
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
 	/*
@@ -1641,10 +1567,7 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
 		ortidquals = list_make1(make_orclause(ortidquals));
 	scan_clauses = list_difference(scan_clauses, ortidquals);
 
-	scan_plan = make_tidscan(tlist,
-							 scan_clauses,
-							 scan_relid,
-							 tidquals);
+	scan_plan = make_tidscan(tlist, scan_clauses, scan_relid, tidquals);
 
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
 
@@ -1657,11 +1580,10 @@ create_tidscan_plan(PlannerInfo *root, TidPath *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static SubqueryScan *
-create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses)
-{
+create_subqueryscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	SubqueryScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 
 	/* it should be a subquery base rel... */
 	Assert(scan_relid > 0);
@@ -1674,18 +1596,15 @@ create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		process_subquery_nestloop_params(root,
-										 best_path->parent->subplan_params);
+				best_path->parent->subplan_params);
 	}
 
-	scan_plan = make_subqueryscan(tlist,
-								  scan_clauses,
-								  scan_relid,
-								  best_path->parent->subplan);
+	scan_plan = make_subqueryscan(tlist, scan_clauses, scan_relid,
+			best_path->parent->subplan);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1698,13 +1617,12 @@ create_subqueryscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static FunctionScan *
-create_functionscan_plan(PlannerInfo *root, Path *best_path,
-						 List *tlist, List *scan_clauses)
-{
+create_functionscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	FunctionScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	List	   *functions;
+	List *functions;
 
 	/* it should be a function base rel... */
 	Assert(scan_relid > 0);
@@ -1719,16 +1637,15 @@ create_functionscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		/* The function expressions could contain nestloop params, too */
 		functions = (List *) replace_nestloop_params(root, (Node *) functions);
 	}
 
-	scan_plan = make_functionscan(tlist, scan_clauses, scan_relid,
-								  functions, rte->funcordinality);
+	scan_plan = make_functionscan(tlist, scan_clauses, scan_relid, functions,
+			rte->funcordinality);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1741,13 +1658,12 @@ create_functionscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static ValuesScan *
-create_valuesscan_plan(PlannerInfo *root, Path *best_path,
-					   List *tlist, List *scan_clauses)
-{
+create_valuesscan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	ValuesScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	List	   *values_lists;
+	List *values_lists;
 
 	/* it should be a values base rel... */
 	Assert(scan_relid > 0);
@@ -1762,17 +1678,15 @@ create_valuesscan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 		/* The values lists could contain nestloop params, too */
-		values_lists = (List *)
-			replace_nestloop_params(root, (Node *) values_lists);
+		values_lists = (List *) replace_nestloop_params(root,
+				(Node *) values_lists);
 	}
 
-	scan_plan = make_valuesscan(tlist, scan_clauses, scan_relid,
-								values_lists);
+	scan_plan = make_valuesscan(tlist, scan_clauses, scan_relid, values_lists);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1785,19 +1699,18 @@ create_valuesscan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static CteScan *
-create_ctescan_plan(PlannerInfo *root, Path *best_path,
-					List *tlist, List *scan_clauses)
-{
-	CteScan    *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+create_ctescan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
+	CteScan *scan_plan;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	SubPlan    *ctesplan = NULL;
-	int			plan_id;
-	int			cte_param_id;
+	SubPlan *ctesplan = NULL;
+	int plan_id;
+	int cte_param_id;
 	PlannerInfo *cteroot;
-	Index		levelsup;
-	int			ndx;
-	ListCell   *lc;
+	Index levelsup;
+	int ndx;
+	ListCell *lc;
 
 	Assert(scan_relid > 0);
 	rte = planner_rt_fetch(scan_relid, root);
@@ -1809,10 +1722,9 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	 */
 	levelsup = rte->ctelevelsup;
 	cteroot = root;
-	while (levelsup-- > 0)
-	{
+	while (levelsup-- > 0) {
 		cteroot = cteroot->parent_root;
-		if (!cteroot)			/* shouldn't happen */
+		if (!cteroot) /* shouldn't happen */
 			elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	}
 
@@ -1822,27 +1734,25 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	 * So we mustn't use forboth here.
 	 */
 	ndx = 0;
-	foreach(lc, cteroot->parse->cteList)
-	{
+	foreach(lc, cteroot->parse->cteList) {
 		CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);
 
 		if (strcmp(cte->ctename, rte->ctename) == 0)
 			break;
 		ndx++;
 	}
-	if (lc == NULL)				/* shouldn't happen */
+	if (lc == NULL) /* shouldn't happen */
 		elog(ERROR, "could not find CTE \"%s\"", rte->ctename);
 	if (ndx >= list_length(cteroot->cte_plan_ids))
 		elog(ERROR, "could not find plan for CTE \"%s\"", rte->ctename);
 	plan_id = list_nth_int(cteroot->cte_plan_ids, ndx);
 	Assert(plan_id > 0);
-	foreach(lc, cteroot->init_plans)
-	{
+	foreach(lc, cteroot->init_plans) {
 		ctesplan = (SubPlan *) lfirst(lc);
 		if (ctesplan->plan_id == plan_id)
 			break;
 	}
-	if (lc == NULL)				/* shouldn't happen */
+	if (lc == NULL) /* shouldn't happen */
 		elog(ERROR, "could not find plan for CTE \"%s\"", rte->ctename);
 
 	/*
@@ -1858,15 +1768,14 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
-	scan_plan = make_ctescan(tlist, scan_clauses, scan_relid,
-							 plan_id, cte_param_id);
-
+	scan_plan = make_ctescan(tlist, scan_clauses, scan_relid, plan_id,
+			cte_param_id);
+	cost_ctescan(best_path, root, best_path->parent, best_path->param_info);
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
 	return scan_plan;
@@ -1878,13 +1787,12 @@ create_ctescan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static WorkTableScan *
-create_worktablescan_plan(PlannerInfo *root, Path *best_path,
-						  List *tlist, List *scan_clauses)
-{
+create_worktablescan_plan(PlannerInfo *root, Path *best_path, List *tlist,
+		List *scan_clauses) {
 	WorkTableScan *scan_plan;
-	Index		scan_relid = best_path->parent->relid;
+	Index scan_relid = best_path->parent->relid;
 	RangeTblEntry *rte;
-	Index		levelsup;
+	Index levelsup;
 	PlannerInfo *cteroot;
 
 	Assert(scan_relid > 0);
@@ -1898,17 +1806,16 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
 	 * the CTE comes from.
 	 */
 	levelsup = rte->ctelevelsup;
-	if (levelsup == 0)			/* shouldn't happen */
+	if (levelsup == 0) /* shouldn't happen */
 		elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	levelsup--;
 	cteroot = root;
-	while (levelsup-- > 0)
-	{
+	while (levelsup-- > 0) {
 		cteroot = cteroot->parent_root;
-		if (!cteroot)			/* shouldn't happen */
+		if (!cteroot) /* shouldn't happen */
 			elog(ERROR, "bad levelsup for CTE \"%s\"", rte->ctename);
 	}
-	if (cteroot->wt_param_id < 0)		/* shouldn't happen */
+	if (cteroot->wt_param_id < 0) /* shouldn't happen */
 		elog(ERROR, "could not find param ID for CTE \"%s\"", rte->ctename);
 
 	/* Sort clauses into best execution order */
@@ -1918,14 +1825,13 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
 	scan_clauses = extract_actual_clauses(scan_clauses, false);
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->param_info)
-	{
-		scan_clauses = (List *)
-			replace_nestloop_params(root, (Node *) scan_clauses);
+	if (best_path->param_info) {
+		scan_clauses = (List *) replace_nestloop_params(root,
+				(Node *) scan_clauses);
 	}
 
 	scan_plan = make_worktablescan(tlist, scan_clauses, scan_relid,
-								   cteroot->wt_param_id);
+			cteroot->wt_param_id);
 
 	copy_path_costsize(&scan_plan->scan.plan, best_path);
 
@@ -1938,14 +1844,13 @@ create_worktablescan_plan(PlannerInfo *root, Path *best_path,
  *	 with restriction clauses 'scan_clauses' and targetlist 'tlist'.
  */
 static ForeignScan *
-create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
-						List *tlist, List *scan_clauses)
-{
+create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path, List *tlist,
+		List *scan_clauses) {
 	ForeignScan *scan_plan;
 	RelOptInfo *rel = best_path->path.parent;
-	Index		scan_relid = rel->relid;
+	Index scan_relid = rel->relid;
 	RangeTblEntry *rte;
-	int			i;
+	int i;
 
 	/* it should be a base rel... */
 	Assert(scan_relid > 0);
@@ -1967,8 +1872,7 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * rechecked locally).
 	 */
 	scan_plan = rel->fdwroutine->GetForeignPlan(root, rel, rte->relid,
-												best_path,
-												tlist, scan_clauses);
+			best_path, tlist, scan_clauses);
 
 	/* Copy cost data from Path to Plan; no need to make FDW do this */
 	copy_path_costsize(&scan_plan->scan.plan, &best_path->path);
@@ -1980,12 +1884,11 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * from join clauses, so doing this beforehand on the scan_clauses
 	 * wouldn't work.)
 	 */
-	if (best_path->path.param_info)
-	{
-		scan_plan->scan.plan.qual = (List *)
-			replace_nestloop_params(root, (Node *) scan_plan->scan.plan.qual);
-		scan_plan->fdw_exprs = (List *)
-			replace_nestloop_params(root, (Node *) scan_plan->fdw_exprs);
+	if (best_path->path.param_info) {
+		scan_plan->scan.plan.qual = (List *) replace_nestloop_params(root,
+				(Node *) scan_plan->scan.plan.qual);
+		scan_plan->fdw_exprs = (List *) replace_nestloop_params(root,
+				(Node *) scan_plan->fdw_exprs);
 	}
 
 	/*
@@ -1994,10 +1897,8 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	 * out of the API presented to FDWs.
 	 */
 	scan_plan->fsSystemCol = false;
-	for (i = rel->min_attr; i < 0; i++)
-	{
-		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr]))
-		{
+	for (i = rel->min_attr; i < 0; i++) {
+		if (!bms_is_empty(rel->attr_needed[i - rel->min_attr])) {
 			scan_plan->fsSystemCol = true;
 			break;
 		}
@@ -2006,7 +1907,6 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
 	return scan_plan;
 }
 
-
 /*****************************************************************************
  *
  *	JOIN METHODS
@@ -2014,46 +1914,39 @@ create_foreignscan_plan(PlannerInfo *root, ForeignPath *best_path,
  *****************************************************************************/
 
 static NestLoop *
-create_nestloop_plan(PlannerInfo *root,
-					 NestPath *best_path,
-					 Plan *outer_plan,
-					 Plan *inner_plan)
-{
-	NestLoop   *join_plan;
-	List	   *tlist = build_path_tlist(root, &best_path->path);
-	List	   *joinrestrictclauses = best_path->joinrestrictinfo;
-	List	   *joinclauses;
-	List	   *otherclauses;
-	Relids		outerrelids;
-	List	   *nestParams;
-	ListCell   *cell;
-	ListCell   *prev;
-	ListCell   *next;
+create_nestloop_plan(PlannerInfo *root, NestPath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	NestLoop *join_plan;
+	List *tlist = build_path_tlist(root, &best_path->path);
+	List *joinrestrictclauses = best_path->joinrestrictinfo;
+	List *joinclauses;
+	List *otherclauses;
+	Relids outerrelids;
+	List *nestParams;
+	ListCell *cell;
+	ListCell *prev;
+	ListCell *next;
 
 	/* Sort join qual clauses into best execution order */
 	joinrestrictclauses = order_qual_clauses(root, joinrestrictclauses);
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jointype))
-	{
-		extract_actual_join_clauses(joinrestrictclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jointype)) {
+		extract_actual_join_clauses(joinrestrictclauses, &joinclauses,
+				&otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinrestrictclauses, false);
 		otherclauses = NIL;
 	}
 
 	/* Replace any outer-relation variables with nestloop params */
-	if (best_path->path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2063,41 +1956,31 @@ create_nestloop_plan(PlannerInfo *root,
 	outerrelids = best_path->outerjoinpath->parent->relids;
 	nestParams = NIL;
 	prev = NULL;
-	for (cell = list_head(root->curOuterParams); cell; cell = next)
-	{
+	for (cell = list_head(root->curOuterParams); cell; cell = next) {
 		NestLoopParam *nlp = (NestLoopParam *) lfirst(cell);
 
 		next = lnext(cell);
-		if (IsA(nlp->paramval, Var) &&
-			bms_is_member(nlp->paramval->varno, outerrelids))
-		{
-			root->curOuterParams = list_delete_cell(root->curOuterParams,
-													cell, prev);
+		if (IsA(nlp->paramval, Var)
+				&& bms_is_member(nlp->paramval->varno, outerrelids)) {
+			root->curOuterParams = list_delete_cell(root->curOuterParams, cell,
+					prev);
 			nestParams = lappend(nestParams, nlp);
-		}
-		else if (IsA(nlp->paramval, PlaceHolderVar) &&
-				 bms_overlap(((PlaceHolderVar *) nlp->paramval)->phrels,
-							 outerrelids) &&
-				 bms_is_subset(find_placeholder_info(root,
-											(PlaceHolderVar *) nlp->paramval,
-													 false)->ph_eval_at,
-							   outerrelids))
-		{
-			root->curOuterParams = list_delete_cell(root->curOuterParams,
-													cell, prev);
+		} else if (IsA(nlp->paramval, PlaceHolderVar)
+				&& bms_overlap(((PlaceHolderVar *) nlp->paramval)->phrels,
+						outerrelids)
+				&& bms_is_subset(
+						find_placeholder_info(root,
+								(PlaceHolderVar *) nlp->paramval, false)->ph_eval_at,
+						outerrelids)) {
+			root->curOuterParams = list_delete_cell(root->curOuterParams, cell,
+					prev);
 			nestParams = lappend(nestParams, nlp);
-		}
-		else
+		} else
 			prev = cell;
 	}
 
-	join_plan = make_nestloop(tlist,
-							  joinclauses,
-							  otherclauses,
-							  nestParams,
-							  outer_plan,
-							  inner_plan,
-							  best_path->jointype);
+	join_plan = make_nestloop(tlist, joinclauses, otherclauses, nestParams,
+			outer_plan, inner_plan, best_path->jointype);
 
 	copy_path_costsize(&join_plan->join.plan, &best_path->path);
 
@@ -2105,27 +1988,27 @@ create_nestloop_plan(PlannerInfo *root,
 }
 
 static MergeJoin *
-create_mergejoin_plan(PlannerInfo *root,
-					  MergePath *best_path,
-					  Plan *outer_plan,
-					  Plan *inner_plan)
-{
-	List	   *tlist = build_path_tlist(root, &best_path->jpath.path);
-	List	   *joinclauses;
-	List	   *otherclauses;
-	List	   *mergeclauses;
-	List	   *outerpathkeys;
-	List	   *innerpathkeys;
-	int			nClauses;
-	Oid		   *mergefamilies;
-	Oid		   *mergecollations;
-	int		   *mergestrategies;
-	bool	   *mergenullsfirst;
-	MergeJoin  *join_plan;
-	int			i;
-	ListCell   *lc;
-	ListCell   *lop;
-	ListCell   *lip;
+create_mergejoin_plan(PlannerInfo *root, MergePath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	List *tlist = build_path_tlist(root, &best_path->jpath.path);
+	List *joinclauses;
+	List *otherclauses;
+	List *mergeclauses;
+	List *outerpathkeys;
+	List *innerpathkeys;
+//JoinCostWorkspace *workspace =best_path->jpath->path->parent->workspace;
+	int nClauses;
+	Oid *mergefamilies;
+	Oid *mergecollations;
+	int *mergestrategies;
+	bool *mergenullsfirst;
+	MergeJoin *join_plan;
+	int i;
+	ListCell *lc;
+	ListCell *lop;
+	ListCell *lip;
+
+	/* Inject cardinalities for path*/
 
 	/* Sort join qual clauses into best execution order */
 	/* NB: do NOT reorder the mergeclauses */
@@ -2133,13 +2016,9 @@ create_mergejoin_plan(PlannerInfo *root,
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jpath.jointype))
-	{
-		extract_actual_join_clauses(joinclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jpath.jointype)) {
+		extract_actual_join_clauses(joinclauses, &joinclauses, &otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinclauses, false);
 		otherclauses = NIL;
@@ -2156,12 +2035,11 @@ create_mergejoin_plan(PlannerInfo *root,
 	 * Replace any outer-relation variables with nestloop params.  There
 	 * should not be any in the mergeclauses.
 	 */
-	if (best_path->jpath.path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->jpath.path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2170,45 +2048,42 @@ create_mergejoin_plan(PlannerInfo *root,
 	 * outer_is_left status.
 	 */
 	mergeclauses = get_switched_clauses(best_path->path_mergeclauses,
-							 best_path->jpath.outerjoinpath->parent->relids);
+			best_path->jpath.outerjoinpath->parent->relids);
 
 	/*
 	 * Create explicit sort nodes for the outer and inner paths if necessary.
 	 * Make sure there are no excess columns in the inputs if sorting.
 	 */
-	if (best_path->outersortkeys)
-	{
+	if (best_path->outersortkeys) {
 		disuse_physical_tlist(root, outer_plan, best_path->jpath.outerjoinpath);
-		outer_plan = (Plan *)
-			make_sort_from_pathkeys(root,
-									outer_plan,
-									best_path->outersortkeys,
-									-1.0);
+		outer_plan = (Plan *) make_sort_from_pathkeys(root, outer_plan,
+				best_path->outersortkeys, -1.0);
 		outerpathkeys = best_path->outersortkeys;
-	}
-	else
+	} else
 		outerpathkeys = best_path->jpath.outerjoinpath->pathkeys;
 
-	if (best_path->innersortkeys)
-	{
+	if (best_path->innersortkeys) {
 		disuse_physical_tlist(root, inner_plan, best_path->jpath.innerjoinpath);
-		inner_plan = (Plan *)
-			make_sort_from_pathkeys(root,
-									inner_plan,
-									best_path->innersortkeys,
-									-1.0);
+		inner_plan = (Plan *) make_sort_from_pathkeys(root, inner_plan,
+				best_path->innersortkeys, -1.0);
 		innerpathkeys = best_path->innersortkeys;
-	}
-	else
+	} else
 		innerpathkeys = best_path->jpath.innerjoinpath->pathkeys;
 
 	/*
 	 * If specified, add a materialize node to shield the inner plan from the
 	 * need to handle mark/restore.
 	 */
-	if (best_path->materialize_inner)
-	{
-		Plan	   *matplan = (Plan *) make_material(inner_plan);
+	/*
+	 * We recalculate the cost with injection
+	 *
+	 *
+	 * */
+//old_statup_cost = best_path->jpath->path->startup_cost;
+//	old_total_cost= best_path->jpath->path->total_cost;
+// final_cost_mergejoin(root,best_path,workspace,NULL);
+	if (best_path->materialize_inner) {
+		Plan *matplan = (Plan *) make_material(inner_plan);
 
 		/*
 		 * We assume the materialize will not spill to disk, and therefore
@@ -2216,6 +2091,7 @@ create_mergejoin_plan(PlannerInfo *root,
 		 * sync with final_cost_mergejoin.)
 		 */
 		copy_plan_costsize(matplan, inner_plan);
+
 		matplan->total_cost += cpu_operator_cost * matplan->plan_rows;
 
 		inner_plan = matplan;
@@ -2237,26 +2113,22 @@ create_mergejoin_plan(PlannerInfo *root,
 	lop = list_head(outerpathkeys);
 	lip = list_head(innerpathkeys);
 	i = 0;
-	foreach(lc, best_path->path_mergeclauses)
-	{
+	foreach(lc, best_path->path_mergeclauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 		EquivalenceClass *oeclass;
 		EquivalenceClass *ieclass;
-		PathKey    *opathkey;
-		PathKey    *ipathkey;
+		PathKey *opathkey;
+		PathKey *ipathkey;
 		EquivalenceClass *opeclass;
 		EquivalenceClass *ipeclass;
-		ListCell   *l2;
+		ListCell *l2;
 
 		/* fetch outer/inner eclass from mergeclause */
 		Assert(IsA(rinfo, RestrictInfo));
-		if (rinfo->outer_is_left)
-		{
+		if (rinfo->outer_is_left) {
 			oeclass = rinfo->left_ec;
 			ieclass = rinfo->right_ec;
-		}
-		else
-		{
+		} else {
 			oeclass = rinfo->right_ec;
 			ieclass = rinfo->left_ec;
 		}
@@ -2275,20 +2147,15 @@ create_mergejoin_plan(PlannerInfo *root,
 		 * it's okay to match them, or any element before them.  If they're
 		 * NULL then we have found all pathkey elements to be used.
 		 */
-		if (lop)
-		{
+		if (lop) {
 			opathkey = (PathKey *) lfirst(lop);
 			opeclass = opathkey->pk_eclass;
-			if (oeclass == opeclass)
-			{
+			if (oeclass == opeclass) {
 				/* fast path for typical case */
 				lop = lnext(lop);
-			}
-			else
-			{
+			} else {
 				/* redundant clauses ... must match something before lop */
-				foreach(l2, outerpathkeys)
-				{
+				foreach(l2, outerpathkeys) {
 					if (l2 == lop)
 						break;
 					opathkey = (PathKey *) lfirst(l2);
@@ -2299,14 +2166,11 @@ create_mergejoin_plan(PlannerInfo *root,
 				if (oeclass != opeclass)
 					elog(ERROR, "outer pathkeys do not match mergeclauses");
 			}
-		}
-		else
-		{
+		} else {
 			/* redundant clauses ... must match some already-used pathkey */
 			opathkey = NULL;
 			opeclass = NULL;
-			foreach(l2, outerpathkeys)
-			{
+			foreach(l2, outerpathkeys) {
 				opathkey = (PathKey *) lfirst(l2);
 				opeclass = opathkey->pk_eclass;
 				if (oeclass == opeclass)
@@ -2316,20 +2180,15 @@ create_mergejoin_plan(PlannerInfo *root,
 				elog(ERROR, "outer pathkeys do not match mergeclauses");
 		}
 
-		if (lip)
-		{
+		if (lip) {
 			ipathkey = (PathKey *) lfirst(lip);
 			ipeclass = ipathkey->pk_eclass;
-			if (ieclass == ipeclass)
-			{
+			if (ieclass == ipeclass) {
 				/* fast path for typical case */
 				lip = lnext(lip);
-			}
-			else
-			{
+			} else {
 				/* redundant clauses ... must match something before lip */
-				foreach(l2, innerpathkeys)
-				{
+				foreach(l2, innerpathkeys) {
 					if (l2 == lip)
 						break;
 					ipathkey = (PathKey *) lfirst(l2);
@@ -2340,14 +2199,11 @@ create_mergejoin_plan(PlannerInfo *root,
 				if (ieclass != ipeclass)
 					elog(ERROR, "inner pathkeys do not match mergeclauses");
 			}
-		}
-		else
-		{
+		} else {
 			/* redundant clauses ... must match some already-used pathkey */
 			ipathkey = NULL;
 			ipeclass = NULL;
-			foreach(l2, innerpathkeys)
-			{
+			foreach(l2, innerpathkeys) {
 				ipathkey = (PathKey *) lfirst(l2);
 				ipeclass = ipathkey->pk_eclass;
 				if (ieclass == ipeclass)
@@ -2358,10 +2214,11 @@ create_mergejoin_plan(PlannerInfo *root,
 		}
 
 		/* pathkeys should match each other too (more debugging) */
-		if (opathkey->pk_opfamily != ipathkey->pk_opfamily ||
-			opathkey->pk_eclass->ec_collation != ipathkey->pk_eclass->ec_collation ||
-			opathkey->pk_strategy != ipathkey->pk_strategy ||
-			opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
+		if (opathkey->pk_opfamily != ipathkey->pk_opfamily
+				|| opathkey->pk_eclass->ec_collation
+						!= ipathkey->pk_eclass->ec_collation
+				|| opathkey->pk_strategy != ipathkey->pk_strategy
+				|| opathkey->pk_nulls_first != ipathkey->pk_nulls_first)
 			elog(ERROR, "left and right pathkeys do not match in mergejoin");
 
 		/* OK, save info for executor */
@@ -2381,17 +2238,9 @@ create_mergejoin_plan(PlannerInfo *root,
 	/*
 	 * Now we can build the mergejoin node.
 	 */
-	join_plan = make_mergejoin(tlist,
-							   joinclauses,
-							   otherclauses,
-							   mergeclauses,
-							   mergefamilies,
-							   mergecollations,
-							   mergestrategies,
-							   mergenullsfirst,
-							   outer_plan,
-							   inner_plan,
-							   best_path->jpath.jointype);
+	join_plan = make_mergejoin(tlist, joinclauses, otherclauses, mergeclauses,
+			mergefamilies, mergecollations, mergestrategies, mergenullsfirst,
+			outer_plan, inner_plan, best_path->jpath.jointype);
 
 	/* Costs of sort and material steps are included in path cost already */
 	copy_path_costsize(&join_plan->join.plan, &best_path->jpath.path);
@@ -2400,22 +2249,19 @@ create_mergejoin_plan(PlannerInfo *root,
 }
 
 static HashJoin *
-create_hashjoin_plan(PlannerInfo *root,
-					 HashPath *best_path,
-					 Plan *outer_plan,
-					 Plan *inner_plan)
-{
-	List	   *tlist = build_path_tlist(root, &best_path->jpath.path);
-	List	   *joinclauses;
-	List	   *otherclauses;
-	List	   *hashclauses;
-	Oid			skewTable = InvalidOid;
-	AttrNumber	skewColumn = InvalidAttrNumber;
-	bool		skewInherit = false;
-	Oid			skewColType = InvalidOid;
-	int32		skewColTypmod = -1;
-	HashJoin   *join_plan;
-	Hash	   *hash_plan;
+create_hashjoin_plan(PlannerInfo *root, HashPath *best_path, Plan *outer_plan,
+		Plan *inner_plan) {
+	List *tlist = build_path_tlist(root, &best_path->jpath.path);
+	List *joinclauses;
+	List *otherclauses;
+	List *hashclauses;
+	Oid skewTable = InvalidOid;
+	AttrNumber skewColumn = InvalidAttrNumber;
+	bool skewInherit = false;
+	Oid skewColType = InvalidOid;
+	int32 skewColTypmod = -1;
+	HashJoin *join_plan;
+	Hash *hash_plan;
 
 	/* Sort join qual clauses into best execution order */
 	joinclauses = order_qual_clauses(root, best_path->jpath.joinrestrictinfo);
@@ -2423,13 +2269,9 @@ create_hashjoin_plan(PlannerInfo *root,
 
 	/* Get the join qual clauses (in plain expression form) */
 	/* Any pseudoconstant clauses are ignored here */
-	if (IS_OUTER_JOIN(best_path->jpath.jointype))
-	{
-		extract_actual_join_clauses(joinclauses,
-									&joinclauses, &otherclauses);
-	}
-	else
-	{
+	if (IS_OUTER_JOIN(best_path->jpath.jointype)) {
+		extract_actual_join_clauses(joinclauses, &joinclauses, &otherclauses);
+	} else {
 		/* We can treat all clauses alike for an inner join */
 		joinclauses = extract_actual_clauses(joinclauses, false);
 		otherclauses = NIL;
@@ -2446,12 +2288,11 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * Replace any outer-relation variables with nestloop params.  There
 	 * should not be any in the hashclauses.
 	 */
-	if (best_path->jpath.path.param_info)
-	{
-		joinclauses = (List *)
-			replace_nestloop_params(root, (Node *) joinclauses);
-		otherclauses = (List *)
-			replace_nestloop_params(root, (Node *) otherclauses);
+	if (best_path->jpath.path.param_info) {
+		joinclauses = (List *) replace_nestloop_params(root,
+				(Node *) joinclauses);
+		otherclauses = (List *) replace_nestloop_params(root,
+				(Node *) otherclauses);
 	}
 
 	/*
@@ -2459,7 +2300,7 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * on the left.
 	 */
 	hashclauses = get_switched_clauses(best_path->path_hashclauses,
-							 best_path->jpath.outerjoinpath->parent->relids);
+			best_path->jpath.outerjoinpath->parent->relids);
 
 	/* We don't want any excess columns in the hashed tuples */
 	disuse_physical_tlist(root, inner_plan, best_path->jpath.innerjoinpath);
@@ -2476,23 +2317,20 @@ create_hashjoin_plan(PlannerInfo *root,
 	 * most common combinations of outer values, which we don't currently have
 	 * enough stats for.)
 	 */
-	if (list_length(hashclauses) == 1)
-	{
-		OpExpr	   *clause = (OpExpr *) linitial(hashclauses);
-		Node	   *node;
+	if (list_length(hashclauses) == 1) {
+		OpExpr *clause = (OpExpr *) linitial(hashclauses);
+		Node *node;
 
 		Assert(is_opclause(clause));
 		node = (Node *) linitial(clause->args);
 		if (IsA(node, RelabelType))
 			node = (Node *) ((RelabelType *) node)->arg;
-		if (IsA(node, Var))
-		{
-			Var		   *var = (Var *) node;
+		if (IsA(node, Var)) {
+			Var *var = (Var *) node;
 			RangeTblEntry *rte;
 
 			rte = root->simple_rte_array[var->varno];
-			if (rte->rtekind == RTE_RELATION)
-			{
+			if (rte->rtekind == RTE_RELATION) {
 				skewTable = rte->relid;
 				skewColumn = var->varattno;
 				skewInherit = rte->inh;
@@ -2505,26 +2343,16 @@ create_hashjoin_plan(PlannerInfo *root,
 	/*
 	 * Build the hash node and hash join node.
 	 */
-	hash_plan = make_hash(inner_plan,
-						  skewTable,
-						  skewColumn,
-						  skewInherit,
-						  skewColType,
-						  skewColTypmod);
-	join_plan = make_hashjoin(tlist,
-							  joinclauses,
-							  otherclauses,
-							  hashclauses,
-							  outer_plan,
-							  (Plan *) hash_plan,
-							  best_path->jpath.jointype);
+	hash_plan = make_hash(inner_plan, skewTable, skewColumn, skewInherit,
+			skewColType, skewColTypmod);
+	join_plan = make_hashjoin(tlist, joinclauses, otherclauses, hashclauses,
+			outer_plan, (Plan *) hash_plan, best_path->jpath.jointype);
 
 	copy_path_costsize(&join_plan->join.plan, &best_path->jpath.path);
 
 	return join_plan;
 }
 
-
 /*****************************************************************************
  *
  *	SUPPORTING ROUTINES
@@ -2541,23 +2369,20 @@ create_hashjoin_plan(PlannerInfo *root,
  * root->curOuterParams if not already present.
  */
 static Node *
-replace_nestloop_params(PlannerInfo *root, Node *expr)
-{
+replace_nestloop_params(PlannerInfo *root, Node *expr) {
 	/* No setup needed for tree walk, so away we go */
 	return replace_nestloop_params_mutator(expr, root);
 }
 
 static Node *
-replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
-{
+replace_nestloop_params_mutator(Node *node, PlannerInfo *root) {
 	if (node == NULL)
 		return NULL;
-	if (IsA(node, Var))
-	{
-		Var		   *var = (Var *) node;
-		Param	   *param;
+	if (IsA(node, Var)) {
+		Var *var = (Var *) node;
+		Param *param;
 		NestLoopParam *nlp;
-		ListCell   *lc;
+		ListCell *lc;
 
 		/* Upper-level Vars should be long gone at this point */
 		Assert(var->varlevelsup == 0);
@@ -2566,12 +2391,9 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 			return node;
 		/* Create a Param representing the Var */
 		param = assign_nestloop_param_var(root, var);
-		/* Is this param already listed in root->curOuterParams? */
-		foreach(lc, root->curOuterParams)
-		{
+		/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 			nlp = (NestLoopParam *) lfirst(lc);
-			if (nlp->paramno == param->paramid)
-			{
+			if (nlp->paramno == param->paramid) {
 				Assert(equal(var, nlp->paramval));
 				/* Present, so we can just return the Param */
 				return (Node *) param;
@@ -2585,12 +2407,11 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		/* And return the replacement Param */
 		return (Node *) param;
 	}
-	if (IsA(node, PlaceHolderVar))
-	{
+	if (IsA(node, PlaceHolderVar)) {
 		PlaceHolderVar *phv = (PlaceHolderVar *) node;
-		Param	   *param;
+		Param *param;
 		NestLoopParam *nlp;
-		ListCell   *lc;
+		ListCell *lc;
 
 		/* Upper-level PlaceHolderVars should be long gone at this point */
 		Assert(phv->phlevelsup == 0);
@@ -2600,10 +2421,10 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		 * cheap/quick test to see if the PHV might be evaluated in the outer
 		 * rels, and then grab its PlaceHolderInfo to tell for sure.
 		 */
-		if (!bms_overlap(phv->phrels, root->curOuterRels) ||
-		  !bms_is_subset(find_placeholder_info(root, phv, false)->ph_eval_at,
-						 root->curOuterRels))
-		{
+		if (!bms_overlap(phv->phrels, root->curOuterRels)
+				|| !bms_is_subset(
+						find_placeholder_info(root, phv, false)->ph_eval_at,
+						root->curOuterRels)) {
 			/*
 			 * We can't replace the whole PHV, but we might still need to
 			 * replace Vars or PHVs within its expression, in case it ends up
@@ -2622,19 +2443,15 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 			PlaceHolderVar *newphv = makeNode(PlaceHolderVar);
 
 			memcpy(newphv, phv, sizeof(PlaceHolderVar));
-			newphv->phexpr = (Expr *)
-				replace_nestloop_params_mutator((Node *) phv->phexpr,
-												root);
+			newphv->phexpr = (Expr *) replace_nestloop_params_mutator(
+					(Node *) phv->phexpr, root);
 			return (Node *) newphv;
 		}
 		/* Create a Param representing the PlaceHolderVar */
 		param = assign_nestloop_param_placeholdervar(root, phv);
-		/* Is this param already listed in root->curOuterParams? */
-		foreach(lc, root->curOuterParams)
-		{
+		/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 			nlp = (NestLoopParam *) lfirst(lc);
-			if (nlp->paramno == param->paramid)
-			{
+			if (nlp->paramno == param->paramid) {
 				Assert(equal(phv, nlp->paramval));
 				/* Present, so we can just return the Param */
 				return (Node *) param;
@@ -2648,9 +2465,8 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
 		/* And return the replacement Param */
 		return (Node *) param;
 	}
-	return expression_tree_mutator(node,
-								   replace_nestloop_params_mutator,
-								   (void *) root);
+	return expression_tree_mutator(node, replace_nestloop_params_mutator,
+			(void *) root);
 }
 
 /*
@@ -2666,75 +2482,62 @@ replace_nestloop_params_mutator(Node *node, PlannerInfo *root)
  * do need to do is add entries to root->curOuterParams to signal the parent
  * nestloop plan node that it must provide these values.
  */
-static void
-process_subquery_nestloop_params(PlannerInfo *root, List *subplan_params)
-{
-	ListCell   *ppl;
+static void process_subquery_nestloop_params(PlannerInfo *root,
+		List *subplan_params) {
+	ListCell *ppl;
 
-	foreach(ppl, subplan_params)
-	{
+	foreach(ppl, subplan_params) {
 		PlannerParamItem *pitem = (PlannerParamItem *) lfirst(ppl);
 
-		if (IsA(pitem->item, Var))
-		{
-			Var		   *var = (Var *) pitem->item;
+		if (IsA(pitem->item, Var)) {
+			Var *var = (Var *) pitem->item;
 			NestLoopParam *nlp;
-			ListCell   *lc;
+			ListCell *lc;
 
 			/* If not from a nestloop outer rel, complain */
 			if (!bms_is_member(var->varno, root->curOuterRels))
 				elog(ERROR, "non-LATERAL parameter required by subquery");
-			/* Is this param already listed in root->curOuterParams? */
-			foreach(lc, root->curOuterParams)
-			{
+			/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 				nlp = (NestLoopParam *) lfirst(lc);
-				if (nlp->paramno == pitem->paramId)
-				{
+				if (nlp->paramno == pitem->paramId) {
 					Assert(equal(var, nlp->paramval));
 					/* Present, so nothing to do */
 					break;
 				}
 			}
-			if (lc == NULL)
-			{
+			if (lc == NULL) {
 				/* No, so add it */
 				nlp = makeNode(NestLoopParam);
 				nlp->paramno = pitem->paramId;
 				nlp->paramval = copyObject(var);
 				root->curOuterParams = lappend(root->curOuterParams, nlp);
 			}
-		}
-		else if (IsA(pitem->item, PlaceHolderVar))
-		{
+		} else if (IsA(pitem->item, PlaceHolderVar)) {
 			PlaceHolderVar *phv = (PlaceHolderVar *) pitem->item;
 			NestLoopParam *nlp;
-			ListCell   *lc;
+			ListCell *lc;
 
 			/* If not from a nestloop outer rel, complain */
-			if (!bms_is_subset(find_placeholder_info(root, phv, false)->ph_eval_at,
-							   root->curOuterRels))
+			if (!bms_is_subset(
+					find_placeholder_info(root, phv, false)->ph_eval_at,
+					root->curOuterRels))
 				elog(ERROR, "non-LATERAL parameter required by subquery");
-			/* Is this param already listed in root->curOuterParams? */
-			foreach(lc, root->curOuterParams)
-			{
+			/* Is this param already listed in root->curOuterParams? */foreach(lc, root->curOuterParams) {
 				nlp = (NestLoopParam *) lfirst(lc);
-				if (nlp->paramno == pitem->paramId)
-				{
+				if (nlp->paramno == pitem->paramId) {
 					Assert(equal(phv, nlp->paramval));
 					/* Present, so nothing to do */
 					break;
 				}
 			}
-			if (lc == NULL)
-			{
+			if (lc == NULL) {
 				/* No, so add it */
 				nlp = makeNode(NestLoopParam);
 				nlp->paramno = pitem->paramId;
 				nlp->paramval = copyObject(phv);
 				root->curOuterParams = lappend(root->curOuterParams, nlp);
 			}
-		}
-		else
+		} else
 			elog(ERROR, "unexpected type of subquery parameter");
 	}
 }
@@ -2759,20 +2562,17 @@ process_subquery_nestloop_params(PlannerInfo *root, List *subplan_params)
  * two separate copies of the subplan tree, or things will go awry).
  */
 static List *
-fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
-{
+fix_indexqual_references(PlannerInfo *root, IndexPath *index_path) {
 	IndexOptInfo *index = index_path->indexinfo;
-	List	   *fixed_indexquals;
-	ListCell   *lcc,
-			   *lci;
+	List *fixed_indexquals;
+	ListCell *lcc, *lci;
 
 	fixed_indexquals = NIL;
 
-	forboth(lcc, index_path->indexquals, lci, index_path->indexqualcols)
-	{
+	forboth(lcc, index_path->indexquals, lci, index_path->indexqualcols) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lcc);
-		int			indexcol = lfirst_int(lci);
-		Node	   *clause;
+		int indexcol = lfirst_int(lci);
+		Node *clause;
 
 		Assert(IsA(rinfo, RestrictInfo));
 
@@ -2784,9 +2584,8 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 		 */
 		clause = replace_nestloop_params(root, (Node *) rinfo->clause);
 
-		if (IsA(clause, OpExpr))
-		{
-			OpExpr	   *op = (OpExpr *) clause;
+		if (IsA(clause, OpExpr)) {
+			OpExpr *op = (OpExpr *) clause;
 
 			if (list_length(op->args) != 2)
 				elog(ERROR, "indexqual clause is not binary opclause");
@@ -2803,26 +2602,19 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expression with an index Var.
 			 */
 			linitial(op->args) = fix_indexqual_operand(linitial(op->args),
-													   index,
-													   indexcol);
-		}
-		else if (IsA(clause, RowCompareExpr))
-		{
+					index, indexcol);
+		} else if (IsA(clause, RowCompareExpr)) {
 			RowCompareExpr *rc = (RowCompareExpr *) clause;
-			Expr	   *newrc;
-			List	   *indexcolnos;
-			bool		var_on_left;
-			ListCell   *lca,
-					   *lcai;
+			Expr *newrc;
+			List *indexcolnos;
+			bool var_on_left;
+			ListCell *lca, *lcai;
 
 			/*
 			 * Re-discover which index columns are used in the rowcompare.
 			 */
-			newrc = adjust_rowcompare_for_index(rc,
-												index,
-												indexcol,
-												&indexcolnos,
-												&var_on_left);
+			newrc = adjust_rowcompare_for_index(rc, index, indexcol,
+					&indexcolnos, &var_on_left);
 
 			/*
 			 * Trouble if adjust_rowcompare_for_index thought the
@@ -2830,7 +2622,8 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * have gone through that routine already.
 			 */
 			if (newrc != (Expr *) rc)
-				elog(ERROR, "inconsistent results from adjust_rowcompare_for_index");
+				elog(ERROR,
+						"inconsistent results from adjust_rowcompare_for_index");
 
 			/*
 			 * Check to see if the indexkey is on the right; if so, commute
@@ -2843,36 +2636,27 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expressions with index Vars.
 			 */
 			Assert(list_length(rc->largs) == list_length(indexcolnos));
-			forboth(lca, rc->largs, lcai, indexcolnos)
-			{
-				lfirst(lca) = fix_indexqual_operand(lfirst(lca),
-													index,
-													lfirst_int(lcai));
+			forboth(lca, rc->largs, lcai, indexcolnos) {
+				lfirst(lca) = fix_indexqual_operand(lfirst(lca), index,
+						lfirst_int(lcai));
 			}
-		}
-		else if (IsA(clause, ScalarArrayOpExpr))
-		{
+		} else if (IsA(clause, ScalarArrayOpExpr)) {
 			ScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;
 
 			/* Never need to commute... */
 
 			/* Replace the indexkey expression with an index Var. */
 			linitial(saop->args) = fix_indexqual_operand(linitial(saop->args),
-														 index,
-														 indexcol);
-		}
-		else if (IsA(clause, NullTest))
-		{
-			NullTest   *nt = (NullTest *) clause;
+					index, indexcol);
+		} else if (IsA(clause, NullTest)) {
+			NullTest *nt = (NullTest *) clause;
 
 			/* Replace the indexkey expression with an index Var. */
-			nt->arg = (Expr *) fix_indexqual_operand((Node *) nt->arg,
-													 index,
-													 indexcol);
-		}
-		else
-			elog(ERROR, "unsupported indexqual type: %d",
-				 (int) nodeTag(clause));
+			nt->arg = (Expr *) fix_indexqual_operand((Node *) nt->arg, index,
+					indexcol);
+		} else
+			elog(ERROR,
+					"unsupported indexqual type: %d", (int) nodeTag(clause));
 
 		fixed_indexquals = lappend(fixed_indexquals, clause);
 	}
@@ -2892,19 +2676,16 @@ fix_indexqual_references(PlannerInfo *root, IndexPath *index_path)
  * is allowed for ordering operators.
  */
 static List *
-fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
-{
+fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path) {
 	IndexOptInfo *index = index_path->indexinfo;
-	List	   *fixed_indexorderbys;
-	ListCell   *lcc,
-			   *lci;
+	List *fixed_indexorderbys;
+	ListCell *lcc, *lci;
 
 	fixed_indexorderbys = NIL;
 
-	forboth(lcc, index_path->indexorderbys, lci, index_path->indexorderbycols)
-	{
-		Node	   *clause = (Node *) lfirst(lcc);
-		int			indexcol = lfirst_int(lci);
+	forboth(lcc, index_path->indexorderbys, lci, index_path->indexorderbycols) {
+		Node *clause = (Node *) lfirst(lcc);
+		int indexcol = lfirst_int(lci);
 
 		/*
 		 * Replace any outer-relation variables with nestloop params.
@@ -2914,9 +2695,8 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
 		 */
 		clause = replace_nestloop_params(root, clause);
 
-		if (IsA(clause, OpExpr))
-		{
-			OpExpr	   *op = (OpExpr *) clause;
+		if (IsA(clause, OpExpr)) {
+			OpExpr *op = (OpExpr *) clause;
 
 			if (list_length(op->args) != 2)
 				elog(ERROR, "indexorderby clause is not binary opclause");
@@ -2925,12 +2705,10 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
 			 * Now replace the indexkey expression with an index Var.
 			 */
 			linitial(op->args) = fix_indexqual_operand(linitial(op->args),
-													   index,
-													   indexcol);
-		}
-		else
-			elog(ERROR, "unsupported indexorderby type: %d",
-				 (int) nodeTag(clause));
+					index, indexcol);
+		} else
+			elog(ERROR,
+					"unsupported indexorderby type: %d", (int) nodeTag(clause));
 
 		fixed_indexorderbys = lappend(fixed_indexorderbys, clause);
 	}
@@ -2949,11 +2727,10 @@ fix_indexorderby_references(PlannerInfo *root, IndexPath *index_path)
  * expression actually matches the index column it's claimed to.
  */
 static Node *
-fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
-{
-	Var		   *result;
-	int			pos;
-	ListCell   *indexpr_item;
+fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol) {
+	Var *result;
+	int pos;
+	ListCell *indexpr_item;
 
 	/*
 	 * Remove any binary-compatible relabeling of the indexkey
@@ -2963,47 +2740,38 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
 
 	Assert(indexcol >= 0 && indexcol < index->ncolumns);
 
-	if (index->indexkeys[indexcol] != 0)
-	{
+	if (index->indexkeys[indexcol] != 0) {
 		/* It's a simple index column */
-		if (IsA(node, Var) &&
-			((Var *) node)->varno == index->rel->relid &&
-			((Var *) node)->varattno == index->indexkeys[indexcol])
-		{
+		if (IsA(node, Var) && ((Var *) node)->varno == index->rel->relid
+				&& ((Var *) node)->varattno == index->indexkeys[indexcol]) {
 			result = (Var *) copyObject(node);
 			result->varno = INDEX_VAR;
 			result->varattno = indexcol + 1;
 			return (Node *) result;
-		}
-		else
+		} else
 			elog(ERROR, "index key does not match expected index column");
 	}
 
 	/* It's an index expression, so find and cross-check the expression */
 	indexpr_item = list_head(index->indexprs);
-	for (pos = 0; pos < index->ncolumns; pos++)
-	{
-		if (index->indexkeys[pos] == 0)
-		{
+	for (pos = 0; pos < index->ncolumns; pos++) {
+		if (index->indexkeys[pos] == 0) {
 			if (indexpr_item == NULL)
 				elog(ERROR, "too few entries in indexprs list");
-			if (pos == indexcol)
-			{
-				Node	   *indexkey;
+			if (pos == indexcol) {
+				Node *indexkey;
 
 				indexkey = (Node *) lfirst(indexpr_item);
 				if (indexkey && IsA(indexkey, RelabelType))
 					indexkey = (Node *) ((RelabelType *) indexkey)->arg;
-				if (equal(node, indexkey))
-				{
+				if (equal(node, indexkey)) {
 					result = makeVar(INDEX_VAR, indexcol + 1,
-									 exprType(lfirst(indexpr_item)), -1,
-									 exprCollation(lfirst(indexpr_item)),
-									 0);
+							exprType(lfirst(indexpr_item)), -1,
+							exprCollation(lfirst(indexpr_item)), 0);
 					return (Node *) result;
-				}
-				else
-					elog(ERROR, "index key does not match expected index column");
+				} else
+					elog(ERROR,
+							"index key does not match expected index column");
 			}
 			indexpr_item = lnext(indexpr_item);
 		}
@@ -3011,7 +2779,7 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
 
 	/* Ooops... */
 	elog(ERROR, "index key does not match expected index column");
-	return NULL;				/* keep compiler quiet */
+	return NULL; /* keep compiler quiet */
 }
 
 /*
@@ -3024,25 +2792,22 @@ fix_indexqual_operand(Node *node, IndexOptInfo *index, int indexcol)
  *	  outer_is_left field in each RestrictInfo to show which side was which.
  */
 static List *
-get_switched_clauses(List *clauses, Relids outerrelids)
-{
-	List	   *t_list = NIL;
-	ListCell   *l;
+get_switched_clauses(List *clauses, Relids outerrelids) {
+	List *t_list = NIL;
+	ListCell *l;
 
-	foreach(l, clauses)
-	{
+	foreach(l, clauses) {
 		RestrictInfo *restrictinfo = (RestrictInfo *) lfirst(l);
-		OpExpr	   *clause = (OpExpr *) restrictinfo->clause;
+		OpExpr *clause = (OpExpr *) restrictinfo->clause;
 
 		Assert(is_opclause(clause));
-		if (bms_is_subset(restrictinfo->right_relids, outerrelids))
-		{
+		if (bms_is_subset(restrictinfo->right_relids, outerrelids)) {
 			/*
 			 * Duplicate just enough of the structure to allow commuting the
 			 * clause without changing the original list.  Could use
 			 * copyObject, but a complete deep copy is overkill.
 			 */
-			OpExpr	   *temp = makeNode(OpExpr);
+			OpExpr *temp = makeNode(OpExpr);
 
 			temp->opno = clause->opno;
 			temp->opfuncid = InvalidOid;
@@ -3056,10 +2821,8 @@ get_switched_clauses(List *clauses, Relids outerrelids)
 			CommuteOpExpr(temp);
 			t_list = lappend(t_list, temp);
 			restrictinfo->outer_is_left = false;
-		}
-		else
-		{
-			Assert(bms_is_subset(restrictinfo->left_relids, outerrelids));
+		} else {
+			Assert( bms_is_subset(restrictinfo->left_relids, outerrelids));
 			t_list = lappend(t_list, clause);
 			restrictinfo->outer_is_left = true;
 		}
@@ -3090,18 +2853,16 @@ get_switched_clauses(List *clauses, Relids outerrelids)
  * a cost/selectivity combination would likely do the wrong thing.
  */
 static List *
-order_qual_clauses(PlannerInfo *root, List *clauses)
-{
-	typedef struct
-	{
-		Node	   *clause;
-		Cost		cost;
+order_qual_clauses(PlannerInfo *root, List *clauses) {
+	typedef struct {
+		Node *clause;
+		Cost cost;
 	} QualItem;
-	int			nitems = list_length(clauses);
-	QualItem   *items;
-	ListCell   *lc;
-	int			i;
-	List	   *result;
+	int nitems = list_length(clauses);
+	QualItem *items;
+	ListCell *lc;
+	int i;
+	List *result;
 
 	/* No need to work hard for 0 or 1 clause */
 	if (nitems <= 1)
@@ -3113,10 +2874,9 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
 	 */
 	items = (QualItem *) palloc(nitems * sizeof(QualItem));
 	i = 0;
-	foreach(lc, clauses)
-	{
-		Node	   *clause = (Node *) lfirst(lc);
-		QualCost	qcost;
+	foreach(lc, clauses) {
+		Node *clause = (Node *) lfirst(lc);
+		QualCost qcost;
 
 		cost_qual_eval_node(&qcost, clause, root);
 		items[i].clause = clause;
@@ -3129,14 +2889,12 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
 	 * equal keys.	The expected number of entries is small enough that a
 	 * simple insertion sort should be good enough.
 	 */
-	for (i = 1; i < nitems; i++)
-	{
-		QualItem	newitem = items[i];
-		int			j;
+	for (i = 1; i < nitems; i++) {
+		QualItem newitem = items[i];
+		int j;
 
 		/* insert newitem into the already-sorted subarray */
-		for (j = i; j > 0; j--)
-		{
+		for (j = i; j > 0; j--) {
 			if (newitem.cost >= items[j - 1].cost)
 				break;
 			items[j] = items[j - 1];
@@ -3156,18 +2914,14 @@ order_qual_clauses(PlannerInfo *root, List *clauses)
  * Copy cost and size info from a Path node to the Plan node created from it.
  * The executor usually won't use this info, but it's needed by EXPLAIN.
  */
-static void
-copy_path_costsize(Plan *dest, Path *src)
-{
-	if (src)
-	{
+static void copy_path_costsize(Plan *dest, Path *src) {
+	if (src) {
 		dest->startup_cost = src->startup_cost;
-		dest->total_cost = src->total_cost;
+		dest->total_cost =
+				(src->mtotal_cost == 0) ? src->total_cost : src->mtotal_cost;
 		dest->plan_rows = src->rows;
 		dest->plan_width = src->parent->width;
-	}
-	else
-	{
+	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
@@ -3179,18 +2933,13 @@ copy_path_costsize(Plan *dest, Path *src)
  * Copy cost and size info from a lower plan node to an inserted node.
  * (Most callers alter the info after copying it.)
  */
-static void
-copy_plan_costsize(Plan *dest, Plan *src)
-{
-	if (src)
-	{
+static void copy_plan_costsize(Plan *dest, Plan *src) {
+	if (src) {
 		dest->startup_cost = src->startup_cost;
 		dest->total_cost = src->total_cost;
 		dest->plan_rows = src->plan_rows;
 		dest->plan_width = src->plan_width;
-	}
-	else
-	{
+	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
@@ -3198,7 +2947,6 @@ copy_plan_costsize(Plan *dest, Plan *src)
 	}
 }
 
-
 /*****************************************************************************
  *
  *	PLAN NODE BUILDING ROUTINES
@@ -3209,12 +2957,9 @@ copy_plan_costsize(Plan *dest, Plan *src)
  *****************************************************************************/
 
 static SeqScan *
-make_seqscan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid)
-{
-	SeqScan    *node = makeNode(SeqScan);
-	Plan	   *plan = &node->plan;
+make_seqscan(List *qptlist, List *qpqual, Index scanrelid) {
+	SeqScan *node = makeNode(SeqScan);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3227,18 +2972,11 @@ make_seqscan(List *qptlist,
 }
 
 static IndexScan *
-make_indexscan(List *qptlist,
-			   List *qpqual,
-			   Index scanrelid,
-			   Oid indexid,
-			   List *indexqual,
-			   List *indexqualorig,
-			   List *indexorderby,
-			   List *indexorderbyorig,
-			   ScanDirection indexscandir)
-{
-	IndexScan  *node = makeNode(IndexScan);
-	Plan	   *plan = &node->scan.plan;
+make_indexscan(List *qptlist, List *qpqual, Index scanrelid, Oid indexid,
+		List *indexqual, List *indexqualorig, List *indexorderby,
+		List *indexorderbyorig, ScanDirection indexscandir) {
+	IndexScan *node = makeNode(IndexScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3257,17 +2995,11 @@ make_indexscan(List *qptlist,
 }
 
 static IndexOnlyScan *
-make_indexonlyscan(List *qptlist,
-				   List *qpqual,
-				   Index scanrelid,
-				   Oid indexid,
-				   List *indexqual,
-				   List *indexorderby,
-				   List *indextlist,
-				   ScanDirection indexscandir)
-{
+make_indexonlyscan(List *qptlist, List *qpqual, Index scanrelid, Oid indexid,
+		List *indexqual, List *indexorderby, List *indextlist,
+		ScanDirection indexscandir) {
 	IndexOnlyScan *node = makeNode(IndexOnlyScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3285,17 +3017,14 @@ make_indexonlyscan(List *qptlist,
 }
 
 static BitmapIndexScan *
-make_bitmap_indexscan(Index scanrelid,
-					  Oid indexid,
-					  List *indexqual,
-					  List *indexqualorig)
-{
+make_bitmap_indexscan(Index scanrelid, Oid indexid, List *indexqual,
+		List *indexqualorig) {
 	BitmapIndexScan *node = makeNode(BitmapIndexScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
-	plan->targetlist = NIL;		/* not used */
-	plan->qual = NIL;			/* not used */
+	plan->targetlist = NIL; /* not used */
+	plan->qual = NIL; /* not used */
 	plan->lefttree = NULL;
 	plan->righttree = NULL;
 	node->scan.scanrelid = scanrelid;
@@ -3307,14 +3036,10 @@ make_bitmap_indexscan(Index scanrelid,
 }
 
 static BitmapHeapScan *
-make_bitmap_heapscan(List *qptlist,
-					 List *qpqual,
-					 Plan *lefttree,
-					 List *bitmapqualorig,
-					 Index scanrelid)
-{
+make_bitmap_heapscan(List *qptlist, List *qpqual, Plan *lefttree,
+		List *bitmapqualorig, Index scanrelid) {
 	BitmapHeapScan *node = makeNode(BitmapHeapScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3328,13 +3053,9 @@ make_bitmap_heapscan(List *qptlist,
 }
 
 static TidScan *
-make_tidscan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid,
-			 List *tidquals)
-{
-	TidScan    *node = makeNode(TidScan);
-	Plan	   *plan = &node->scan.plan;
+make_tidscan(List *qptlist, List *qpqual, Index scanrelid, List *tidquals) {
+	TidScan *node = makeNode(TidScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3348,13 +3069,9 @@ make_tidscan(List *qptlist,
 }
 
 SubqueryScan *
-make_subqueryscan(List *qptlist,
-				  List *qpqual,
-				  Index scanrelid,
-				  Plan *subplan)
-{
+make_subqueryscan(List *qptlist, List *qpqual, Index scanrelid, Plan *subplan) {
 	SubqueryScan *node = makeNode(SubqueryScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/*
 	 * Cost is figured here for the convenience of prepunion.c.  Note this is
@@ -3375,14 +3092,10 @@ make_subqueryscan(List *qptlist,
 }
 
 static FunctionScan *
-make_functionscan(List *qptlist,
-				  List *qpqual,
-				  Index scanrelid,
-				  List *functions,
-				  bool funcordinality)
-{
+make_functionscan(List *qptlist, List *qpqual, Index scanrelid, List *functions,
+		bool funcordinality) {
 	FunctionScan *node = makeNode(FunctionScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3397,13 +3110,10 @@ make_functionscan(List *qptlist,
 }
 
 static ValuesScan *
-make_valuesscan(List *qptlist,
-				List *qpqual,
-				Index scanrelid,
-				List *values_lists)
-{
+make_valuesscan(List *qptlist, List *qpqual, Index scanrelid,
+		List *values_lists) {
 	ValuesScan *node = makeNode(ValuesScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3417,14 +3127,10 @@ make_valuesscan(List *qptlist,
 }
 
 static CteScan *
-make_ctescan(List *qptlist,
-			 List *qpqual,
-			 Index scanrelid,
-			 int ctePlanId,
-			 int cteParam)
-{
-	CteScan    *node = makeNode(CteScan);
-	Plan	   *plan = &node->scan.plan;
+make_ctescan(List *qptlist, List *qpqual, Index scanrelid, int ctePlanId,
+		int cteParam) {
+	CteScan *node = makeNode(CteScan);
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3439,13 +3145,9 @@ make_ctescan(List *qptlist,
 }
 
 static WorkTableScan *
-make_worktablescan(List *qptlist,
-				   List *qpqual,
-				   Index scanrelid,
-				   int wtParam)
-{
+make_worktablescan(List *qptlist, List *qpqual, Index scanrelid, int wtParam) {
 	WorkTableScan *node = makeNode(WorkTableScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = qptlist;
@@ -3459,14 +3161,10 @@ make_worktablescan(List *qptlist,
 }
 
 ForeignScan *
-make_foreignscan(List *qptlist,
-				 List *qpqual,
-				 Index scanrelid,
-				 List *fdw_exprs,
-				 List *fdw_private)
-{
+make_foreignscan(List *qptlist, List *qpqual, Index scanrelid, List *fdw_exprs,
+		List *fdw_private) {
 	ForeignScan *node = makeNode(ForeignScan);
-	Plan	   *plan = &node->scan.plan;
+	Plan *plan = &node->scan.plan;
 
 	/* cost will be filled in by create_foreignscan_plan */
 	plan->targetlist = qptlist;
@@ -3483,12 +3181,11 @@ make_foreignscan(List *qptlist,
 }
 
 Append *
-make_append(List *appendplans, List *tlist)
-{
-	Append	   *node = makeNode(Append);
-	Plan	   *plan = &node->plan;
-	double		total_size;
-	ListCell   *subnode;
+make_append(List *appendplans, List *tlist) {
+	Append *node = makeNode(Append);
+	Plan *plan = &node->plan;
+	double total_size;
+	ListCell *subnode;
 
 	/*
 	 * Compute cost as sum of subplan costs.  We charge nothing extra for the
@@ -3505,11 +3202,10 @@ make_append(List *appendplans, List *tlist)
 	plan->total_cost = 0;
 	plan->plan_rows = 0;
 	total_size = 0;
-	foreach(subnode, appendplans)
-	{
-		Plan	   *subplan = (Plan *) lfirst(subnode);
+	foreach(subnode, appendplans) {
+		Plan *subplan = (Plan *) lfirst(subnode);
 
-		if (subnode == list_head(appendplans))	/* first node? */
+		if (subnode == list_head(appendplans)) /* first node? */
 			plan->startup_cost = subplan->startup_cost;
 		plan->total_cost += subplan->total_cost;
 		plan->plan_rows += subplan->plan_rows;
@@ -3530,16 +3226,11 @@ make_append(List *appendplans, List *tlist)
 }
 
 RecursiveUnion *
-make_recursive_union(List *tlist,
-					 Plan *lefttree,
-					 Plan *righttree,
-					 int wtParam,
-					 List *distinctList,
-					 long numGroups)
-{
+make_recursive_union(List *tlist, Plan *lefttree, Plan *righttree, int wtParam,
+		List *distinctList, long numGroups) {
 	RecursiveUnion *node = makeNode(RecursiveUnion);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
 
 	cost_recursive_union(plan, lefttree, righttree);
 
@@ -3554,21 +3245,19 @@ make_recursive_union(List *tlist,
 	 * operators, as wanted by executor
 	 */
 	node->numCols = numCols;
-	if (numCols > 0)
-	{
-		int			keyno = 0;
+	if (numCols > 0) {
+		int keyno = 0;
 		AttrNumber *dupColIdx;
-		Oid		   *dupOperators;
-		ListCell   *slitem;
+		Oid *dupOperators;
+		ListCell *slitem;
 
 		dupColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 		dupOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-		foreach(slitem, distinctList)
-		{
+		foreach(slitem, distinctList) {
 			SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 			TargetEntry *tle = get_sortgroupclause_tle(sortcl,
-													   plan->targetlist);
+					plan->targetlist);
 
 			dupColIdx[keyno] = tle->resno;
 			dupOperators[keyno] = sortcl->eqop;
@@ -3584,10 +3273,9 @@ make_recursive_union(List *tlist,
 }
 
 static BitmapAnd *
-make_bitmap_and(List *bitmapplans)
-{
-	BitmapAnd  *node = makeNode(BitmapAnd);
-	Plan	   *plan = &node->plan;
+make_bitmap_and(List *bitmapplans) {
+	BitmapAnd *node = makeNode(BitmapAnd);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = NIL;
@@ -3600,10 +3288,9 @@ make_bitmap_and(List *bitmapplans)
 }
 
 static BitmapOr *
-make_bitmap_or(List *bitmapplans)
-{
-	BitmapOr   *node = makeNode(BitmapOr);
-	Plan	   *plan = &node->plan;
+make_bitmap_or(List *bitmapplans) {
+	BitmapOr *node = makeNode(BitmapOr);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = NIL;
@@ -3616,16 +3303,10 @@ make_bitmap_or(List *bitmapplans)
 }
 
 static NestLoop *
-make_nestloop(List *tlist,
-			  List *joinclauses,
-			  List *otherclauses,
-			  List *nestParams,
-			  Plan *lefttree,
-			  Plan *righttree,
-			  JoinType jointype)
-{
-	NestLoop   *node = makeNode(NestLoop);
-	Plan	   *plan = &node->join.plan;
+make_nestloop(List *tlist, List *joinclauses, List *otherclauses,
+		List *nestParams, Plan *lefttree, Plan *righttree, JoinType jointype) {
+	NestLoop *node = makeNode(NestLoop);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3640,16 +3321,10 @@ make_nestloop(List *tlist,
 }
 
 static HashJoin *
-make_hashjoin(List *tlist,
-			  List *joinclauses,
-			  List *otherclauses,
-			  List *hashclauses,
-			  Plan *lefttree,
-			  Plan *righttree,
-			  JoinType jointype)
-{
-	HashJoin   *node = makeNode(HashJoin);
-	Plan	   *plan = &node->join.plan;
+make_hashjoin(List *tlist, List *joinclauses, List *otherclauses,
+		List *hashclauses, Plan *lefttree, Plan *righttree, JoinType jointype) {
+	HashJoin *node = makeNode(HashJoin);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3664,15 +3339,10 @@ make_hashjoin(List *tlist,
 }
 
 static Hash *
-make_hash(Plan *lefttree,
-		  Oid skewTable,
-		  AttrNumber skewColumn,
-		  bool skewInherit,
-		  Oid skewColType,
-		  int32 skewColTypmod)
-{
-	Hash	   *node = makeNode(Hash);
-	Plan	   *plan = &node->plan;
+make_hash(Plan *lefttree, Oid skewTable, AttrNumber skewColumn,
+		bool skewInherit, Oid skewColType, int32 skewColTypmod) {
+	Hash *node = makeNode(Hash);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -3696,20 +3366,12 @@ make_hash(Plan *lefttree,
 }
 
 static MergeJoin *
-make_mergejoin(List *tlist,
-			   List *joinclauses,
-			   List *otherclauses,
-			   List *mergeclauses,
-			   Oid *mergefamilies,
-			   Oid *mergecollations,
-			   int *mergestrategies,
-			   bool *mergenullsfirst,
-			   Plan *lefttree,
-			   Plan *righttree,
-			   JoinType jointype)
-{
-	MergeJoin  *node = makeNode(MergeJoin);
-	Plan	   *plan = &node->join.plan;
+make_mergejoin(List *tlist, List *joinclauses, List *otherclauses,
+		List *mergeclauses, Oid *mergefamilies, Oid *mergecollations,
+		int *mergestrategies, bool *mergenullsfirst, Plan *lefttree,
+		Plan *righttree, JoinType jointype) {
+	MergeJoin *node = makeNode(MergeJoin);
+	Plan *plan = &node->join.plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = tlist;
@@ -3736,22 +3398,15 @@ make_mergejoin(List *tlist,
  */
 static Sort *
 make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
-		  AttrNumber *sortColIdx, Oid *sortOperators,
-		  Oid *collations, bool *nullsFirst,
-		  double limit_tuples)
-{
-	Sort	   *node = makeNode(Sort);
-	Plan	   *plan = &node->plan;
-	Path		sort_path;		/* dummy for result of cost_sort */
+		AttrNumber *sortColIdx, Oid *sortOperators, Oid *collations,
+		bool *nullsFirst, double limit_tuples) {
+	Sort *node = makeNode(Sort);
+	Plan *plan = &node->plan;
+	Path sort_path; /* dummy for result of cost_sort */
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_sort(&sort_path, root, NIL,
-			  lefttree->total_cost,
-			  lefttree->plan_rows,
-			  lefttree->plan_width,
-			  0.0,
-			  work_mem,
-			  limit_tuples);
+	cost_sort(&sort_path, root, NIL, lefttree->total_cost, lefttree->plan_rows,
+			lefttree->plan_width, 0.0, work_mem, limit_tuples);
 	plan->startup_cost = sort_path.startup_cost;
 	plan->total_cost = sort_path.total_cost;
 	plan->targetlist = lefttree->targetlist;
@@ -3809,22 +3464,16 @@ make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
  */
 static Plan *
 prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
-						   Relids relids,
-						   const AttrNumber *reqColIdx,
-						   bool adjust_tlist_in_place,
-						   int *p_numsortkeys,
-						   AttrNumber **p_sortColIdx,
-						   Oid **p_sortOperators,
-						   Oid **p_collations,
-						   bool **p_nullsFirst)
-{
-	List	   *tlist = lefttree->targetlist;
-	ListCell   *i;
-	int			numsortkeys;
+		Relids relids, const AttrNumber *reqColIdx, bool adjust_tlist_in_place,
+		int *p_numsortkeys, AttrNumber **p_sortColIdx, Oid **p_sortOperators,
+		Oid **p_collations, bool **p_nullsFirst) {
+	List *tlist = lefttree->targetlist;
+	ListCell *i;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/*
 	 * We will need at most list_length(pathkeys) sort columns; possibly less
@@ -3837,32 +3486,29 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 
 	numsortkeys = 0;
 
-	foreach(i, pathkeys)
-	{
-		PathKey    *pathkey = (PathKey *) lfirst(i);
+	foreach(i, pathkeys) {
+		PathKey *pathkey = (PathKey *) lfirst(i);
 		EquivalenceClass *ec = pathkey->pk_eclass;
 		EquivalenceMember *em;
 		TargetEntry *tle = NULL;
-		Oid			pk_datatype = InvalidOid;
-		Oid			sortop;
-		ListCell   *j;
+		Oid pk_datatype = InvalidOid;
+		Oid sortop;
+		ListCell *j;
 
-		if (ec->ec_has_volatile)
-		{
+		if (ec->ec_has_volatile) {
 			/*
 			 * If the pathkey's EquivalenceClass is volatile, then it must
 			 * have come from an ORDER BY clause, and we have to match it to
 			 * that same targetlist entry.
 			 */
-			if (ec->ec_sortref == 0)	/* can't happen */
+			if (ec->ec_sortref == 0) /* can't happen */
 				elog(ERROR, "volatile EquivalenceClass has no sortref");
 			tle = get_sortgroupref_tle(ec->ec_sortref, tlist);
 			Assert(tle);
 			Assert(list_length(ec->ec_members) == 1);
-			pk_datatype = ((EquivalenceMember *) linitial(ec->ec_members))->em_datatype;
-		}
-		else if (reqColIdx != NULL)
-		{
+			pk_datatype =
+					((EquivalenceMember *) linitial(ec->ec_members))->em_datatype;
+		} else if (reqColIdx != NULL) {
 			/*
 			 * If we are given a sort column number to match, only consider
 			 * the single TLE at that position.  It's possible that there is
@@ -3873,20 +3519,15 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * but we'll leave it to caller to complain about the mismatch.
 			 */
 			tle = get_tle_by_resno(tlist, reqColIdx[numsortkeys]);
-			if (tle)
-			{
+			if (tle) {
 				em = find_ec_member_for_tle(ec, tle, relids);
-				if (em)
-				{
+				if (em) {
 					/* found expr at right place in tlist */
 					pk_datatype = em->em_datatype;
-				}
-				else
+				} else
 					tle = NULL;
 			}
-		}
-		else
-		{
+		} else {
 			/*
 			 * Otherwise, we can sort by any non-constant expression listed in
 			 * the pathkey's EquivalenceClass.  For now, we take the first
@@ -3903,12 +3544,10 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * in the same equivalence class...)  Not clear that we ever will
 			 * have an interesting choice in practice, so it may not matter.
 			 */
-			foreach(j, tlist)
-			{
+			foreach(j, tlist) {
 				tle = (TargetEntry *) lfirst(j);
 				em = find_ec_member_for_tle(ec, tle, relids);
-				if (em)
-				{
+				if (em) {
 					/* found expr already in tlist */
 					pk_datatype = em->em_datatype;
 					break;
@@ -3917,8 +3556,7 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			}
 		}
 
-		if (!tle)
-		{
+		if (!tle) {
 			/*
 			 * No matching tlist item; look for a computable expression. Note
 			 * that we treat Aggrefs as if they were variables; this is
@@ -3926,13 +3564,12 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			 * for use in a WindowFunc (since grouping_planner will have
 			 * treated the Aggrefs as variables, too).
 			 */
-			Expr	   *sortexpr = NULL;
+			Expr *sortexpr = NULL;
 
-			foreach(j, ec->ec_members)
-			{
+			foreach(j, ec->ec_members) {
 				EquivalenceMember *em = (EquivalenceMember *) lfirst(j);
-				List	   *exprvars;
-				ListCell   *k;
+				List *exprvars;
+				ListCell *k;
 
 				/*
 				 * We shouldn't be trying to sort by an equivalence class that
@@ -3946,24 +3583,20 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 				 * Ignore child members unless they match the rel being
 				 * sorted.
 				 */
-				if (em->em_is_child &&
-					!bms_equal(em->em_relids, relids))
+				if (em->em_is_child && !bms_equal(em->em_relids, relids))
 					continue;
 
 				sortexpr = em->em_expr;
 				exprvars = pull_var_clause((Node *) sortexpr,
-										   PVC_INCLUDE_AGGREGATES,
-										   PVC_INCLUDE_PLACEHOLDERS);
-				foreach(k, exprvars)
-				{
+						PVC_INCLUDE_AGGREGATES, PVC_INCLUDE_PLACEHOLDERS);
+				foreach(k, exprvars) {
 					if (!tlist_member_ignore_relabel(lfirst(k), tlist))
 						break;
 				}
 				list_free(exprvars);
-				if (!k)
-				{
+				if (!k) {
 					pk_datatype = em->em_datatype;
-					break;		/* found usable expression */
+					break; /* found usable expression */
 				}
 			}
 			if (!j)
@@ -3972,13 +3605,11 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			/*
 			 * Do we need to insert a Result node?
 			 */
-			if (!adjust_tlist_in_place &&
-				!is_projection_capable_plan(lefttree))
-			{
+			if (!adjust_tlist_in_place
+					&& !is_projection_capable_plan(lefttree)) {
 				/* copy needed so we don't modify input's tlist below */
 				tlist = copyObject(tlist);
-				lefttree = (Plan *) make_result(root, tlist, NULL,
-												lefttree);
+				lefttree = (Plan *) make_result(root, tlist, NULL, lefttree);
 			}
 
 			/* Don't bother testing is_projection_capable_plan again */
@@ -3987,26 +3618,20 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
 			/*
 			 * Add resjunk entry to input's tlist
 			 */
-			tle = makeTargetEntry(sortexpr,
-								  list_length(tlist) + 1,
-								  NULL,
-								  true);
+			tle = makeTargetEntry(sortexpr, list_length(tlist) + 1, NULL, true);
 			tlist = lappend(tlist, tle);
-			lefttree->targetlist = tlist;		/* just in case NIL before */
+			lefttree->targetlist = tlist; /* just in case NIL before */
 		}
 
 		/*
 		 * Look up the correct sort operator from the PathKey's slightly
 		 * abstracted representation.
 		 */
-		sortop = get_opfamily_member(pathkey->pk_opfamily,
-									 pk_datatype,
-									 pk_datatype,
-									 pathkey->pk_strategy);
-		if (!OidIsValid(sortop))	/* should not happen */
-			elog(ERROR, "could not find member %d(%u,%u) of opfamily %u",
-				 pathkey->pk_strategy, pk_datatype, pk_datatype,
-				 pathkey->pk_opfamily);
+		sortop = get_opfamily_member(pathkey->pk_opfamily, pk_datatype,
+				pk_datatype, pathkey->pk_strategy);
+		if (!OidIsValid(sortop)) /* should not happen */
+			elog(ERROR,
+					"could not find member %d(%u,%u) of opfamily %u", pathkey->pk_strategy, pk_datatype, pk_datatype, pathkey->pk_opfamily);
 
 		/* Add the column to the sort arrays */
 		sortColIdx[numsortkeys] = tle->resno;
@@ -4033,22 +3658,18 @@ prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
  * Child EC members are ignored unless they match 'relids'.
  */
 static EquivalenceMember *
-find_ec_member_for_tle(EquivalenceClass *ec,
-					   TargetEntry *tle,
-					   Relids relids)
-{
-	Expr	   *tlexpr;
-	ListCell   *lc;
+find_ec_member_for_tle(EquivalenceClass *ec, TargetEntry *tle, Relids relids) {
+	Expr *tlexpr;
+	ListCell *lc;
 
 	/* We ignore binary-compatible relabeling on both ends */
 	tlexpr = tle->expr;
 	while (tlexpr && IsA(tlexpr, RelabelType))
 		tlexpr = ((RelabelType *) tlexpr)->arg;
 
-	foreach(lc, ec->ec_members)
-	{
+	foreach(lc, ec->ec_members) {
 		EquivalenceMember *em = (EquivalenceMember *) lfirst(lc);
-		Expr	   *emexpr;
+		Expr *emexpr;
 
 		/*
 		 * We shouldn't be trying to sort by an equivalence class that
@@ -4060,8 +3681,7 @@ find_ec_member_for_tle(EquivalenceClass *ec,
 		/*
 		 * Ignore child members unless they match the rel being sorted.
 		 */
-		if (em->em_is_child &&
-			!bms_equal(em->em_relids, relids))
+		if (em->em_is_child && !bms_equal(em->em_relids, relids))
 			continue;
 
 		/* Match if same expression (after stripping relabel) */
@@ -4087,29 +3707,21 @@ find_ec_member_for_tle(EquivalenceClass *ec,
  */
 Sort *
 make_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
-						double limit_tuples)
-{
-	int			numsortkeys;
+		double limit_tuples) {
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Compute sort column info, and adjust lefttree as needed */
-	lefttree = prepare_sort_from_pathkeys(root, lefttree, pathkeys,
-										  NULL,
-										  NULL,
-										  false,
-										  &numsortkeys,
-										  &sortColIdx,
-										  &sortOperators,
-										  &collations,
-										  &nullsFirst);
+	lefttree = prepare_sort_from_pathkeys(root, lefttree, pathkeys, NULL, NULL,
+			false, &numsortkeys, &sortColIdx, &sortOperators, &collations,
+			&nullsFirst);
 
 	/* Now build the Sort node */
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, limit_tuples);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, limit_tuples);
 }
 
 /*
@@ -4120,15 +3732,14 @@ make_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree, List *pathkeys,
  *	  'lefttree' is the node which yields input tuples
  */
 Sort *
-make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
-{
-	List	   *sub_tlist = lefttree->targetlist;
-	ListCell   *l;
-	int			numsortkeys;
+make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree) {
+	List *sub_tlist = lefttree->targetlist;
+	ListCell *l;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Convert list-ish representation to arrays wanted by executor */
 	numsortkeys = list_length(sortcls);
@@ -4138,8 +3749,7 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
 	nullsFirst = (bool *) palloc(numsortkeys * sizeof(bool));
 
 	numsortkeys = 0;
-	foreach(l, sortcls)
-	{
+	foreach(l, sortcls) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(l);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, sub_tlist);
 
@@ -4150,9 +3760,8 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
 		numsortkeys++;
 	}
 
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, -1.0);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, -1.0);
 }
 
 /*
@@ -4169,18 +3778,15 @@ make_sort_from_sortclauses(PlannerInfo *root, List *sortcls, Plan *lefttree)
  * is used from the SortGroupClause entries.
  */
 Sort *
-make_sort_from_groupcols(PlannerInfo *root,
-						 List *groupcls,
-						 AttrNumber *grpColIdx,
-						 Plan *lefttree)
-{
-	List	   *sub_tlist = lefttree->targetlist;
-	ListCell   *l;
-	int			numsortkeys;
+make_sort_from_groupcols(PlannerInfo *root, List *groupcls,
+		AttrNumber *grpColIdx, Plan *lefttree) {
+	List *sub_tlist = lefttree->targetlist;
+	ListCell *l;
+	int numsortkeys;
 	AttrNumber *sortColIdx;
-	Oid		   *sortOperators;
-	Oid		   *collations;
-	bool	   *nullsFirst;
+	Oid *sortOperators;
+	Oid *collations;
+	bool *nullsFirst;
 
 	/* Convert list-ish representation to arrays wanted by executor */
 	numsortkeys = list_length(groupcls);
@@ -4190,8 +3796,7 @@ make_sort_from_groupcols(PlannerInfo *root,
 	nullsFirst = (bool *) palloc(numsortkeys * sizeof(bool));
 
 	numsortkeys = 0;
-	foreach(l, groupcls)
-	{
+	foreach(l, groupcls) {
 		SortGroupClause *grpcl = (SortGroupClause *) lfirst(l);
 		TargetEntry *tle = get_tle_by_resno(sub_tlist, grpColIdx[numsortkeys]);
 
@@ -4205,16 +3810,14 @@ make_sort_from_groupcols(PlannerInfo *root,
 		numsortkeys++;
 	}
 
-	return make_sort(root, lefttree, numsortkeys,
-					 sortColIdx, sortOperators, collations,
-					 nullsFirst, -1.0);
+	return make_sort(root, lefttree, numsortkeys, sortColIdx, sortOperators,
+			collations, nullsFirst, -1.0);
 }
 
 static Material *
-make_material(Plan *lefttree)
-{
-	Material   *node = makeNode(Material);
-	Plan	   *plan = &node->plan;
+make_material(Plan *lefttree) {
+	Material *node = makeNode(Material);
+	Plan *plan = &node->plan;
 
 	/* cost should be inserted by caller */
 	plan->targetlist = lefttree->targetlist;
@@ -4236,19 +3839,15 @@ make_material(Plan *lefttree)
  * until setrefs.c is run?
  */
 Plan *
-materialize_finished_plan(Plan *subplan)
-{
-	Plan	   *matplan;
-	Path		matpath;		/* dummy for result of cost_material */
+materialize_finished_plan(Plan *subplan) {
+	Plan *matplan;
+	Path matpath; /* dummy for result of cost_material */
 
 	matplan = (Plan *) make_material(subplan);
 
 	/* Set cost data */
-	cost_material(&matpath,
-				  subplan->startup_cost,
-				  subplan->total_cost,
-				  subplan->plan_rows,
-				  subplan->plan_width);
+	cost_material(&matpath, subplan->startup_cost, subplan->total_cost,
+			subplan->plan_rows, subplan->plan_width);
 	matplan->startup_cost = matpath.startup_cost;
 	matplan->total_cost = matpath.total_cost;
 	matplan->plan_rows = subplan->plan_rows;
@@ -4262,16 +3861,13 @@ materialize_finished_plan(Plan *subplan)
 }
 
 Agg *
-make_agg(PlannerInfo *root, List *tlist, List *qual,
-		 AggStrategy aggstrategy, const AggClauseCosts *aggcosts,
-		 int numGroupCols, AttrNumber *grpColIdx, Oid *grpOperators,
-		 long numGroups,
-		 Plan *lefttree)
-{
-	Agg		   *node = makeNode(Agg);
-	Plan	   *plan = &node->plan;
-	Path		agg_path;		/* dummy for result of cost_agg */
-	QualCost	qual_cost;
+make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
+		const AggClauseCosts *aggcosts, int numGroupCols, AttrNumber *grpColIdx,
+		Oid *grpOperators, long numGroups, Plan *lefttree) {
+	Agg *node = makeNode(Agg);
+	Plan *plan = &node->plan;
+	Path agg_path; /* dummy for result of cost_agg */
+	QualCost qual_cost;
 
 	node->aggstrategy = aggstrategy;
 	node->numCols = numGroupCols;
@@ -4280,12 +3876,8 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 	node->numGroups = numGroups;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_agg(&agg_path, root,
-			 aggstrategy, aggcosts,
-			 numGroupCols, numGroups,
-			 lefttree->startup_cost,
-			 lefttree->total_cost,
-			 lefttree->plan_rows);
+	cost_agg(&agg_path, root, aggstrategy, aggcosts, numGroupCols, numGroups,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = agg_path.startup_cost;
 	plan->total_cost = agg_path.total_cost;
 
@@ -4307,8 +3899,7 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 	 * See notes in add_tlist_costs_to_plan about why only make_agg,
 	 * make_windowagg and make_group worry about tlist eval cost.
 	 */
-	if (qual)
-	{
+	if (qual) {
 		cost_qual_eval(&qual_cost, qual, root);
 		plan->startup_cost += qual_cost.startup;
 		plan->total_cost += qual_cost.startup;
@@ -4325,16 +3916,13 @@ make_agg(PlannerInfo *root, List *tlist, List *qual,
 }
 
 WindowAgg *
-make_windowagg(PlannerInfo *root, List *tlist,
-			   List *windowFuncs, Index winref,
-			   int partNumCols, AttrNumber *partColIdx, Oid *partOperators,
-			   int ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators,
-			   int frameOptions, Node *startOffset, Node *endOffset,
-			   Plan *lefttree)
-{
-	WindowAgg  *node = makeNode(WindowAgg);
-	Plan	   *plan = &node->plan;
-	Path		windowagg_path; /* dummy for result of cost_windowagg */
+make_windowagg(PlannerInfo *root, List *tlist, List *windowFuncs, Index winref,
+		int partNumCols, AttrNumber *partColIdx, Oid *partOperators,
+		int ordNumCols, AttrNumber *ordColIdx, Oid *ordOperators,
+		int frameOptions, Node *startOffset, Node *endOffset, Plan *lefttree) {
+	WindowAgg *node = makeNode(WindowAgg);
+	Plan *plan = &node->plan;
+	Path windowagg_path; /* dummy for result of cost_windowagg */
 
 	node->winref = winref;
 	node->partNumCols = partNumCols;
@@ -4348,11 +3936,8 @@ make_windowagg(PlannerInfo *root, List *tlist,
 	node->endOffset = endOffset;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_windowagg(&windowagg_path, root,
-				   windowFuncs, partNumCols, ordNumCols,
-				   lefttree->startup_cost,
-				   lefttree->total_cost,
-				   lefttree->plan_rows);
+	cost_windowagg(&windowagg_path, root, windowFuncs, partNumCols, ordNumCols,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = windowagg_path.startup_cost;
 	plan->total_cost = windowagg_path.total_cost;
 
@@ -4374,30 +3959,21 @@ make_windowagg(PlannerInfo *root, List *tlist,
 }
 
 Group *
-make_group(PlannerInfo *root,
-		   List *tlist,
-		   List *qual,
-		   int numGroupCols,
-		   AttrNumber *grpColIdx,
-		   Oid *grpOperators,
-		   double numGroups,
-		   Plan *lefttree)
-{
-	Group	   *node = makeNode(Group);
-	Plan	   *plan = &node->plan;
-	Path		group_path;		/* dummy for result of cost_group */
-	QualCost	qual_cost;
+make_group(PlannerInfo *root, List *tlist, List *qual, int numGroupCols,
+		AttrNumber *grpColIdx, Oid *grpOperators, double numGroups,
+		Plan *lefttree) {
+	Group *node = makeNode(Group);
+	Plan *plan = &node->plan;
+	Path group_path; /* dummy for result of cost_group */
+	QualCost qual_cost;
 
 	node->numCols = numGroupCols;
 	node->grpColIdx = grpColIdx;
 	node->grpOperators = grpOperators;
 
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
-	cost_group(&group_path, root,
-			   numGroupCols, numGroups,
-			   lefttree->startup_cost,
-			   lefttree->total_cost,
-			   lefttree->plan_rows);
+	cost_group(&group_path, root, numGroupCols, numGroups,
+			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
 	plan->startup_cost = group_path.startup_cost;
 	plan->total_cost = group_path.total_cost;
 
@@ -4416,8 +3992,7 @@ make_group(PlannerInfo *root,
 	 * See notes in add_tlist_costs_to_plan about why only make_agg,
 	 * make_windowagg and make_group worry about tlist eval cost.
 	 */
-	if (qual)
-	{
+	if (qual) {
 		cost_qual_eval(&qual_cost, qual, root);
 		plan->startup_cost += qual_cost.startup;
 		plan->total_cost += qual_cost.startup;
@@ -4439,15 +4014,14 @@ make_group(PlannerInfo *root,
  * already be sorted accordingly.
  */
 Unique *
-make_unique(Plan *lefttree, List *distinctList)
-{
-	Unique	   *node = makeNode(Unique);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
-	int			keyno = 0;
+make_unique(Plan *lefttree, List *distinctList) {
+	Unique *node = makeNode(Unique);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
+	int keyno = 0;
 	AttrNumber *uniqColIdx;
-	Oid		   *uniqOperators;
-	ListCell   *slitem;
+	Oid *uniqOperators;
+	ListCell *slitem;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4477,8 +4051,7 @@ make_unique(Plan *lefttree, List *distinctList)
 	uniqColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 	uniqOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-	foreach(slitem, distinctList)
-	{
+	foreach(slitem, distinctList) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, plan->targetlist);
 
@@ -4502,16 +4075,15 @@ make_unique(Plan *lefttree, List *distinctList)
  */
 SetOp *
 make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
-		   List *distinctList, AttrNumber flagColIdx, int firstFlag,
-		   long numGroups, double outputRows)
-{
-	SetOp	   *node = makeNode(SetOp);
-	Plan	   *plan = &node->plan;
-	int			numCols = list_length(distinctList);
-	int			keyno = 0;
+		List *distinctList, AttrNumber flagColIdx, int firstFlag,
+		long numGroups, double outputRows) {
+	SetOp *node = makeNode(SetOp);
+	Plan *plan = &node->plan;
+	int numCols = list_length(distinctList);
+	int keyno = 0;
 	AttrNumber *dupColIdx;
-	Oid		   *dupOperators;
-	ListCell   *slitem;
+	Oid *dupOperators;
+	ListCell *slitem;
 
 	copy_plan_costsize(plan, lefttree);
 	plan->plan_rows = outputRows;
@@ -4535,8 +4107,7 @@ make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
 	dupColIdx = (AttrNumber *) palloc(sizeof(AttrNumber) * numCols);
 	dupOperators = (Oid *) palloc(sizeof(Oid) * numCols);
 
-	foreach(slitem, distinctList)
-	{
+	foreach(slitem, distinctList) {
 		SortGroupClause *sortcl = (SortGroupClause *) lfirst(slitem);
 		TargetEntry *tle = get_sortgroupclause_tle(sortcl, plan->targetlist);
 
@@ -4563,10 +4134,9 @@ make_setop(SetOpCmd cmd, SetOpStrategy strategy, Plan *lefttree,
  *	  Build a LockRows plan node
  */
 LockRows *
-make_lockrows(Plan *lefttree, List *rowMarks, int epqParam)
-{
-	LockRows   *node = makeNode(LockRows);
-	Plan	   *plan = &node->plan;
+make_lockrows(Plan *lefttree, List *rowMarks, int epqParam) {
+	LockRows *node = makeNode(LockRows);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4593,10 +4163,9 @@ make_lockrows(Plan *lefttree, List *rowMarks, int epqParam)
  */
 Limit *
 make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
-		   int64 offset_est, int64 count_est)
-{
-	Limit	   *node = makeNode(Limit);
-	Plan	   *plan = &node->plan;
+		int64 offset_est, int64 count_est) {
+	Limit *node = makeNode(Limit);
+	Plan *plan = &node->plan;
 
 	copy_plan_costsize(plan, lefttree);
 
@@ -4609,9 +4178,8 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 	 * When the offset or count couldn't be estimated, use 10% of the
 	 * estimated number of rows emitted from the subplan.
 	 */
-	if (offset_est != 0)
-	{
-		double		offset_rows;
+	if (offset_est != 0) {
+		double offset_rows;
 
 		if (offset_est > 0)
 			offset_rows = (double) offset_est;
@@ -4620,17 +4188,15 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 		if (offset_rows > plan->plan_rows)
 			offset_rows = plan->plan_rows;
 		if (plan->plan_rows > 0)
-			plan->startup_cost +=
-				(plan->total_cost - plan->startup_cost)
-				* offset_rows / plan->plan_rows;
+			plan->startup_cost += (plan->total_cost - plan->startup_cost)
+					* offset_rows / plan->plan_rows;
 		plan->plan_rows -= offset_rows;
 		if (plan->plan_rows < 1)
 			plan->plan_rows = 1;
 	}
 
-	if (count_est != 0)
-	{
-		double		count_rows;
+	if (count_est != 0) {
+		double count_rows;
 
 		if (count_est > 0)
 			count_rows = (double) count_est;
@@ -4639,9 +4205,9 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
 		if (count_rows > plan->plan_rows)
 			count_rows = plan->plan_rows;
 		if (plan->plan_rows > 0)
-			plan->total_cost = plan->startup_cost +
-				(plan->total_cost - plan->startup_cost)
-				* count_rows / plan->plan_rows;
+			plan->total_cost = plan->startup_cost
+					+ (plan->total_cost - plan->startup_cost) * count_rows
+							/ plan->plan_rows;
 		plan->plan_rows = count_rows;
 		if (plan->plan_rows < 1)
 			plan->plan_rows = 1;
@@ -4668,25 +4234,20 @@ make_limit(Plan *lefttree, Node *limitOffset, Node *limitCount,
  * cost.  In either case, tlist eval cost is not to be included here.
  */
 Result *
-make_result(PlannerInfo *root,
-			List *tlist,
-			Node *resconstantqual,
-			Plan *subplan)
-{
-	Result	   *node = makeNode(Result);
-	Plan	   *plan = &node->plan;
+make_result(PlannerInfo *root, List *tlist, Node *resconstantqual,
+		Plan *subplan) {
+	Result *node = makeNode(Result);
+	Plan *plan = &node->plan;
 
 	if (subplan)
 		copy_plan_costsize(plan, subplan);
-	else
-	{
+	else {
 		plan->startup_cost = 0;
 		plan->total_cost = cpu_tuple_cost;
-		plan->plan_rows = 1;	/* wrong if we have a set-valued function? */
-		plan->plan_width = 0;	/* XXX is it worth being smarter? */
-		if (resconstantqual)
-		{
-			QualCost	qual_cost;
+		plan->plan_rows = 1; /* wrong if we have a set-valued function? */
+		plan->plan_width = 0; /* XXX is it worth being smarter? */
+		if (resconstantqual) {
+			QualCost qual_cost;
 
 			cost_qual_eval(&qual_cost, (List *) resconstantqual, root);
 			/* resconstantqual is evaluated once at startup */
@@ -4715,25 +4276,22 @@ make_result(PlannerInfo *root,
  * But we might want to make it look better sometime.
  */
 ModifyTable *
-make_modifytable(PlannerInfo *root,
-				 CmdType operation, bool canSetTag,
-				 List *resultRelations, List *subplans,
-				 List *withCheckOptionLists, List *returningLists,
-				 List *rowMarks, int epqParam)
-{
+make_modifytable(PlannerInfo *root, CmdType operation, bool canSetTag,
+		List *resultRelations, List *subplans, List *withCheckOptionLists,
+		List *returningLists, List *rowMarks, int epqParam) {
 	ModifyTable *node = makeNode(ModifyTable);
-	Plan	   *plan = &node->plan;
-	double		total_size;
-	List	   *fdw_private_list;
-	ListCell   *subnode;
-	ListCell   *lc;
-	int			i;
+	Plan *plan = &node->plan;
+	double total_size;
+	List *fdw_private_list;
+	ListCell *subnode;
+	ListCell *lc;
+	int i;
 
 	Assert(list_length(resultRelations) == list_length(subplans));
-	Assert(withCheckOptionLists == NIL ||
-		   list_length(resultRelations) == list_length(withCheckOptionLists));
-	Assert(returningLists == NIL ||
-		   list_length(resultRelations) == list_length(returningLists));
+	Assert(
+			withCheckOptionLists == NIL || list_length(resultRelations) == list_length(withCheckOptionLists));
+	Assert(
+			returningLists == NIL || list_length(resultRelations) == list_length(returningLists));
 
 	/*
 	 * Compute cost as sum of subplan costs.
@@ -4742,11 +4300,10 @@ make_modifytable(PlannerInfo *root,
 	plan->total_cost = 0;
 	plan->plan_rows = 0;
 	total_size = 0;
-	foreach(subnode, subplans)
-	{
-		Plan	   *subplan = (Plan *) lfirst(subnode);
+	foreach(subnode, subplans) {
+		Plan *subplan = (Plan *) lfirst(subnode);
 
-		if (subnode == list_head(subplans))		/* first node? */
+		if (subnode == list_head(subplans)) /* first node? */
 			plan->startup_cost = subplan->startup_cost;
 		plan->total_cost += subplan->total_cost;
 		plan->plan_rows += subplan->plan_rows;
@@ -4766,7 +4323,7 @@ make_modifytable(PlannerInfo *root,
 	node->operation = operation;
 	node->canSetTag = canSetTag;
 	node->resultRelations = resultRelations;
-	node->resultRelIndex = -1;	/* will be set correctly in setrefs.c */
+	node->resultRelIndex = -1; /* will be set correctly in setrefs.c */
 	node->plans = subplans;
 	node->withCheckOptionLists = withCheckOptionLists;
 	node->returningLists = returningLists;
@@ -4779,11 +4336,10 @@ make_modifytable(PlannerInfo *root,
 	 */
 	fdw_private_list = NIL;
 	i = 0;
-	foreach(lc, resultRelations)
-	{
-		Index		rti = lfirst_int(lc);
+	foreach(lc, resultRelations) {
+		Index rti = lfirst_int(lc);
 		FdwRoutine *fdwroutine;
-		List	   *fdw_private;
+		List *fdw_private;
 
 		/*
 		 * If possible, we want to get the FdwRoutine from our RelOptInfo for
@@ -4792,26 +4348,21 @@ make_modifytable(PlannerInfo *root,
 		 * so it's not a baserel; and there are also corner cases for
 		 * updatable views where the target rel isn't a baserel.)
 		 */
-		if (rti < root->simple_rel_array_size &&
-			root->simple_rel_array[rti] != NULL)
-		{
-			RelOptInfo *resultRel = root->simple_rel_array[rti];
+		if (rti
+				< root->simple_rel_array_size&& root->simple_rel_array[rti] != NULL) {RelOptInfo *resultRel = root->simple_rel_array[rti];
 
-			fdwroutine = resultRel->fdwroutine;
-		}
+		fdwroutine = resultRel->fdwroutine;
+	} else {
+		RangeTblEntry *rte = planner_rt_fetch(rti, root);
+
+		Assert(rte->rtekind == RTE_RELATION);
+		if (rte->relkind == RELKIND_FOREIGN_TABLE)
+		fdwroutine = GetFdwRoutineByRelId(rte->relid);
 		else
-		{
-			RangeTblEntry *rte = planner_rt_fetch(rti, root);
-
-			Assert(rte->rtekind == RTE_RELATION);
-			if (rte->relkind == RELKIND_FOREIGN_TABLE)
-				fdwroutine = GetFdwRoutineByRelId(rte->relid);
-			else
-				fdwroutine = NULL;
-		}
+		fdwroutine = NULL;
+	}
 
-		if (fdwroutine != NULL &&
-			fdwroutine->PlanForeignModify != NULL)
+		if (fdwroutine != NULL && fdwroutine->PlanForeignModify != NULL)
 			fdw_private = fdwroutine->PlanForeignModify(root, node, rti, i);
 		else
 			fdw_private = NIL;
@@ -4827,26 +4378,48 @@ make_modifytable(PlannerInfo *root,
  * is_projection_capable_plan
  *		Check whether a given Plan node is able to do projection.
  */
-bool
-is_projection_capable_plan(Plan *plan)
-{
+bool is_projection_capable_plan(Plan *plan) {
 	/* Most plan types can project, so just list the ones that can't */
-	switch (nodeTag(plan))
-	{
-		case T_Hash:
-		case T_Material:
-		case T_Sort:
-		case T_Unique:
-		case T_SetOp:
-		case T_LockRows:
-		case T_Limit:
-		case T_ModifyTable:
-		case T_Append:
-		case T_MergeAppend:
-		case T_RecursiveUnion:
-			return false;
-		default:
-			break;
+	switch (nodeTag(plan)) {
+	case T_Hash:
+	case T_Material:
+	case T_Sort:
+	case T_Unique:
+	case T_SetOp:
+	case T_LockRows:
+	case T_Limit:
+	case T_ModifyTable:
+	case T_Append:
+	case T_MergeAppend:
+	case T_RecursiveUnion:
+		return false;
+	default:
+		break;
 	}
 	return true;
 }
+void print_injected_cost(const char *rel, int rows,double old_cost , double cost_result) {
+
+	fprintf(file, "%s	%d	%.2f	%.2f\n", rel, rows, old_cost, cost_result);
+
+}
+int get_base_rows_from_memo(char *name, int level) {
+
+	if (enable_cost_check) {
+
+		return get_baserel_memo_size(name, level);
+
+	}
+
+	return (-1);
+}
+int get_join_rows_from_memo(char *name, int level) {
+
+	if (enable_cost_check) {
+
+		return get_join_memo_size(name, level);
+
+	}
+
+	return (-1);
+}
diff --git a/src/backend/optimizer/plan/planmain.c b/src/backend/optimizer/plan/planmain.c
index 3ea916f..6680216 100644
--- a/src/backend/optimizer/plan/planmain.c
+++ b/src/backend/optimizer/plan/planmain.c
@@ -26,7 +26,6 @@
 #include "optimizer/placeholder.h"
 #include "optimizer/planmain.h"
 
-
 /*
  * query_planner
  *	  Generate a path (that is, a simplified plan) for a basic query,
@@ -242,3 +241,4 @@ query_planner(PlannerInfo *root, List *tlist,
 
 	return final_rel;
 }
+
diff --git a/src/backend/optimizer/plan/planner.c b/src/backend/optimizer/plan/planner.c
index 35bda67..45e84a6 100644
--- a/src/backend/optimizer/plan/planner.c
+++ b/src/backend/optimizer/plan/planner.c
@@ -42,9 +42,12 @@
 #include "utils/selfuncs.h"
 
 
+
+
 /* GUC parameter */
 double		cursor_tuple_fraction = DEFAULT_CURSOR_TUPLE_FRACTION;
 
+
 /* Hook for plugins to get control in planner() */
 planner_hook_type planner_hook = NULL;
 
@@ -151,6 +154,9 @@ standard_planner(Query *parse, int cursorOptions, ParamListInfo boundParams)
 	ListCell   *lp,
 			   *lr;
 
+
+
+
 	/* Cursor options may come from caller or from DECLARE CURSOR stmt */
 	if (parse->utilityStmt &&
 		IsA(parse->utilityStmt, DeclareCursorStmt))
@@ -1438,13 +1444,14 @@ grouping_planner(PlannerInfo *root, double tuple_fraction)
 			best_path = cheapest_path;
 		else
 			best_path = sorted_path;
-
+	//
 		/*
 		 * Check to see if it's possible to optimize MIN/MAX aggregates. If
 		 * so, we will forget all the work we did so far to choose a "regular"
 		 * path ... but we had to do it anyway to be able to tell which way is
 		 * cheaper.
 		 */
+		//check_memo_costs(root);
 		result_plan = optimize_minmax_aggregates(root,
 												 tlist,
 												 &agg_costs,
diff --git a/src/backend/optimizer/util/pathnode.c b/src/backend/optimizer/util/pathnode.c
index b79af7a..e8be972 100644
--- a/src/backend/optimizer/util/pathnode.c
+++ b/src/backend/optimizer/util/pathnode.c
@@ -27,6 +27,7 @@
 #include "parser/parsetree.h"
 #include "utils/lsyscache.h"
 #include "utils/selfuncs.h"
+#include "storage/fd.h"
 
 
 typedef enum
@@ -2067,3 +2068,73 @@ reparameterize_path(PlannerInfo *root, Path *path,
 	}
 	return NULL;
 }
+int get_baserel_memo_size(char *rel_name, int level) {
+	FILE *file = AllocateFile("memoTxt.txt", "rb");
+	char buffer[200];
+	char relname[200];
+	int level_n;
+	int estsize;
+	int actsize;
+	int max = 200;
+	printf("Checking rows for %s at level %d\n", rel_name, level);
+		fflush(stdout);
+	while (fgets(buffer, max, file) != NULL) {
+
+		if (sscanf(buffer, "%d %s %d %d", &level_n,relname, &estsize, &actsize) > 0) {
+			//printf("token rel: %s\n\r", buffer);
+			if (!strcmp(relname, rel_name) && level_n == level) {
+			printf("found rel: %s at level %d\n", rel_name,level_n);
+			fflush(stdout);
+				return actsize;
+			}
+
+		}
+
+	}
+
+	return -1;
+
+}
+
+int get_join_memo_size(char *rel_names, int level) {
+
+	FILE *file = AllocateFile("memoTxt.txt", "rb");
+	int max = strlen(rel_names);
+	char buffer[200];
+	char relnames[max];
+	int level_n;
+	int estsize;
+	int actsize;
+	const char s[2] = ",";
+
+	char *found;
+
+	char *rel_name;
+	printf("Checking rows for %s at level %d\n", rel_names, level);
+	fflush(stdout);
+	while (fgets(buffer, 200, file) != NULL) {
+		if (sscanf(buffer, "%d [ %s ] %d %d",&level_n, relnames, &estsize, &actsize) > 0) {
+			if (max == strlen(relnames) && level == level_n) {
+				rel_name = strtok(relnames, s);
+				while (rel_name != NULL) {
+
+					found = strstr(rel_names, rel_name);
+					if (found == NULL)
+						break;
+					rel_name = strtok(NULL, s);
+
+				}
+				if (found != NULL) {
+					printf("found rel: %s at level %d\n", rel_names,level_n);
+								fflush(stdout);
+					return actsize;
+				}
+
+			}
+
+		}
+	}
+
+	return -1;
+
+}
diff --git a/src/backend/optimizer/util/plancat.c b/src/backend/optimizer/util/plancat.c
index 73ba2f6..b635661 100644
--- a/src/backend/optimizer/util/plancat.c
+++ b/src/backend/optimizer/util/plancat.c
@@ -106,7 +106,7 @@ get_relation_info(PlannerInfo *root, Oid relationObjectId, bool inhparent,
 	rel->min_attr = FirstLowInvalidHeapAttributeNumber + 1;
 	rel->max_attr = RelationGetNumberOfAttributes(relation);
 	rel->reltablespace = RelationGetForm(relation)->reltablespace;
-
+	rel->rel_name = RelationGetRelationName(relation);
 	Assert(rel->max_attr >= rel->min_attr);
 	rel->attr_needed = (Relids *)
 		palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
diff --git a/src/backend/optimizer/util/relnode.c b/src/backend/optimizer/util/relnode.c
index 8ae8f55..0197beb 100644
--- a/src/backend/optimizer/util/relnode.c
+++ b/src/backend/optimizer/util/relnode.c
@@ -13,7 +13,8 @@
  *-------------------------------------------------------------------------
  */
 #include "postgres.h"
-
+#include "stdio.h"
+#include "unistd.h"
 #include "optimizer/cost.h"
 #include "optimizer/pathnode.h"
 #include "optimizer/paths.h"
@@ -21,51 +22,49 @@
 #include "optimizer/plancat.h"
 #include "optimizer/restrictinfo.h"
 #include "utils/hsearch.h"
-
-
-typedef struct JoinHashEntry
-{
-	Relids		join_relids;	/* hash key --- MUST BE FIRST */
+#include "lib/stringinfo.h"
+#include "nodes/nodes.h"
+#include "utils/rel.h"
+#include "catalog/objectaddress.h"
+#include "catalog/namespace.h"
+#include "c.h"
+#include "storage/fd.h"
+
+typedef struct JoinHashEntry {
+	Relids join_relids; /* hash key --- MUST BE FIRST */
 	RelOptInfo *join_rel;
 } JoinHashEntry;
 
 static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
-					RelOptInfo *input_rel);
-static List *build_joinrel_restrictlist(PlannerInfo *root,
-						   RelOptInfo *joinrel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel);
-static void build_joinrel_joinlist(RelOptInfo *joinrel,
-					   RelOptInfo *outer_rel,
-					   RelOptInfo *inner_rel);
-static List *subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
-							  List *joininfo_list,
-							  List *new_restrictlist);
-static List *subbuild_joinrel_joinlist(RelOptInfo *joinrel,
-						  List *joininfo_list,
-						  List *new_joininfo);
+		RelOptInfo *input_rel);
 
+static List *build_joinrel_restrictlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel);
+static void build_joinrel_joinlist(RelOptInfo *joinrel, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel);
+static List *subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
+		List *joininfo_list, List *new_restrictlist);
+static List *subbuild_joinrel_joinlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_joininfo);
 
 /*
  * setup_simple_rel_arrays
  *	  Prepare the arrays we use for quickly accessing base relations.
  */
-void
-setup_simple_rel_arrays(PlannerInfo *root)
-{
-	Index		rti;
-	ListCell   *lc;
+void setup_simple_rel_arrays(PlannerInfo *root) {
+	Index rti;
+	ListCell *lc;
 
 	/* Arrays are accessed using RT indexes (1..N) */
 	root->simple_rel_array_size = list_length(root->parse->rtable) + 1;
 
 	/* simple_rel_array is initialized to all NULLs */
-	root->simple_rel_array = (RelOptInfo **)
-		palloc0(root->simple_rel_array_size * sizeof(RelOptInfo *));
+	root->simple_rel_array = (RelOptInfo **) palloc0(
+			root->simple_rel_array_size * sizeof(RelOptInfo *));
 
 	/* simple_rte_array is an array equivalent of the rtable list */
-	root->simple_rte_array = (RangeTblEntry **)
-		palloc0(root->simple_rel_array_size * sizeof(RangeTblEntry *));
+	root->simple_rte_array = (RangeTblEntry **) palloc0(
+			root->simple_rel_array_size * sizeof(RangeTblEntry *));
 	rti = 1;
 	foreach(lc, root->parse->rtable)
 	{
@@ -80,11 +79,10 @@ setup_simple_rel_arrays(PlannerInfo *root)
  *	  Construct a new RelOptInfo for a base relation or 'other' relation.
  */
 RelOptInfo *
-build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
-{
+build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 	RelOptInfo *rel;
 	RangeTblEntry *rte;
-
+	int memo_size;
 	/* Rel should not exist already */
 	Assert(relid > 0 && relid < root->simple_rel_array_size);
 	if (root->simple_rel_array[relid] != NULL)
@@ -97,7 +95,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	rel = makeNode(RelOptInfo);
 	rel->reloptkind = reloptkind;
 	rel->relids = bms_make_singleton(relid);
-	rel->rows = 0;
+	rel->rows = -1;
 	rel->width = 0;
 	/* cheap startup cost is interesting iff not all tuples to be retrieved */
 	rel->consider_startup = (root->tuple_fraction > 0);
@@ -123,6 +121,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	rel->subplan_params = NIL;
 	rel->fdwroutine = NULL;
 	rel->fdw_private = NULL;
+	rel->workspace = NULL;
 	rel->baserestrictinfo = NIL;
 	rel->baserestrictcost.startup = 0;
 	rel->baserestrictcost.per_tuple = 0;
@@ -130,34 +129,40 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	rel->has_eclass_joins = false;
 
 	/* Check type of rtable entry */
-	switch (rte->rtekind)
-	{
-		case RTE_RELATION:
-			/* Table --- retrieve statistics from the system catalogs */
-			get_relation_info(root, rte->relid, rte->inh, rel);
-			break;
-		case RTE_SUBQUERY:
-		case RTE_FUNCTION:
-		case RTE_VALUES:
-		case RTE_CTE:
+	switch (rte->rtekind) {
+	case RTE_RELATION:
+
+		/* Table --- retrieve statistics from the system catalogs */
+		get_relation_info(root, rte->relid, rte->inh, rel);
+		/*hack for memo*/
+		if (enable_memo) {
+			printf("memo status : %d", enable_memo);
+			memo_size = get_baserel_memo_size(rel->rel_name,root->query_level);
+			//printf("rel size was : %d", memo_size );
+			rel->rows = memo_size;
+		}
+		break;
+	case RTE_SUBQUERY:
+	case RTE_FUNCTION:
+	case RTE_VALUES:
+	case RTE_CTE:
 
-			/*
-			 * Subquery, function, or values list --- set up attr range and
-			 * arrays
-			 *
-			 * Note: 0 is included in range to support whole-row Vars
-			 */
-			rel->min_attr = 0;
-			rel->max_attr = list_length(rte->eref->colnames);
-			rel->attr_needed = (Relids *)
-				palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
-			rel->attr_widths = (int32 *)
-				palloc0((rel->max_attr - rel->min_attr + 1) * sizeof(int32));
-			break;
-		default:
-			elog(ERROR, "unrecognized RTE kind: %d",
-				 (int) rte->rtekind);
-			break;
+		/*
+		 * Subquery, function, or values list --- set up attr range and
+		 * arrays
+		 *
+		 * Note: 0 is included in range to support whole-row Vars
+		 */
+		rel->min_attr = 0;
+		rel->max_attr = list_length(rte->eref->colnames);
+		rel->attr_needed = (Relids *) palloc0(
+				(rel->max_attr - rel->min_attr + 1) * sizeof(Relids));
+		rel->attr_widths = (int32 *) palloc0(
+				(rel->max_attr - rel->min_attr + 1) * sizeof(int32));
+		break;
+	default:
+		elog(ERROR, "unrecognized RTE kind: %d", (int ) rte->rtekind);
+		break;
 	}
 
 	/* Save the finished struct in the query's simple_rel_array */
@@ -169,9 +174,8 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 	 * not in the main join tree, but we will need RelOptInfos to plan access
 	 * to them.
 	 */
-	if (rte->inh)
-	{
-		ListCell   *l;
+	if (rte->inh) {
+		ListCell *l;
 
 		foreach(l, root->append_rel_list)
 		{
@@ -182,7 +186,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
 				continue;
 
 			(void) build_simple_rel(root, appinfo->child_relid,
-									RELOPT_OTHER_MEMBER_REL);
+					RELOPT_OTHER_MEMBER_REL);
 		}
 	}
 
@@ -194,14 +198,12 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind)
  *	  Find a base or other relation entry, which must already exist.
  */
 RelOptInfo *
-find_base_rel(PlannerInfo *root, int relid)
-{
+find_base_rel(PlannerInfo *root, int relid) {
 	RelOptInfo *rel;
 
 	Assert(relid > 0);
 
-	if (relid < root->simple_rel_array_size)
-	{
+	if (relid < root->simple_rel_array_size) {
 		rel = root->simple_rel_array[relid];
 		if (rel)
 			return rel;
@@ -209,19 +211,17 @@ find_base_rel(PlannerInfo *root, int relid)
 
 	elog(ERROR, "no relation entry for relid %d", relid);
 
-	return NULL;				/* keep compiler quiet */
+	return NULL; /* keep compiler quiet */
 }
 
 /*
  * build_join_rel_hash
  *	  Construct the auxiliary hash table for join relations.
  */
-static void
-build_join_rel_hash(PlannerInfo *root)
-{
-	HTAB	   *hashtab;
-	HASHCTL		hash_ctl;
-	ListCell   *l;
+static void build_join_rel_hash(PlannerInfo *root) {
+	HTAB *hashtab;
+	HASHCTL hash_ctl;
+	ListCell *l;
 
 	/* Create the hash table */
 	MemSet(&hash_ctl, 0, sizeof(hash_ctl));
@@ -230,22 +230,18 @@ build_join_rel_hash(PlannerInfo *root)
 	hash_ctl.hash = bitmap_hash;
 	hash_ctl.match = bitmap_match;
 	hash_ctl.hcxt = CurrentMemoryContext;
-	hashtab = hash_create("JoinRelHashTable",
-						  256L,
-						  &hash_ctl,
-					HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
+	hashtab = hash_create("JoinRelHashTable", 256L, &hash_ctl,
+	HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
 
 	/* Insert all the already-existing joinrels */
 	foreach(l, root->join_rel_list)
 	{
 		RelOptInfo *rel = (RelOptInfo *) lfirst(l);
 		JoinHashEntry *hentry;
-		bool		found;
+		bool found;
 
-		hentry = (JoinHashEntry *) hash_search(hashtab,
-											   &(rel->relids),
-											   HASH_ENTER,
-											   &found);
+		hentry = (JoinHashEntry *) hash_search(hashtab, &(rel->relids),
+				HASH_ENTER, &found);
 		Assert(!found);
 		hentry->join_rel = rel;
 	}
@@ -259,8 +255,7 @@ build_join_rel_hash(PlannerInfo *root)
  *	  or NULL if none exists.  This is for join relations.
  */
 RelOptInfo *
-find_join_rel(PlannerInfo *root, Relids relids)
-{
+find_join_rel(PlannerInfo *root, Relids relids) {
 	/*
 	 * Switch to using hash lookup when list grows "too long".	The threshold
 	 * is arbitrary and is known only here.
@@ -276,21 +271,17 @@ find_join_rel(PlannerInfo *root, Relids relids)
 	 * so would force relids out of a register and thus probably slow down the
 	 * list-search case.
 	 */
-	if (root->join_rel_hash)
-	{
-		Relids		hashkey = relids;
+	if (root->join_rel_hash) {
+		Relids hashkey = relids;
 		JoinHashEntry *hentry;
 
-		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash,
-											   &hashkey,
-											   HASH_FIND,
-											   NULL);
+		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash, &hashkey,
+				HASH_FIND,
+				NULL);
 		if (hentry)
 			return hentry->join_rel;
-	}
-	else
-	{
-		ListCell   *l;
+	} else {
+		ListCell *l;
 
 		foreach(l, root->join_rel_list)
 		{
@@ -321,32 +312,30 @@ find_join_rel(PlannerInfo *root, Relids relids)
  * duplicated calculation of the restrictlist...
  */
 RelOptInfo *
-build_join_rel(PlannerInfo *root,
-			   Relids joinrelids,
-			   RelOptInfo *outer_rel,
-			   RelOptInfo *inner_rel,
-			   SpecialJoinInfo *sjinfo,
-			   List **restrictlist_ptr)
-{
+build_join_rel(PlannerInfo *root, Relids joinrelids, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo, List **restrictlist_ptr) {
 	RelOptInfo *joinrel;
-	List	   *restrictlist;
+	//Relation relation;
+	List *restrictlist;
+	int name_len = 0;
+
+	int memo_size = 0;
+	char *rel_names;
+	StringInfoData join_name;
 
 	/*
 	 * See if we already have a joinrel for this set of base rels.
 	 */
 	joinrel = find_join_rel(root, joinrelids);
 
-	if (joinrel)
-	{
+	if (joinrel) {
 		/*
 		 * Yes, so we only need to figure the restrictlist for this particular
 		 * pair of component relations.
 		 */
 		if (restrictlist_ptr)
-			*restrictlist_ptr = build_joinrel_restrictlist(root,
-														   joinrel,
-														   outer_rel,
-														   inner_rel);
+			*restrictlist_ptr = build_joinrel_restrictlist(root, joinrel,
+					outer_rel, inner_rel);
 		return joinrel;
 	}
 
@@ -356,7 +345,7 @@ build_join_rel(PlannerInfo *root,
 	joinrel = makeNode(RelOptInfo);
 	joinrel->reloptkind = RELOPT_JOINREL;
 	joinrel->relids = bms_copy(joinrelids);
-	joinrel->rows = 0;
+	joinrel->rows = -1;
 	joinrel->width = 0;
 	/* cheap startup cost is interesting iff not all tuples to be retrieved */
 	joinrel->consider_startup = (root->tuple_fraction > 0);
@@ -367,7 +356,7 @@ build_join_rel(PlannerInfo *root,
 	joinrel->cheapest_total_path = NULL;
 	joinrel->cheapest_unique_path = NULL;
 	joinrel->cheapest_parameterized_paths = NIL;
-	joinrel->relid = 0;			/* indicates not a baserel */
+	joinrel->relid = 0; /* indicates not a baserel */
 	joinrel->rtekind = RTE_JOIN;
 	joinrel->min_attr = 0;
 	joinrel->max_attr = 0;
@@ -385,12 +374,25 @@ build_join_rel(PlannerInfo *root,
 	joinrel->subplan_params = NIL;
 	joinrel->fdwroutine = NULL;
 	joinrel->fdw_private = NULL;
+	joinrel->workspace = NULL;
 	joinrel->baserestrictinfo = NIL;
 	joinrel->baserestrictcost.startup = 0;
 	joinrel->baserestrictcost.per_tuple = 0;
 	joinrel->joininfo = NIL;
 	joinrel->has_eclass_joins = false;
 
+	/* We build the join mane  separated by colons using names of childs*/
+	/* see stringinfo.h for an explanation of this maneuver */
+	initStringInfo(&join_name);
+	appendStringInfoString(&join_name, inner_rel->rel_name);
+	appendStringInfoChar(&join_name, ',');
+	appendStringInfoString(&join_name, outer_rel->rel_name);
+	joinrel->rel_name = join_name.data;
+	name_len = strlen(join_name.data) + 1;
+	rel_names = palloc(name_len * sizeof(joinrel->rel_name));
+	memset(rel_names, '\0', name_len);
+	strcpy(rel_names, joinrel->rel_name);
+
 	/*
 	 * Create a new tlist containing just the vars that need to be output from
 	 * this join (ie, are needed for higher joinclauses or final output).
@@ -408,8 +410,8 @@ build_join_rel(PlannerInfo *root,
 	 * caller might or might not need the restrictlist, but I need it anyway
 	 * for set_joinrel_size_estimates().)
 	 */
-	restrictlist = build_joinrel_restrictlist(root, joinrel,
-											  outer_rel, inner_rel);
+	restrictlist = build_joinrel_restrictlist(root, joinrel, outer_rel,
+			inner_rel);
 	if (restrictlist_ptr)
 		*restrictlist_ptr = restrictlist;
 	build_joinrel_joinlist(joinrel, outer_rel, inner_rel);
@@ -423,8 +425,16 @@ build_join_rel(PlannerInfo *root,
 	/*
 	 * Set estimates of the joinrel's size.
 	 */
-	set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel,
-							   sjinfo, restrictlist);
+
+	/* hack for memo injection*/ // to-do set_rel
+	if (enable_memo){
+		memo_size = get_join_memo_size(rel_names,root->query_level);
+		joinrel->rows = memo_size;}
+
+
+
+		set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel, sjinfo,
+				restrictlist);
 
 	/*
 	 * Add the joinrel to the query's joinrel list, and store it into the
@@ -433,15 +443,12 @@ build_join_rel(PlannerInfo *root,
 	 */
 	root->join_rel_list = lappend(root->join_rel_list, joinrel);
 
-	if (root->join_rel_hash)
-	{
+	if (root->join_rel_hash) {
 		JoinHashEntry *hentry;
-		bool		found;
+		bool found;
 
 		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash,
-											   &(joinrel->relids),
-											   HASH_ENTER,
-											   &found);
+				&(joinrel->relids), HASH_ENTER, &found);
 		Assert(!found);
 		hentry->join_rel = joinrel;
 	}
@@ -452,12 +459,11 @@ build_join_rel(PlannerInfo *root,
 	 * of members should be for equality, but some of the level 1 rels might
 	 * have been joinrels already, so we can only assert <=.
 	 */
-	if (root->join_rel_level)
-	{
+	if (root->join_rel_level) {
 		Assert(root->join_cur_level > 0);
 		Assert(root->join_cur_level <= bms_num_members(joinrel->relids));
-		root->join_rel_level[root->join_cur_level] =
-			lappend(root->join_rel_level[root->join_cur_level], joinrel);
+		root->join_rel_level[root->join_cur_level] = lappend(
+				root->join_rel_level[root->join_cur_level], joinrel);
 	}
 
 	return joinrel;
@@ -475,18 +481,16 @@ build_join_rel(PlannerInfo *root,
  * We also compute the expected width of the join's output, making use
  * of data that was cached at the baserel level by set_rel_width().
  */
-static void
-build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
-					RelOptInfo *input_rel)
-{
-	Relids		relids = joinrel->relids;
-	ListCell   *vars;
+static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *input_rel) {
+	Relids relids = joinrel->relids;
+	ListCell *vars;
 
 	foreach(vars, input_rel->reltargetlist)
 	{
-		Var		   *var = (Var *) lfirst(vars);
+		Var *var = (Var *) lfirst(vars);
 		RelOptInfo *baserel;
-		int			ndx;
+		int ndx;
 
 		/*
 		 * Ignore PlaceHolderVars in the input tlists; we'll make our own
@@ -502,15 +506,14 @@ build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
 		 */
 		if (!IsA(var, Var))
 			elog(ERROR, "unexpected node type in reltargetlist: %d",
-				 (int) nodeTag(var));
+					(int) nodeTag(var));
 
 		/* Get the Var's original base rel */
 		baserel = find_base_rel(root, var->varno);
 
 		/* Is it still needed above this joinrel? */
 		ndx = var->varattno - baserel->min_attr;
-		if (bms_nonempty_difference(baserel->attr_needed[ndx], relids))
-		{
+		if (bms_nonempty_difference(baserel->attr_needed[ndx], relids)) {
 			/* Yup, add it to the output */
 			joinrel->reltargetlist = lappend(joinrel->reltargetlist, var);
 			joinrel->width += baserel->attr_widths[ndx];
@@ -561,12 +564,9 @@ build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
  * the original nodes in the lists made for the join relation.
  */
 static List *
-build_joinrel_restrictlist(PlannerInfo *root,
-						   RelOptInfo *joinrel,
-						   RelOptInfo *outer_rel,
-						   RelOptInfo *inner_rel)
-{
-	List	   *result;
+build_joinrel_restrictlist(PlannerInfo *root, RelOptInfo *joinrel,
+		RelOptInfo *outer_rel, RelOptInfo *inner_rel) {
+	List *result;
 
 	/*
 	 * Collect all the clauses that syntactically belong at this level,
@@ -574,7 +574,8 @@ build_joinrel_restrictlist(PlannerInfo *root,
 	 * same clauses arriving from both input relations).
 	 */
 	result = subbuild_joinrel_restrictlist(joinrel, outer_rel->joininfo, NIL);
-	result = subbuild_joinrel_restrictlist(joinrel, inner_rel->joininfo, result);
+	result = subbuild_joinrel_restrictlist(joinrel, inner_rel->joininfo,
+			result);
 
 	/*
 	 * Add on any clauses derived from EquivalenceClasses.	These cannot be
@@ -582,20 +583,15 @@ build_joinrel_restrictlist(PlannerInfo *root,
 	 * checking.
 	 */
 	result = list_concat(result,
-						 generate_join_implied_equalities(root,
-														  joinrel->relids,
-														  outer_rel->relids,
-														  inner_rel));
+			generate_join_implied_equalities(root, joinrel->relids,
+					outer_rel->relids, inner_rel));
 
 	return result;
 }
 
-static void
-build_joinrel_joinlist(RelOptInfo *joinrel,
-					   RelOptInfo *outer_rel,
-					   RelOptInfo *inner_rel)
-{
-	List	   *result;
+static void build_joinrel_joinlist(RelOptInfo *joinrel, RelOptInfo *outer_rel,
+		RelOptInfo *inner_rel) {
+	List *result;
 
 	/*
 	 * Collect all the clauses that syntactically belong above this level,
@@ -609,18 +605,15 @@ build_joinrel_joinlist(RelOptInfo *joinrel,
 }
 
 static List *
-subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
-							  List *joininfo_list,
-							  List *new_restrictlist)
-{
-	ListCell   *l;
+subbuild_joinrel_restrictlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_restrictlist) {
+	ListCell *l;
 
 	foreach(l, joininfo_list)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
-		if (bms_is_subset(rinfo->required_relids, joinrel->relids))
-		{
+		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
 			/*
 			 * This clause becomes a restriction clause for the joinrel, since
 			 * it refers to no outside rels.  Add it to the list, being
@@ -629,9 +622,7 @@ subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
 			 * copied, pointer equality should be a sufficient test.)
 			 */
 			new_restrictlist = list_append_unique_ptr(new_restrictlist, rinfo);
-		}
-		else
-		{
+		} else {
 			/*
 			 * This clause is still a join clause at this level, so we ignore
 			 * it in this routine.
@@ -643,26 +634,21 @@ subbuild_joinrel_restrictlist(RelOptInfo *joinrel,
 }
 
 static List *
-subbuild_joinrel_joinlist(RelOptInfo *joinrel,
-						  List *joininfo_list,
-						  List *new_joininfo)
-{
-	ListCell   *l;
+subbuild_joinrel_joinlist(RelOptInfo *joinrel, List *joininfo_list,
+		List *new_joininfo) {
+	ListCell *l;
 
 	foreach(l, joininfo_list)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
-		if (bms_is_subset(rinfo->required_relids, joinrel->relids))
-		{
+		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
 			/*
 			 * This clause becomes a restriction clause for the joinrel, since
 			 * it refers to no outside rels.  So we can ignore it in this
 			 * routine.
 			 */
-		}
-		else
-		{
+		} else {
 			/*
 			 * This clause is still a join clause at this level, so add it to
 			 * the new joininfo list, being careful to eliminate duplicates.
@@ -677,7 +663,6 @@ subbuild_joinrel_joinlist(RelOptInfo *joinrel,
 	return new_joininfo;
 }
 
-
 /*
  * build_empty_join_rel
  *		Build a dummy join relation describing an empty set of base rels.
@@ -688,8 +673,7 @@ subbuild_joinrel_joinlist(RelOptInfo *joinrel,
  * we just need it to carry a simple Result path out of query_planner().
  */
 RelOptInfo *
-build_empty_join_rel(PlannerInfo *root)
-{
+build_empty_join_rel(PlannerInfo *root) {
 	RelOptInfo *joinrel;
 
 	/* The dummy join relation should be the only one ... */
@@ -697,9 +681,9 @@ build_empty_join_rel(PlannerInfo *root)
 
 	joinrel = makeNode(RelOptInfo);
 	joinrel->reloptkind = RELOPT_JOINREL;
-	joinrel->relids = NULL;		/* empty set */
-	joinrel->rows = 1;			/* we produce one row for such cases */
-	joinrel->width = 0;			/* it contains no Vars */
+	joinrel->relids = NULL; /* empty set */
+	joinrel->rows = 1; /* we produce one row for such cases */
+	joinrel->width = 0; /* it contains no Vars */
 	joinrel->rtekind = RTE_JOIN;
 
 	root->join_rel_list = lappend(root->join_rel_list, joinrel);
@@ -707,7 +691,6 @@ build_empty_join_rel(PlannerInfo *root)
 	return joinrel;
 }
 
-
 /*
  * find_childrel_appendrelinfo
  *		Get the AppendRelInfo associated with an appendrel child rel.
@@ -716,10 +699,9 @@ build_empty_join_rel(PlannerInfo *root)
  * but for now it doesn't seem performance-critical.
  */
 AppendRelInfo *
-find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
-{
-	Index		relid = rel->relid;
-	ListCell   *lc;
+find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel) {
+	Index relid = rel->relid;
+	ListCell *lc;
 
 	/* Should only be called on child rels */
 	Assert(rel->reloptkind == RELOPT_OTHER_MEMBER_REL);
@@ -733,10 +715,9 @@ find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
 	}
 	/* should have found the entry ... */
 	elog(ERROR, "child rel %d not found in append_rel_list", relid);
-	return NULL;				/* not reached */
+	return NULL; /* not reached */
 }
 
-
 /*
  * get_baserel_parampathinfo
  *		Get the ParamPathInfo for a parameterized path for a base relation,
@@ -750,13 +731,12 @@ find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel)
  */
 ParamPathInfo *
 get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
-						  Relids required_outer)
-{
+		Relids required_outer) {
 	ParamPathInfo *ppi;
-	Relids		joinrelids;
-	List	   *pclauses;
-	double		rows;
-	ListCell   *lc;
+	Relids joinrelids;
+	List *pclauses;
+	double rows;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo */
 	if (bms_is_empty(required_outer))
@@ -782,9 +762,7 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										baserel->relids,
-										joinrelids))
+		if (join_clause_is_movable_into(rinfo, baserel->relids, joinrelids))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
@@ -793,14 +771,16 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	 * necessarily satisfy join_clause_is_movable_into.)
 	 */
 	pclauses = list_concat(pclauses,
-						   generate_join_implied_equalities(root,
-															joinrelids,
-															required_outer,
-															baserel));
+			generate_join_implied_equalities(root, joinrelids, required_outer,
+					baserel));
 
 	/* Estimate the number of rows returned by the parameterized scan */
+	if(enable_memo){
+		rows = get_baserel_memo_size(baserel->rel_name,root->query_level);
+		}
+		if(rows == -1){
 	rows = get_parameterized_baserel_size(root, baserel, pclauses);
-
+		}
 	/* And now we can build the ParamPathInfo */
 	ppi = makeNode(ParamPathInfo);
 	ppi->ppi_req_outer = required_outer;
@@ -841,20 +821,16 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
  */
 ParamPathInfo *
 get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
-						  Path *outer_path,
-						  Path *inner_path,
-						  SpecialJoinInfo *sjinfo,
-						  Relids required_outer,
-						  List **restrict_clauses)
-{
+		Path *outer_path, Path *inner_path, SpecialJoinInfo *sjinfo,
+		Relids required_outer, List **restrict_clauses) {
 	ParamPathInfo *ppi;
-	Relids		join_and_req;
-	Relids		outer_and_req;
-	Relids		inner_and_req;
-	List	   *pclauses;
-	List	   *eclauses;
-	double		rows;
-	ListCell   *lc;
+	Relids join_and_req;
+	Relids outer_and_req;
+	Relids inner_and_req;
+	List *pclauses;
+	List *eclauses;
+	double rows = -1;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo or extra join clauses */
 	if (bms_is_empty(required_outer))
@@ -874,51 +850,43 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	join_and_req = bms_union(joinrel->relids, required_outer);
 	if (outer_path->param_info)
 		outer_and_req = bms_union(outer_path->parent->relids,
-								  PATH_REQ_OUTER(outer_path));
+				PATH_REQ_OUTER(outer_path));
 	else
-		outer_and_req = NULL;	/* outer path does not accept parameters */
+		outer_and_req = NULL; /* outer path does not accept parameters */
 	if (inner_path->param_info)
 		inner_and_req = bms_union(inner_path->parent->relids,
-								  PATH_REQ_OUTER(inner_path));
+				PATH_REQ_OUTER(inner_path));
 	else
-		inner_and_req = NULL;	/* inner path does not accept parameters */
+		inner_and_req = NULL; /* inner path does not accept parameters */
 
 	pclauses = NIL;
 	foreach(lc, joinrel->joininfo)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		if (join_clause_is_movable_into(rinfo,
-										joinrel->relids,
-										join_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 outer_path->parent->relids,
-										 outer_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 inner_path->parent->relids,
-										 inner_and_req))
+		if (join_clause_is_movable_into(rinfo, joinrel->relids, join_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						outer_path->parent->relids, outer_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						inner_path->parent->relids, inner_and_req))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
 	/* Consider joinclauses generated by EquivalenceClasses, too */
-	eclauses = generate_join_implied_equalities(root,
-												join_and_req,
-												required_outer,
-												joinrel);
+	eclauses = generate_join_implied_equalities(root, join_and_req,
+			required_outer, joinrel);
 	/* We only want ones that aren't movable to lower levels */
 	foreach(lc, eclauses)
 	{
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-		Assert(join_clause_is_movable_into(rinfo,
-										   joinrel->relids,
-										   join_and_req));
-		if (!join_clause_is_movable_into(rinfo,
-										 outer_path->parent->relids,
-										 outer_and_req) &&
-			!join_clause_is_movable_into(rinfo,
-										 inner_path->parent->relids,
-										 inner_and_req))
+		Assert(
+				join_clause_is_movable_into(rinfo, joinrel->relids,
+						join_and_req));
+		if (!join_clause_is_movable_into(rinfo, outer_path->parent->relids,
+				outer_and_req)
+				&& !join_clause_is_movable_into(rinfo,
+						inner_path->parent->relids, inner_and_req))
 			pclauses = lappend(pclauses, rinfo);
 	}
 
@@ -937,12 +905,14 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 			return ppi;
 	}
 
+	if(enable_memo){
+	rows = get_join_memo_size(joinrel->rel_name,root->query_level);
+	}
+	if(rows == -1){
 	/* Estimate the number of rows returned by the parameterized join */
-	rows = get_parameterized_joinrel_size(root, joinrel,
-										  outer_path->rows,
-										  inner_path->rows,
-										  sjinfo,
-										  *restrict_clauses);
+	rows = get_parameterized_joinrel_size(root, joinrel, outer_path->rows,
+			inner_path->rows, sjinfo, *restrict_clauses);
+	}
 
 	/*
 	 * And now we can build the ParamPathInfo.	No point in saving the
@@ -971,10 +941,9 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
  * the Append node isn't responsible for checking quals).
  */
 ParamPathInfo *
-get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer)
-{
+get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer) {
 	ParamPathInfo *ppi;
-	ListCell   *lc;
+	ListCell *lc;
 
 	/* Unparameterized paths have no ParamPathInfo */
 	if (bms_is_empty(required_outer))
@@ -999,3 +968,5 @@ get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer)
 
 	return ppi;
 }
+
+
diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c
index 15020c4..2d8264f 100644
--- a/src/backend/utils/misc/guc.c
+++ b/src/backend/utils/misc/guc.c
@@ -801,6 +801,24 @@ static struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 	{
+		{"enable_memo", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables memo query optimization."),
+			NULL
+		},
+		&enable_memo,
+		false,
+		NULL, NULL, NULL
+	},
+	{
+		{"enable_cost_check", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables memo query optimization."),
+			NULL
+		},
+		&enable_cost_check,
+		false,
+		NULL, NULL, NULL
+	},
+	{
 		/* Not for general use --- used by SET SESSION AUTHORIZATION */
 		{"is_superuser", PGC_INTERNAL, UNGROUPED,
 			gettext_noop("Shows whether the current user is a superuser."),
diff --git a/src/include/nodes/plannodes.h b/src/include/nodes/plannodes.h
index 38c039c..b1c78f3 100644
--- a/src/include/nodes/plannodes.h
+++ b/src/include/nodes/plannodes.h
@@ -95,7 +95,7 @@ typedef struct Plan
 	 */
 	Cost		startup_cost;	/* cost expended before fetching any tuples */
 	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
-
+	Cost 		mtotal_cost;
 	/*
 	 * planner's estimate of result size of this plan step
 	 */
diff --git a/src/include/nodes/relation.h b/src/include/nodes/relation.h
index c607b36..f9f7fc6 100644
--- a/src/include/nodes/relation.h
+++ b/src/include/nodes/relation.h
@@ -265,6 +265,67 @@ typedef struct PlannerInfo
 	((root)->simple_rte_array ? (root)->simple_rte_array[rti] : \
 	 rt_fetch(rti, (root)->parse->rtable))
 
+/*
+ * When making cost estimates for a SEMI or ANTI join, there are some
+ * correction factors that are needed in both nestloop and hash joins
+ * to account for the fact that the executor can stop scanning inner rows
+ * as soon as it finds a match to the current outer row.  These numbers
+ * depend only on the selected outer and inner join relations, not on the
+ * particular paths used for them, so it's worthwhile to calculate them
+ * just once per relation pair not once per considered path.  This struct
+ * is filled by compute_semi_anti_join_factors and must be passed along
+ * to the join cost estimation functions.
+ *
+ * outer_match_frac is the fraction of the outer tuples that are
+ *		expected to have at least one match.
+ * match_count is the average number of matches expected for
+ *		outer tuples that have at least one match.
+ */
+typedef struct SemiAntiJoinFactors
+{
+	Selectivity outer_match_frac;
+	Selectivity match_count;
+} SemiAntiJoinFactors;
+
+/*
+ * For speed reasons, cost estimation for join paths is performed in two
+ * phases: the first phase tries to quickly derive a lower bound for the
+ * join cost, and then we check if that's sufficient to reject the path.
+ * If not, we come back for a more refined cost estimate.  The first phase
+ * fills a JoinCostWorkspace struct with its preliminary cost estimates
+ * and possibly additional intermediate values.  The second phase takes
+ * these values as inputs to avoid repeating work.
+ *
+ * (Ideally we'd declare this in cost.h, but it's also needed in pathnode.h,
+ * so seems best to put it here.)
+ */
+typedef struct JoinCostWorkspace
+{
+	/* Preliminary cost estimates --- must not be larger than final ones! */
+	Cost		startup_cost;	/* cost expended before fetching any tuples */
+	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
+
+	/* Fields below here should be treated as private to costsize.c */
+	Cost		run_cost;		/* non-startup cost components */
+
+	/* private for cost_nestloop code */
+	Cost		inner_rescan_run_cost;
+	double		outer_matched_rows;
+	Selectivity inner_scan_frac;
+
+	/* private for cost_mergejoin code */
+	Cost		inner_run_cost;
+	double		outer_rows;
+	double		inner_rows;
+	double		outer_skip_rows;
+	double		inner_skip_rows;
+
+	SemiAntiJoinFactors *semifactors;
+
+	/* private for cost_hashjoin code */
+	int			numbuckets;
+	int			numbatches;
+} JoinCostWorkspace;
 
 /*----------
  * RelOptInfo
@@ -427,7 +488,7 @@ typedef struct RelOptInfo
 	/* materialization information */
 	List	   *reltargetlist;	/* Vars to be output by scan of relation */
 	List	   *pathlist;		/* Path structures */
-	List	   *ppilist;		/* ParamPathInfos used in pathlist */
+	List	   *ppilist;		/* ParamPathInfos used in pathrlist */
 	struct Path *cheapest_startup_path;
 	struct Path *cheapest_total_path;
 	struct Path *cheapest_unique_path;
@@ -435,6 +496,7 @@ typedef struct RelOptInfo
 
 	/* information about a base rel (not set for join rels!) */
 	Index		relid;
+	char		*rel_name;
 	Oid			reltablespace;	/* containing tablespace */
 	RTEKind		rtekind;		/* RELATION, SUBQUERY, or FUNCTION */
 	AttrNumber	min_attr;		/* smallest attrno of rel (often <0) */
@@ -456,6 +518,7 @@ typedef struct RelOptInfo
 	struct FdwRoutine *fdwroutine;		/* if foreign table */
 	void	   *fdw_private;	/* if foreign table */
 
+	JoinCostWorkspace *workspace; /* used for calculating cost on cardinality injection*/
 	/* used by various scans and joins: */
 	List	   *baserestrictinfo;		/* RestrictInfo structures (if base
 										 * rel) */
@@ -522,6 +585,9 @@ typedef struct IndexOptInfo
 
 	List	   *indextlist;		/* targetlist representing index columns */
 
+
+	double		loop_count;
+
 	bool		predOK;			/* true if predicate matches query */
 	bool		unique;			/* true if a unique index */
 	bool		immediate;		/* is uniqueness enforced immediately? */
@@ -717,15 +783,22 @@ typedef struct Path
 	NodeTag		type;
 
 	NodeTag		pathtype;		/* tag identifying scan/join method */
+	char		*path_name;
 
 	RelOptInfo *parent;			/* the relation this path can build */
 	ParamPathInfo *param_info;	/* parameterization info, or NULL if none */
+	bool 		memo_checked;
 
 	/* estimated size/costs for path (see costsize.c for more info) */
+
 	double		rows;			/* estimated number of result tuples */
 	Cost		startup_cost;	/* cost expended before fetching any tuples */
+
 	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
 
+	double 		mrows;
+	Cost		mstartup_cost;
+	Cost        mtotal_cost;
 	List	   *pathkeys;		/* sort ordering of path's output */
 	/* pathkeys is a List of PathKey nodes; see above */
 } Path;
@@ -820,6 +893,8 @@ typedef struct IndexPath
 typedef struct BitmapHeapPath
 {
 	Path		path;
+
+	double		loop;
 	Path	   *bitmapqual;		/* IndexPath, BitmapAndPath, BitmapOrPath */
 } BitmapHeapPath;
 
@@ -974,7 +1049,6 @@ typedef struct JoinPath
 	Path		path;
 
 	JoinType	jointype;
-
 	Path	   *outerjoinpath;	/* path for the outer side of the join */
 	Path	   *innerjoinpath;	/* path for the inner side of the join */
 
@@ -1583,64 +1657,6 @@ typedef struct PlannerParamItem
 	int			paramId;		/* its assigned PARAM_EXEC slot number */
 } PlannerParamItem;
 
-/*
- * When making cost estimates for a SEMI or ANTI join, there are some
- * correction factors that are needed in both nestloop and hash joins
- * to account for the fact that the executor can stop scanning inner rows
- * as soon as it finds a match to the current outer row.  These numbers
- * depend only on the selected outer and inner join relations, not on the
- * particular paths used for them, so it's worthwhile to calculate them
- * just once per relation pair not once per considered path.  This struct
- * is filled by compute_semi_anti_join_factors and must be passed along
- * to the join cost estimation functions.
- *
- * outer_match_frac is the fraction of the outer tuples that are
- *		expected to have at least one match.
- * match_count is the average number of matches expected for
- *		outer tuples that have at least one match.
- */
-typedef struct SemiAntiJoinFactors
-{
-	Selectivity outer_match_frac;
-	Selectivity match_count;
-} SemiAntiJoinFactors;
-
-/*
- * For speed reasons, cost estimation for join paths is performed in two
- * phases: the first phase tries to quickly derive a lower bound for the
- * join cost, and then we check if that's sufficient to reject the path.
- * If not, we come back for a more refined cost estimate.  The first phase
- * fills a JoinCostWorkspace struct with its preliminary cost estimates
- * and possibly additional intermediate values.  The second phase takes
- * these values as inputs to avoid repeating work.
- *
- * (Ideally we'd declare this in cost.h, but it's also needed in pathnode.h,
- * so seems best to put it here.)
- */
-typedef struct JoinCostWorkspace
-{
-	/* Preliminary cost estimates --- must not be larger than final ones! */
-	Cost		startup_cost;	/* cost expended before fetching any tuples */
-	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
-
-	/* Fields below here should be treated as private to costsize.c */
-	Cost		run_cost;		/* non-startup cost components */
 
-	/* private for cost_nestloop code */
-	Cost		inner_rescan_run_cost;
-	double		outer_matched_rows;
-	Selectivity inner_scan_frac;
-
-	/* private for cost_mergejoin code */
-	Cost		inner_run_cost;
-	double		outer_rows;
-	double		inner_rows;
-	double		outer_skip_rows;
-	double		inner_skip_rows;
-
-	/* private for cost_hashjoin code */
-	int			numbuckets;
-	int			numbatches;
-} JoinCostWorkspace;
 
 #endif   /* RELATION_H */
diff --git a/src/include/optimizer/cost.h b/src/include/optimizer/cost.h
index ec1605d..f6c2931 100644
--- a/src/include/optimizer/cost.h
+++ b/src/include/optimizer/cost.h
@@ -59,6 +59,9 @@ extern bool enable_nestloop;
 extern bool enable_material;
 extern bool enable_mergejoin;
 extern bool enable_hashjoin;
+extern bool enable_memo;
+extern bool enable_cost_check;
+extern bool mode_cost_check;
 extern int	constraint_exclusion;
 
 extern double clamp_row_est(double nrows);
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index a0bcc82..44c6b36 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -157,5 +157,7 @@ extern ParamPathInfo *get_joinrel_parampathinfo(PlannerInfo *root,
 						  List **restrict_clauses);
 extern ParamPathInfo *get_appendrel_parampathinfo(RelOptInfo *appendrel,
 							Relids required_outer);
+extern int get_join_memo_size(char *rel_names, int level);
+extern int get_baserel_memo_size(char *rel_name, int level);
 
 #endif   /* PATHNODE_H */
-- 
1.9.1


From 1f28f59b60fca264e37f5c5615aff84247b7f2bb Mon Sep 17 00:00:00 2001
From: JavierRivas <javieralejandro.rivas@epfl.ch>
Date: Sat, 16 Aug 2014 17:21:24 +0200
Subject: [PATCH 3/3] fixed selectivity clauses check

---
 contrib/file_fdw/file_fdw.c             |    2 +
 src/backend/commands/explain.c          | 2697 ++++++++++++++-----------------
 src/backend/nodes/outfuncs.c            | 2272 ++++++++++++--------------
 src/backend/optimizer/path/clausesel.c  |    9 +-
 src/backend/optimizer/path/costsize.c   |  603 +++----
 src/backend/optimizer/plan/createplan.c |  184 ++-
 src/backend/optimizer/util/pathnode.c   | 1297 +++++++--------
 src/backend/optimizer/util/relnode.c    |  108 +-
 src/backend/utils/misc/guc.c            |    9 +
 src/include/commands/prepare.h          |    2 +-
 src/include/nodes/nodes.h               |    2 +
 src/include/nodes/plannodes.h           |    2 +
 src/include/nodes/relation.h            |    3 +-
 src/include/optimizer/pathnode.h        |    4 +-
 14 files changed, 3273 insertions(+), 3921 deletions(-)

diff --git a/contrib/file_fdw/file_fdw.c b/contrib/file_fdw/file_fdw.c
index 7fb1dbc..7e1017d 100644
--- a/contrib/file_fdw/file_fdw.c
+++ b/contrib/file_fdw/file_fdw.c
@@ -897,6 +897,8 @@ estimate_size(PlannerInfo *root, RelOptInfo *baserel,
 	double		ntuples;
 	double		nrows;
 
+
+
 	/*
 	 * Get size of the file.  It might not be there at plan time, though, in
 	 * which case we have to use a default estimate.
diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 08f3167..b454c72 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -20,6 +20,9 @@
 #include "commands/prepare.h"
 #include "executor/hashjoin.h"
 #include "foreign/fdwapi.h"
+#include "nodes/print.h"
+#include "nodes/outfuncs.h"
+#include "lib/stringinfo.h"
 #include "optimizer/clauses.h"
 #include "parser/parsetree.h"
 #include "rewrite/rewriteHandler.h"
@@ -32,111 +35,100 @@
 #include "utils/tuplesort.h"
 #include "utils/xml.h"
 
-
 /* Hook for plugins to get control in ExplainOneQuery() */
 ExplainOneQuery_hook_type ExplainOneQuery_hook = NULL;
 
 /* Hook for plugins to get control in explain_get_index_name() */
 explain_get_index_name_hook_type explain_get_index_name_hook = NULL;
 
-
 /* OR-able flags for ExplainXMLTag() */
 #define X_OPENING 0
 #define X_CLOSING 1
 #define X_CLOSE_IMMEDIATE 2
 #define X_NOWHITESPACE 4
 
+bool enable_explain_memo = false;
 static void ExplainOneQuery(Query *query, IntoClause *into, ExplainState *es,
-				const char *queryString, ParamListInfo params);
+		const char *queryString, ParamListInfo params);
 static void report_triggers(ResultRelInfo *rInfo, bool show_relname,
-				ExplainState *es);
+		ExplainState *es);
+static void show_scan_parsed_qual(List *qual, const char *qlabel,
+		ExplainState *es);
 static double elapsed_time(instr_time *starttime);
 static void ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used);
 static void ExplainPreScanMemberNodes(List *plans, PlanState **planstates,
-						  Bitmapset **rels_used);
+		Bitmapset **rels_used);
 static void ExplainPreScanSubPlans(List *plans, Bitmapset **rels_used);
 static void ExplainNode(PlanState *planstate, List *ancestors,
-			const char *relationship, const char *plan_name,
-			ExplainState *es);
+		const char *relationship, const char *plan_name, ExplainState *es);
 static void show_plan_tlist(PlanState *planstate, List *ancestors,
-				ExplainState *es);
+		ExplainState *es);
 static void show_expression(Node *node, const char *qlabel,
-				PlanState *planstate, List *ancestors,
-				bool useprefix, ExplainState *es);
-static void show_qual(List *qual, const char *qlabel,
-		  PlanState *planstate, List *ancestors,
-		  bool useprefix, ExplainState *es);
-static void show_scan_qual(List *qual, const char *qlabel,
-			   PlanState *planstate, List *ancestors,
-			   ExplainState *es);
+		PlanState *planstate, List *ancestors, bool useprefix, ExplainState *es);
+static void show_qual(List *qual, const char *qlabel, PlanState *planstate,
+		List *ancestors, bool useprefix, ExplainState *es);
+static void show_scan_qual(List *qual, const char *qlabel, PlanState *planstate,
+		List *ancestors, ExplainState *es);
 static void show_upper_qual(List *qual, const char *qlabel,
-				PlanState *planstate, List *ancestors,
-				ExplainState *es);
+		PlanState *planstate, List *ancestors, ExplainState *es);
 static void show_sort_keys(SortState *sortstate, List *ancestors,
-			   ExplainState *es);
+		ExplainState *es);
 static void show_merge_append_keys(MergeAppendState *mstate, List *ancestors,
-					   ExplainState *es);
-static void show_agg_keys(AggState *astate, List *ancestors,
-			  ExplainState *es);
+		ExplainState *es);
+static void show_agg_keys(AggState *astate, List *ancestors, ExplainState *es);
 static void show_group_keys(GroupState *gstate, List *ancestors,
-				ExplainState *es);
+		ExplainState *es);
 static void show_sort_group_keys(PlanState *planstate, const char *qlabel,
-					 int nkeys, AttrNumber *keycols,
-					 List *ancestors, ExplainState *es);
+		int nkeys, AttrNumber *keycols, List *ancestors, ExplainState *es);
 static void show_sort_info(SortState *sortstate, ExplainState *es);
 static void show_hash_info(HashState *hashstate, ExplainState *es);
 static void show_tidbitmap_info(BitmapHeapScanState *planstate,
-								ExplainState *es);
+		ExplainState *es);
 static void show_instrumentation_count(const char *qlabel, int which,
-						   PlanState *planstate, ExplainState *es);
+		PlanState *planstate, ExplainState *es);
 static void show_foreignscan_info(ForeignScanState *fsstate, ExplainState *es);
 static const char *explain_get_index_name(Oid indexId);
 static void ExplainIndexScanDetails(Oid indexid, ScanDirection indexorderdir,
-						ExplainState *es);
+		ExplainState *es);
 static void ExplainScanTarget(Scan *plan, ExplainState *es);
 static void ExplainModifyTarget(ModifyTable *plan, ExplainState *es);
 static void ExplainTargetRel(Plan *plan, Index rti, ExplainState *es);
 static void show_modifytable_info(ModifyTableState *mtstate, ExplainState *es);
 static void ExplainMemberNodes(List *plans, PlanState **planstates,
-				   List *ancestors, ExplainState *es);
+		List *ancestors, ExplainState *es);
 static void ExplainSubPlans(List *plans, List *ancestors,
-				const char *relationship, ExplainState *es);
-static void ExplainProperty(const char *qlabel, const char *value,
-				bool numeric, ExplainState *es);
+		const char *relationship, ExplainState *es);
+static void ExplainProperty(const char *qlabel, const char *value, bool numeric,
+		ExplainState *es);
 static void ExplainOpenGroup(const char *objtype, const char *labelname,
-				 bool labeled, ExplainState *es);
+		bool labeled, ExplainState *es);
 static void ExplainCloseGroup(const char *objtype, const char *labelname,
-				  bool labeled, ExplainState *es);
+		bool labeled, ExplainState *es);
 static void ExplainDummyGroup(const char *objtype, const char *labelname,
-				  ExplainState *es);
+		ExplainState *es);
 static void ExplainXMLTag(const char *tagname, int flags, ExplainState *es);
 static void ExplainJSONLineEnding(ExplainState *es);
 static void ExplainYAMLLineStarting(ExplainState *es);
 static void escape_yaml(StringInfo buf, const char *str);
-
-
+static void get_varattno(Expr * expr, Datum* att);
 
 /*
  * ExplainQuery -
  *	  execute an EXPLAIN command
  */
-void
-ExplainQuery(ExplainStmt *stmt, const char *queryString,
-			 ParamListInfo params, DestReceiver *dest)
-{
+void ExplainQuery(ExplainStmt *stmt, const char *queryString,
+		ParamListInfo params, DestReceiver *dest) {
 	ExplainState es;
 	TupOutputState *tstate;
-	List	   *rewritten;
-	ListCell   *lc;
-	bool		timing_set = false;
+	List *rewritten;
+	ListCell *lc;
+	bool timing_set = false;
 
 	/* Initialize ExplainState. */
 	ExplainInitState(&es);
 
-	/* Parse options list. */
-	foreach(lc, stmt->options)
-	{
-		DefElem    *opt = (DefElem *) lfirst(lc);
+	/* Parse options list. */foreach(lc, stmt->options) {
+		DefElem *opt = (DefElem *) lfirst(lc);
 
 		if (strcmp(opt->defname, "analyze") == 0)
 			es.analyze = defGetBoolean(opt);
@@ -146,14 +138,11 @@ ExplainQuery(ExplainStmt *stmt, const char *queryString,
 			es.costs = defGetBoolean(opt);
 		else if (strcmp(opt->defname, "buffers") == 0)
 			es.buffers = defGetBoolean(opt);
-		else if (strcmp(opt->defname, "timing") == 0)
-		{
+		else if (strcmp(opt->defname, "timing") == 0) {
 			timing_set = true;
 			es.timing = defGetBoolean(opt);
-		}
-		else if (strcmp(opt->defname, "format") == 0)
-		{
-			char	   *p = defGetString(opt);
+		} else if (strcmp(opt->defname, "format") == 0) {
+			char *p = defGetString(opt);
 
 			if (strcmp(p, "text") == 0)
 				es.format = EXPLAIN_FORMAT_TEXT;
@@ -165,21 +154,15 @@ ExplainQuery(ExplainStmt *stmt, const char *queryString,
 				es.format = EXPLAIN_FORMAT_YAML;
 			else
 				ereport(ERROR,
-						(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-				errmsg("unrecognized value for EXPLAIN option \"%s\": \"%s\"",
-					   opt->defname, p)));
-		}
-		else
+						(errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg("unrecognized value for EXPLAIN option \"%s\": \"%s\"", opt->defname, p)));
+		} else
 			ereport(ERROR,
-					(errcode(ERRCODE_SYNTAX_ERROR),
-					 errmsg("unrecognized EXPLAIN option \"%s\"",
-							opt->defname)));
+					(errcode(ERRCODE_SYNTAX_ERROR), errmsg("unrecognized EXPLAIN option \"%s\"", opt->defname)));
 	}
 
 	if (es.buffers && !es.analyze)
 		ereport(ERROR,
-				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-				 errmsg("EXPLAIN option BUFFERS requires ANALYZE")));
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg("EXPLAIN option BUFFERS requires ANALYZE")));
 
 	/* if the timing was not set explicitly, set default value */
 	es.timing = (timing_set) ? es.timing : es.analyze;
@@ -187,8 +170,7 @@ ExplainQuery(ExplainStmt *stmt, const char *queryString,
 	/* check that timing is used with EXPLAIN ANALYZE */
 	if (es.timing && !es.analyze)
 		ereport(ERROR,
-				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
-				 errmsg("EXPLAIN option TIMING requires ANALYZE")));
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg("EXPLAIN option TIMING requires ANALYZE")));
 
 	/*
 	 * Parse analysis was done already, but we still have to run the rule
@@ -208,24 +190,20 @@ ExplainQuery(ExplainStmt *stmt, const char *queryString,
 	/* emit opening boilerplate */
 	ExplainBeginOutput(&es);
 
-	if (rewritten == NIL)
-	{
+	if (rewritten == NIL) {
 		/*
 		 * In the case of an INSTEAD NOTHING, tell at least that.  But in
 		 * non-text format, the output is delimited, so this isn't necessary.
 		 */
 		if (es.format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfoString(es.str, "Query rewrites to nothing\n");
-	}
-	else
-	{
-		ListCell   *l;
+	} else {
+		ListCell *l;
 
 		/* Explain every plan */
-		foreach(l, rewritten)
-		{
-			ExplainOneQuery((Query *) lfirst(l), NULL, &es,
-							queryString, params);
+		foreach(l, rewritten) {
+			ExplainOneQuery((Query *) lfirst(l), NULL, &es, queryString,
+					params);
 
 			/* Separate plans with an appropriate separator */
 			if (lnext(l) != NULL)
@@ -251,9 +229,7 @@ ExplainQuery(ExplainStmt *stmt, const char *queryString,
 /*
  * Initialize ExplainState.
  */
-void
-ExplainInitState(ExplainState *es)
-{
+void ExplainInitState(ExplainState *es) {
 	/* Set default options. */
 	memset(es, 0, sizeof(ExplainState));
 	es->costs = true;
@@ -265,21 +241,16 @@ ExplainInitState(ExplainState *es)
  * ExplainResultDesc -
  *	  construct the result tupledesc for an EXPLAIN
  */
-TupleDesc
-ExplainResultDesc(ExplainStmt *stmt)
-{
-	TupleDesc	tupdesc;
-	ListCell   *lc;
-	Oid			result_type = TEXTOID;
-
-	/* Check for XML format option */
-	foreach(lc, stmt->options)
-	{
-		DefElem    *opt = (DefElem *) lfirst(lc);
-
-		if (strcmp(opt->defname, "format") == 0)
-		{
-			char	   *p = defGetString(opt);
+TupleDesc ExplainResultDesc(ExplainStmt *stmt) {
+	TupleDesc tupdesc;
+	ListCell *lc;
+	Oid result_type = TEXTOID;
+
+	/* Check for XML format option */foreach(lc, stmt->options) {
+		DefElem *opt = (DefElem *) lfirst(lc);
+
+		if (strcmp(opt->defname, "format") == 0) {
+			char *p = defGetString(opt);
 
 			if (strcmp(p, "xml") == 0)
 				result_type = XMLOID;
@@ -293,8 +264,8 @@ ExplainResultDesc(ExplainStmt *stmt)
 
 	/* Need a tuple descriptor representing a single TEXT or XML column */
 	tupdesc = CreateTemplateTupleDesc(1, false);
-	TupleDescInitEntry(tupdesc, (AttrNumber) 1, "QUERY PLAN",
-					   result_type, -1, 0);
+	TupleDescInitEntry(tupdesc, (AttrNumber) 1, "QUERY PLAN", result_type, -1,
+			0);
 	return tupdesc;
 }
 
@@ -304,24 +275,20 @@ ExplainResultDesc(ExplainStmt *stmt)
  *
  * "into" is NULL unless we are explaining the contents of a CreateTableAsStmt.
  */
-static void
-ExplainOneQuery(Query *query, IntoClause *into, ExplainState *es,
-				const char *queryString, ParamListInfo params)
-{
+static void ExplainOneQuery(Query *query, IntoClause *into, ExplainState *es,
+		const char *queryString, ParamListInfo params) {
 	/* planner will not cope with utility statements */
-	if (query->commandType == CMD_UTILITY)
-	{
+	if (query->commandType == CMD_UTILITY) {
 		ExplainOneUtility(query->utilityStmt, into, es, queryString, params);
 		return;
 	}
 
 	/* if an advisor plugin is present, let it manage things */
 	if (ExplainOneQuery_hook)
-		(*ExplainOneQuery_hook) (query, into, es, queryString, params);
-	else
-	{
-		PlannedStmt	*plan;
-		instr_time	planstart, planduration;
+		(*ExplainOneQuery_hook)(query, into, es, queryString, params);
+	else {
+		PlannedStmt *plan;
+		instr_time planstart, planduration;
 
 		INSTR_TIME_SET_CURRENT(planstart);
 
@@ -347,44 +314,37 @@ ExplainOneQuery(Query *query, IntoClause *into, ExplainState *es,
  * This is exported because it's called back from prepare.c in the
  * EXPLAIN EXECUTE case.
  */
-void
-ExplainOneUtility(Node *utilityStmt, IntoClause *into, ExplainState *es,
-				  const char *queryString, ParamListInfo params)
-{
+void ExplainOneUtility(Node *utilityStmt, IntoClause *into, ExplainState *es,
+		const char *queryString, ParamListInfo params) {
 	if (utilityStmt == NULL)
 		return;
 
-	if (IsA(utilityStmt, CreateTableAsStmt))
-	{
+	if (IsA(utilityStmt, CreateTableAsStmt)) {
 		/*
 		 * We have to rewrite the contained SELECT and then pass it back to
 		 * ExplainOneQuery.  It's probably not really necessary to copy the
 		 * contained parsetree another time, but let's be safe.
 		 */
 		CreateTableAsStmt *ctas = (CreateTableAsStmt *) utilityStmt;
-		List	   *rewritten;
+		List *rewritten;
 
 		Assert(IsA(ctas->query, Query));
 		rewritten = QueryRewrite((Query *) copyObject(ctas->query));
 		Assert(list_length(rewritten) == 1);
 		ExplainOneQuery((Query *) linitial(rewritten), ctas->into, es,
-						queryString, params);
-	}
-	else if (IsA(utilityStmt, ExecuteStmt))
-		ExplainExecuteQuery((ExecuteStmt *) utilityStmt, into, es,
-							queryString, params);
-	else if (IsA(utilityStmt, NotifyStmt))
-	{
+				queryString, params);
+	} else if (IsA(utilityStmt, ExecuteStmt))
+		ExplainExecuteQuery((ExecuteStmt *) utilityStmt, into, es, queryString,
+				params);
+	else if (IsA(utilityStmt, NotifyStmt)) {
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfoString(es->str, "NOTIFY\n");
 		else
 			ExplainDummyGroup("Notify", NULL, es);
-	}
-	else
-	{
+	} else {
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfoString(es->str,
-							  "Utility statements have no plan structure\n");
+					"Utility statements have no plan structure\n");
 		else
 			ExplainDummyGroup("Utility Statement", NULL, es);
 	}
@@ -407,17 +367,15 @@ ExplainOneUtility(Node *utilityStmt, IntoClause *into, ExplainState *es,
  * EXPLAIN EXECUTE case, and because an index advisor plugin would need
  * to call it.
  */
-void
-ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
-			   const char *queryString, ParamListInfo params,
-			   const instr_time *planduration)
-{
+void ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into,
+		ExplainState *es, const char *queryString, ParamListInfo params,
+		const instr_time *planduration) {
 	DestReceiver *dest;
-	QueryDesc  *queryDesc;
-	instr_time	starttime;
-	double		totaltime = 0;
-	int			eflags;
-	int			instrument_option = 0;
+	QueryDesc *queryDesc;
+	instr_time starttime;
+	double totaltime = 0;
+	int eflags;
+	int instrument_option = 0;
 
 	if (es->analyze && es->timing)
 		instrument_option |= INSTRUMENT_TIMER;
@@ -450,13 +408,12 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
 		dest = None_Receiver;
 
 	/* Create a QueryDesc for the query */
-	queryDesc = CreateQueryDesc(plannedstmt, queryString,
-								GetActiveSnapshot(), InvalidSnapshot,
-								dest, params, instrument_option);
+	queryDesc = CreateQueryDesc(plannedstmt, queryString, GetActiveSnapshot(),
+			InvalidSnapshot, dest, params, instrument_option);
 
 	/* Select execution options */
 	if (es->analyze)
-		eflags = 0;				/* default run-to-completion flags */
+		eflags = 0; /* default run-to-completion flags */
 	else
 		eflags = EXEC_FLAG_EXPLAIN_ONLY;
 	if (into)
@@ -466,8 +423,7 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
 	ExecutorStart(queryDesc, eflags);
 
 	/* Execute the plan for statistics if asked for */
-	if (es->analyze)
-	{
+	if (es->analyze) {
 		ScanDirection dir;
 
 		/* EXPLAIN ANALYZE CREATE TABLE AS WITH NO DATA is weird */
@@ -491,13 +447,12 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
 	/* Create textual dump of plan tree */
 	ExplainPrintPlan(es, queryDesc);
 
-	if (es->costs && planduration)
-	{
+	if (es->costs && planduration) {
 		double plantime = INSTR_TIME_GET_DOUBLE(*planduration);
 
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfo(es->str, "Planning time: %.3f ms\n",
-							 1000.0 * plantime);
+					1000.0 * plantime);
 		else
 			ExplainPropertyFloat("Planning Time", 1000.0 * plantime, 3, es);
 	}
@@ -524,14 +479,12 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
 
 	totaltime += elapsed_time(&starttime);
 
-	if (es->analyze)
-	{
+	if (es->analyze) {
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfo(es->str, "Total runtime: %.3f ms\n",
-							 1000.0 * totaltime);
+					1000.0 * totaltime);
 		else
-			ExplainPropertyFloat("Total Runtime", 1000.0 * totaltime,
-								 3, es);
+			ExplainPropertyFloat("Total Runtime", 1000.0 * totaltime, 3, es);
 	}
 
 	ExplainCloseGroup("Query", NULL, true, es);
@@ -547,10 +500,8 @@ ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es,
  *
  * NB: will not work on utility statements
  */
-void
-ExplainPrintPlan(ExplainState *es, QueryDesc *queryDesc)
-{
-	Bitmapset  *rels_used = NULL;
+void ExplainPrintPlan(ExplainState *es, QueryDesc *queryDesc) {
+	Bitmapset *rels_used = NULL;
 
 	Assert(queryDesc->plannedstmt != NULL);
 	es->pstmt = queryDesc->plannedstmt;
@@ -570,15 +521,13 @@ ExplainPrintPlan(ExplainState *es, QueryDesc *queryDesc)
  * initializing the output buffer es->str.	Other fields in *es are
  * initialized here.
  */
-void
-ExplainPrintTriggers(ExplainState *es, QueryDesc *queryDesc)
-{
+void ExplainPrintTriggers(ExplainState *es, QueryDesc *queryDesc) {
 	ResultRelInfo *rInfo;
-	bool		show_relname;
-	int			numrels = queryDesc->estate->es_num_result_relations;
-	List	   *targrels = queryDesc->estate->es_trig_target_relations;
-	int			nr;
-	ListCell   *l;
+	bool show_relname;
+	int numrels = queryDesc->estate->es_num_result_relations;
+	List *targrels = queryDesc->estate->es_trig_target_relations;
+	int nr;
+	ListCell *l;
 
 	ExplainOpenGroup("Triggers", "Triggers", false, es);
 
@@ -587,8 +536,7 @@ ExplainPrintTriggers(ExplainState *es, QueryDesc *queryDesc)
 	for (nr = 0; nr < numrels; rInfo++, nr++)
 		report_triggers(rInfo, show_relname, es);
 
-	foreach(l, targrels)
-	{
+	foreach(l, targrels) {
 		rInfo = (ResultRelInfo *) lfirst(l);
 		report_triggers(rInfo, show_relname, es);
 	}
@@ -604,9 +552,7 @@ ExplainPrintTriggers(ExplainState *es, QueryDesc *queryDesc)
  * initializing the output buffer es->str.
  *
  */
-void
-ExplainQueryText(ExplainState *es, QueryDesc *queryDesc)
-{
+void ExplainQueryText(ExplainState *es, QueryDesc *queryDesc) {
 	if (queryDesc->sourceText)
 		ExplainPropertyText("Query Text", queryDesc->sourceText, es);
 }
@@ -615,19 +561,17 @@ ExplainQueryText(ExplainState *es, QueryDesc *queryDesc)
  * report_triggers -
  *		report execution stats for a single relation's triggers
  */
-static void
-report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
-{
-	int			nt;
+static void report_triggers(ResultRelInfo *rInfo, bool show_relname,
+		ExplainState *es) {
+	int nt;
 
 	if (!rInfo->ri_TrigDesc || !rInfo->ri_TrigInstrument)
 		return;
-	for (nt = 0; nt < rInfo->ri_TrigDesc->numtriggers; nt++)
-	{
-		Trigger    *trig = rInfo->ri_TrigDesc->triggers + nt;
+	for (nt = 0; nt < rInfo->ri_TrigDesc->numtriggers; nt++) {
+		Trigger *trig = rInfo->ri_TrigDesc->triggers + nt;
 		Instrumentation *instr = rInfo->ri_TrigInstrument + nt;
-		char	   *relname;
-		char	   *conname = NULL;
+		char *relname;
+		char *conname = NULL;
 
 		/* Must clean up instrumentation state */
 		InstrEndLoop(instr);
@@ -650,8 +594,7 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 		 * constraint name unless VERBOSE is specified.  In non-text formats
 		 * we just print everything.
 		 */
-		if (es->format == EXPLAIN_FORMAT_TEXT)
-		{
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
 			if (es->verbose || conname == NULL)
 				appendStringInfo(es->str, "Trigger %s", trig->tgname);
 			else
@@ -661,10 +604,8 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 			if (show_relname)
 				appendStringInfo(es->str, " on %s", relname);
 			appendStringInfo(es->str, ": time=%.3f calls=%.0f\n",
-							 1000.0 * instr->total, instr->ntuples);
-		}
-		else
-		{
+					1000.0 * instr->total, instr->ntuples);
+		} else {
 			ExplainPropertyText("Trigger Name", trig->tgname, es);
 			if (conname)
 				ExplainPropertyText("Constraint Name", conname, es);
@@ -681,10 +622,8 @@ report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es)
 }
 
 /* Compute elapsed time in seconds since given timestamp */
-static double
-elapsed_time(instr_time *starttime)
-{
-	instr_time	endtime;
+static double elapsed_time(instr_time *starttime) {
+	instr_time endtime;
 
 	INSTR_TIME_SET_CURRENT(endtime);
 	INSTR_TIME_SUBTRACT(endtime, *starttime);
@@ -700,34 +639,30 @@ elapsed_time(instr_time *starttime)
  * This ensures that we don't confusingly assign un-suffixed aliases to RTEs
  * that never appear in the EXPLAIN output (such as inheritance parents).
  */
-static void
-ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used)
-{
-	Plan	   *plan = planstate->plan;
-
-	switch (nodeTag(plan))
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			*rels_used = bms_add_member(*rels_used,
-										((Scan *) plan)->scanrelid);
-			break;
-		case T_ModifyTable:
-			/* cf ExplainModifyTarget */
-			*rels_used = bms_add_member(*rels_used,
-					  linitial_int(((ModifyTable *) plan)->resultRelations));
-			break;
-		default:
-			break;
+static void ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used) {
+	Plan *plan = planstate->plan;
+
+	switch (nodeTag(plan)) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		*rels_used = bms_add_member(*rels_used, ((Scan *) plan)->scanrelid);
+		break;
+	case T_ModifyTable:
+		/* cf ExplainModifyTarget */
+		*rels_used = bms_add_member(*rels_used,
+				linitial_int(((ModifyTable *) plan)->resultRelations));
+		break;
+	default:
+		break;
 	}
 
 	/* initPlan-s */
@@ -743,39 +678,33 @@ ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used)
 		ExplainPreScanNode(innerPlanState(planstate), rels_used);
 
 	/* special child plans */
-	switch (nodeTag(plan))
-	{
-		case T_ModifyTable:
-			ExplainPreScanMemberNodes(((ModifyTable *) plan)->plans,
-								  ((ModifyTableState *) planstate)->mt_plans,
-									  rels_used);
-			break;
-		case T_Append:
-			ExplainPreScanMemberNodes(((Append *) plan)->appendplans,
-									((AppendState *) planstate)->appendplans,
-									  rels_used);
-			break;
-		case T_MergeAppend:
-			ExplainPreScanMemberNodes(((MergeAppend *) plan)->mergeplans,
-								((MergeAppendState *) planstate)->mergeplans,
-									  rels_used);
-			break;
-		case T_BitmapAnd:
-			ExplainPreScanMemberNodes(((BitmapAnd *) plan)->bitmapplans,
-								 ((BitmapAndState *) planstate)->bitmapplans,
-									  rels_used);
-			break;
-		case T_BitmapOr:
-			ExplainPreScanMemberNodes(((BitmapOr *) plan)->bitmapplans,
-								  ((BitmapOrState *) planstate)->bitmapplans,
-									  rels_used);
-			break;
-		case T_SubqueryScan:
-			ExplainPreScanNode(((SubqueryScanState *) planstate)->subplan,
-							   rels_used);
-			break;
-		default:
-			break;
+	switch (nodeTag(plan)) {
+	case T_ModifyTable:
+		ExplainPreScanMemberNodes(((ModifyTable *) plan)->plans,
+				((ModifyTableState *) planstate)->mt_plans, rels_used);
+		break;
+	case T_Append:
+		ExplainPreScanMemberNodes(((Append *) plan)->appendplans,
+				((AppendState *) planstate)->appendplans, rels_used);
+		break;
+	case T_MergeAppend:
+		ExplainPreScanMemberNodes(((MergeAppend *) plan)->mergeplans,
+				((MergeAppendState *) planstate)->mergeplans, rels_used);
+		break;
+	case T_BitmapAnd:
+		ExplainPreScanMemberNodes(((BitmapAnd *) plan)->bitmapplans,
+				((BitmapAndState *) planstate)->bitmapplans, rels_used);
+		break;
+	case T_BitmapOr:
+		ExplainPreScanMemberNodes(((BitmapOr *) plan)->bitmapplans,
+				((BitmapOrState *) planstate)->bitmapplans, rels_used);
+		break;
+	case T_SubqueryScan:
+		ExplainPreScanNode(((SubqueryScanState *) planstate)->subplan,
+				rels_used);
+		break;
+	default:
+		break;
 	}
 
 	/* subPlan-s */
@@ -790,12 +719,10 @@ ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used)
  * Note: we don't actually need to examine the Plan list members, but
  * we need the list in order to determine the length of the PlanState array.
  */
-static void
-ExplainPreScanMemberNodes(List *plans, PlanState **planstates,
-						  Bitmapset **rels_used)
-{
-	int			nplans = list_length(plans);
-	int			j;
+static void ExplainPreScanMemberNodes(List *plans, PlanState **planstates,
+		Bitmapset **rels_used) {
+	int nplans = list_length(plans);
+	int j;
 
 	for (j = 0; j < nplans; j++)
 		ExplainPreScanNode(planstates[j], rels_used);
@@ -804,13 +731,10 @@ ExplainPreScanMemberNodes(List *plans, PlanState **planstates,
 /*
  * Prescan a list of SubPlans (or initPlans, which also use SubPlan nodes).
  */
-static void
-ExplainPreScanSubPlans(List *plans, Bitmapset **rels_used)
-{
-	ListCell   *lst;
+static void ExplainPreScanSubPlans(List *plans, Bitmapset **rels_used) {
+	ListCell *lst;
 
-	foreach(lst, plans)
-	{
+	foreach(lst, plans) {
 		SubPlanState *sps = (SubPlanState *) lfirst(lst);
 
 		ExplainPreScanNode(sps->planstate, rels_used);
@@ -837,196 +761,182 @@ ExplainPreScanSubPlans(List *plans, Bitmapset **rels_used)
  * corresponds to the nesting depth of logical output groups, and therefore
  * is controlled by ExplainOpenGroup/ExplainCloseGroup.
  */
-static void
-ExplainNode(PlanState *planstate, List *ancestors,
-			const char *relationship, const char *plan_name,
-			ExplainState *es)
-{
-	Plan	   *plan = planstate->plan;
-	const char *pname;			/* node type name for text output */
-	const char *sname;			/* node type name for non-text output */
+static void ExplainNode(PlanState *planstate, List *ancestors,
+		const char *relationship, const char *plan_name, ExplainState *es) {
+	Plan *plan = planstate->plan;
+	const char *pname; /* node type name for text output */
+	const char *sname; /* node type name for non-text output */
 	const char *strategy = NULL;
 	const char *operation = NULL;
-	int			save_indent = es->indent;
-	bool		haschildren;
+	int save_indent = es->indent;
+	bool haschildren;
 
-	switch (nodeTag(plan))
-	{
-		case T_Result:
-			pname = sname = "Result";
-			break;
-		case T_ModifyTable:
-			sname = "ModifyTable";
-			switch (((ModifyTable *) plan)->operation)
-			{
-				case CMD_INSERT:
-					pname = operation = "Insert";
-					break;
-				case CMD_UPDATE:
-					pname = operation = "Update";
-					break;
-				case CMD_DELETE:
-					pname = operation = "Delete";
-					break;
-				default:
-					pname = "???";
-					break;
-			}
-			break;
-		case T_Append:
-			pname = sname = "Append";
-			break;
-		case T_MergeAppend:
-			pname = sname = "Merge Append";
-			break;
-		case T_RecursiveUnion:
-			pname = sname = "Recursive Union";
-			break;
-		case T_BitmapAnd:
-			pname = sname = "BitmapAnd";
-			break;
-		case T_BitmapOr:
-			pname = sname = "BitmapOr";
-			break;
-		case T_NestLoop:
-			pname = sname = "Nested Loop";
-			break;
-		case T_MergeJoin:
-			pname = "Merge";	/* "Join" gets added by jointype switch */
-			sname = "Merge Join";
+	switch (nodeTag(plan)) {
+	case T_Result:
+		pname = sname = "Result";
+		break;
+	case T_ModifyTable:
+		sname = "ModifyTable";
+		switch (((ModifyTable *) plan)->operation) {
+		case CMD_INSERT:
+			pname = operation = "Insert";
 			break;
-		case T_HashJoin:
-			pname = "Hash";		/* "Join" gets added by jointype switch */
-			sname = "Hash Join";
+		case CMD_UPDATE:
+			pname = operation = "Update";
 			break;
-		case T_SeqScan:
-			pname = sname = "Seq Scan";
+		case CMD_DELETE:
+			pname = operation = "Delete";
 			break;
-		case T_IndexScan:
-			pname = sname = "Index Scan";
-			break;
-		case T_IndexOnlyScan:
-			pname = sname = "Index Only Scan";
-			break;
-		case T_BitmapIndexScan:
-			pname = sname = "Bitmap Index Scan";
-			break;
-		case T_BitmapHeapScan:
-			pname = sname = "Bitmap Heap Scan";
-			break;
-		case T_TidScan:
-			pname = sname = "Tid Scan";
-			break;
-		case T_SubqueryScan:
-			pname = sname = "Subquery Scan";
-			break;
-		case T_FunctionScan:
-			pname = sname = "Function Scan";
-			break;
-		case T_ValuesScan:
-			pname = sname = "Values Scan";
-			break;
-		case T_CteScan:
-			pname = sname = "CTE Scan";
-			break;
-		case T_WorkTableScan:
-			pname = sname = "WorkTable Scan";
-			break;
-		case T_ForeignScan:
-			pname = sname = "Foreign Scan";
-			break;
-		case T_Material:
-			pname = sname = "Materialize";
-			break;
-		case T_Sort:
-			pname = sname = "Sort";
-			break;
-		case T_Group:
-			pname = sname = "Group";
-			break;
-		case T_Agg:
-			sname = "Aggregate";
-			switch (((Agg *) plan)->aggstrategy)
-			{
-				case AGG_PLAIN:
-					pname = "Aggregate";
-					strategy = "Plain";
-					break;
-				case AGG_SORTED:
-					pname = "GroupAggregate";
-					strategy = "Sorted";
-					break;
-				case AGG_HASHED:
-					pname = "HashAggregate";
-					strategy = "Hashed";
-					break;
-				default:
-					pname = "Aggregate ???";
-					strategy = "???";
-					break;
-			}
-			break;
-		case T_WindowAgg:
-			pname = sname = "WindowAgg";
-			break;
-		case T_Unique:
-			pname = sname = "Unique";
-			break;
-		case T_SetOp:
-			sname = "SetOp";
-			switch (((SetOp *) plan)->strategy)
-			{
-				case SETOP_SORTED:
-					pname = "SetOp";
-					strategy = "Sorted";
-					break;
-				case SETOP_HASHED:
-					pname = "HashSetOp";
-					strategy = "Hashed";
-					break;
-				default:
-					pname = "SetOp ???";
-					strategy = "???";
-					break;
-			}
+		default:
+			pname = "???";
 			break;
-		case T_LockRows:
-			pname = sname = "LockRows";
+		}
+		break;
+	case T_Append:
+		pname = sname = "Append";
+		break;
+	case T_MergeAppend:
+		pname = sname = "Merge Append";
+		break;
+	case T_RecursiveUnion:
+		pname = sname = "Recursive Union";
+		break;
+	case T_BitmapAnd:
+		pname = sname = "BitmapAnd";
+		break;
+	case T_BitmapOr:
+		pname = sname = "BitmapOr";
+		break;
+	case T_NestLoop:
+		pname = sname = "Nested Loop";
+		break;
+	case T_MergeJoin:
+		pname = "Merge"; /* "Join" gets added by jointype switch */
+		sname = "Merge Join";
+		break;
+	case T_HashJoin:
+		pname = "Hash"; /* "Join" gets added by jointype switch */
+		sname = "Hash Join";
+		break;
+	case T_SeqScan:
+		pname = sname = "Seq Scan";
+		break;
+	case T_IndexScan:
+		pname = sname = "Index Scan";
+		break;
+	case T_IndexOnlyScan:
+		pname = sname = "Index Only Scan";
+		break;
+	case T_BitmapIndexScan:
+		pname = sname = "Bitmap Index Scan";
+		break;
+	case T_BitmapHeapScan:
+		pname = sname = "Bitmap Heap Scan";
+		break;
+	case T_TidScan:
+		pname = sname = "Tid Scan";
+		break;
+	case T_SubqueryScan:
+		pname = sname = "Subquery Scan";
+		break;
+	case T_FunctionScan:
+		pname = sname = "Function Scan";
+		break;
+	case T_ValuesScan:
+		pname = sname = "Values Scan";
+		break;
+	case T_CteScan:
+		pname = sname = "CTE Scan";
+		break;
+	case T_WorkTableScan:
+		pname = sname = "WorkTable Scan";
+		break;
+	case T_ForeignScan:
+		pname = sname = "Foreign Scan";
+		break;
+	case T_Material:
+		pname = sname = "Materialize";
+		break;
+	case T_Sort:
+		pname = sname = "Sort";
+		break;
+	case T_Group:
+		pname = sname = "Group";
+		break;
+	case T_Agg:
+		sname = "Aggregate";
+		switch (((Agg *) plan)->aggstrategy) {
+		case AGG_PLAIN:
+			pname = "Aggregate";
+			strategy = "Plain";
+			break;
+		case AGG_SORTED:
+			pname = "GroupAggregate";
+			strategy = "Sorted";
+			break;
+		case AGG_HASHED:
+			pname = "HashAggregate";
+			strategy = "Hashed";
 			break;
-		case T_Limit:
-			pname = sname = "Limit";
+		default:
+			pname = "Aggregate ???";
+			strategy = "???";
 			break;
-		case T_Hash:
-			pname = sname = "Hash";
+		}
+		break;
+	case T_WindowAgg:
+		pname = sname = "WindowAgg";
+		break;
+	case T_Unique:
+		pname = sname = "Unique";
+		break;
+	case T_SetOp:
+		sname = "SetOp";
+		switch (((SetOp *) plan)->strategy) {
+		case SETOP_SORTED:
+			pname = "SetOp";
+			strategy = "Sorted";
+			break;
+		case SETOP_HASHED:
+			pname = "HashSetOp";
+			strategy = "Hashed";
 			break;
 		default:
-			pname = sname = "???";
+			pname = "SetOp ???";
+			strategy = "???";
 			break;
+		}
+		break;
+	case T_LockRows:
+		pname = sname = "LockRows";
+		break;
+	case T_Limit:
+		pname = sname = "Limit";
+		break;
+	case T_Hash:
+		pname = sname = "Hash";
+		break;
+	default:
+		pname = sname = "???";
+		break;
 	}
 
-	ExplainOpenGroup("Plan",
-					 relationship ? NULL : "Plan",
-					 true, es);
+	ExplainOpenGroup("Plan", relationship ? NULL : "Plan", true, es);
 
-	if (es->format == EXPLAIN_FORMAT_TEXT)
-	{
-		if (plan_name)
-		{
+	if (es->format == EXPLAIN_FORMAT_TEXT) {
+		if (plan_name) {
 			appendStringInfoSpaces(es->str, es->indent * 2);
 			appendStringInfo(es->str, "%s\n", plan_name);
 			es->indent++;
 		}
-		if (es->indent)
-		{
+		if (es->indent) {
 			appendStringInfoSpaces(es->str, es->indent * 2);
 			appendStringInfoString(es->str, "->  ");
 			es->indent += 2;
 		}
 		appendStringInfoString(es->str, pname);
 		es->indent++;
-	}
-	else
-	{
+	} else {
 		ExplainPropertyText("Node Type", sname, es);
 		if (strategy)
 			ExplainPropertyText("Strategy", strategy, es);
@@ -1038,141 +948,125 @@ ExplainNode(PlanState *planstate, List *ancestors,
 			ExplainPropertyText("Subplan Name", plan_name, es);
 	}
 
-	switch (nodeTag(plan))
-	{
-		case T_SeqScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_SubqueryScan:
-		case T_FunctionScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_ForeignScan:
-			ExplainScanTarget((Scan *) plan, es);
+	switch (nodeTag(plan)) {
+	case T_SeqScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_SubqueryScan:
+	case T_FunctionScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_ForeignScan:
+		ExplainScanTarget((Scan *) plan, es);
+		break;
+	case T_IndexScan: {
+		IndexScan *indexscan = (IndexScan *) plan;
+
+		ExplainIndexScanDetails(indexscan->indexid, indexscan->indexorderdir,
+				es);
+		ExplainScanTarget((Scan *) indexscan, es);
+	}
+		break;
+	case T_IndexOnlyScan: {
+		IndexOnlyScan *indexonlyscan = (IndexOnlyScan *) plan;
+
+		ExplainIndexScanDetails(indexonlyscan->indexid,
+				indexonlyscan->indexorderdir, es);
+		ExplainScanTarget((Scan *) indexonlyscan, es);
+	}
+		break;
+	case T_BitmapIndexScan: {
+		BitmapIndexScan *bitmapindexscan = (BitmapIndexScan *) plan;
+		const char *indexname = explain_get_index_name(
+				bitmapindexscan->indexid);
+
+		if (es->format == EXPLAIN_FORMAT_TEXT)
+			appendStringInfo(es->str, " on %s", indexname);
+		else
+			ExplainPropertyText("Index Name", indexname, es);
+	}
+		break;
+	case T_ModifyTable:
+		ExplainModifyTarget((ModifyTable *) plan, es);
+		break;
+	case T_NestLoop:
+	case T_MergeJoin:
+	case T_HashJoin: {
+		const char *jointype;
+
+		switch (((Join *) plan)->jointype) {
+		case JOIN_INNER:
+			jointype = "Inner";
 			break;
-		case T_IndexScan:
-			{
-				IndexScan  *indexscan = (IndexScan *) plan;
-
-				ExplainIndexScanDetails(indexscan->indexid,
-										indexscan->indexorderdir,
-										es);
-				ExplainScanTarget((Scan *) indexscan, es);
-			}
+		case JOIN_LEFT:
+			jointype = "Left";
 			break;
-		case T_IndexOnlyScan:
-			{
-				IndexOnlyScan *indexonlyscan = (IndexOnlyScan *) plan;
-
-				ExplainIndexScanDetails(indexonlyscan->indexid,
-										indexonlyscan->indexorderdir,
-										es);
-				ExplainScanTarget((Scan *) indexonlyscan, es);
-			}
+		case JOIN_FULL:
+			jointype = "Full";
 			break;
-		case T_BitmapIndexScan:
-			{
-				BitmapIndexScan *bitmapindexscan = (BitmapIndexScan *) plan;
-				const char *indexname =
-				explain_get_index_name(bitmapindexscan->indexid);
-
-				if (es->format == EXPLAIN_FORMAT_TEXT)
-					appendStringInfo(es->str, " on %s", indexname);
-				else
-					ExplainPropertyText("Index Name", indexname, es);
-			}
+		case JOIN_RIGHT:
+			jointype = "Right";
 			break;
-		case T_ModifyTable:
-			ExplainModifyTarget((ModifyTable *) plan, es);
+		case JOIN_SEMI:
+			jointype = "Semi";
 			break;
-		case T_NestLoop:
-		case T_MergeJoin:
-		case T_HashJoin:
-			{
-				const char *jointype;
-
-				switch (((Join *) plan)->jointype)
-				{
-					case JOIN_INNER:
-						jointype = "Inner";
-						break;
-					case JOIN_LEFT:
-						jointype = "Left";
-						break;
-					case JOIN_FULL:
-						jointype = "Full";
-						break;
-					case JOIN_RIGHT:
-						jointype = "Right";
-						break;
-					case JOIN_SEMI:
-						jointype = "Semi";
-						break;
-					case JOIN_ANTI:
-						jointype = "Anti";
-						break;
-					default:
-						jointype = "???";
-						break;
-				}
-				if (es->format == EXPLAIN_FORMAT_TEXT)
-				{
-					/*
-					 * For historical reasons, the join type is interpolated
-					 * into the node type name...
-					 */
-					if (((Join *) plan)->jointype != JOIN_INNER)
-						appendStringInfo(es->str, " %s Join", jointype);
-					else if (!IsA(plan, NestLoop))
-						appendStringInfoString(es->str, " Join");
-				}
-				else
-					ExplainPropertyText("Join Type", jointype, es);
-			}
-			break;
-		case T_SetOp:
-			{
-				const char *setopcmd;
-
-				switch (((SetOp *) plan)->cmd)
-				{
-					case SETOPCMD_INTERSECT:
-						setopcmd = "Intersect";
-						break;
-					case SETOPCMD_INTERSECT_ALL:
-						setopcmd = "Intersect All";
-						break;
-					case SETOPCMD_EXCEPT:
-						setopcmd = "Except";
-						break;
-					case SETOPCMD_EXCEPT_ALL:
-						setopcmd = "Except All";
-						break;
-					default:
-						setopcmd = "???";
-						break;
-				}
-				if (es->format == EXPLAIN_FORMAT_TEXT)
-					appendStringInfo(es->str, " %s", setopcmd);
-				else
-					ExplainPropertyText("Command", setopcmd, es);
-			}
+		case JOIN_ANTI:
+			jointype = "Anti";
 			break;
 		default:
+			jointype = "???";
 			break;
+		}
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
+			/*
+			 * For historical reasons, the join type is interpolated
+			 * into the node type name...
+			 */
+			if (((Join *) plan)->jointype != JOIN_INNER)
+				appendStringInfo(es->str, " %s Join", jointype);
+			else if (!IsA(plan, NestLoop))
+				appendStringInfoString(es->str, " Join");
+		} else
+			ExplainPropertyText("Join Type", jointype, es);
 	}
+		break;
+	case T_SetOp: {
+		const char *setopcmd;
 
-	if (es->costs)
-	{
-		if (es->format == EXPLAIN_FORMAT_TEXT)
-		{
-			appendStringInfo(es->str, "  (cost=%.2f..%.2f rows=%.0f width=%d)",
-							 plan->startup_cost, plan->total_cost,
-							 plan->plan_rows, plan->plan_width);
+		switch (((SetOp *) plan)->cmd) {
+		case SETOPCMD_INTERSECT:
+			setopcmd = "Intersect";
+			break;
+		case SETOPCMD_INTERSECT_ALL:
+			setopcmd = "Intersect All";
+			break;
+		case SETOPCMD_EXCEPT:
+			setopcmd = "Except";
+			break;
+		case SETOPCMD_EXCEPT_ALL:
+			setopcmd = "Except All";
+			break;
+		default:
+			setopcmd = "???";
+			break;
 		}
+		if (es->format == EXPLAIN_FORMAT_TEXT)
+			appendStringInfo(es->str, " %s", setopcmd);
 		else
-		{
+			ExplainPropertyText("Command", setopcmd, es);
+	}
+		break;
+	default:
+		break;
+	}
+
+	if (es->costs) {
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
+			appendStringInfo(es->str, "  (cost=%.2f..%.2f rows=%.0f width=%d)",
+					plan->startup_cost, plan->total_cost, plan->plan_rows,
+					plan->plan_width);
+		} else {
 			ExplainPropertyFloat("Startup Cost", plan->startup_cost, 2, es);
 			ExplainPropertyFloat("Total Cost", plan->total_cost, 2, es);
 			ExplainPropertyFloat("Plan Rows", plan->plan_rows, 0, es);
@@ -1187,47 +1081,36 @@ ExplainNode(PlanState *planstate, List *ancestors,
 	if (planstate->instrument)
 		InstrEndLoop(planstate->instrument);
 
-	if (planstate->instrument && planstate->instrument->nloops > 0)
-	{
-		double		nloops = planstate->instrument->nloops;
-		double		startup_sec = 1000.0 * planstate->instrument->startup / nloops;
-		double		total_sec = 1000.0 * planstate->instrument->total / nloops;
-		double		rows = planstate->instrument->ntuples / nloops;
+	if (planstate->instrument && planstate->instrument->nloops > 0) {
+		double nloops = planstate->instrument->nloops;
+		double startup_sec = 1000.0 * planstate->instrument->startup / nloops;
+		double total_sec = 1000.0 * planstate->instrument->total / nloops;
+		double rows = planstate->instrument->ntuples / nloops;
 
-		if (es->format == EXPLAIN_FORMAT_TEXT)
-		{
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
 			if (planstate->instrument->need_timer)
 				appendStringInfo(es->str,
-							" (actual time=%.3f..%.3f rows=%.0f loops=%.0f)",
-								 startup_sec, total_sec, rows, nloops);
+						" (actual time=%.3f..%.3f rows=%.0f loops=%.0f)",
+						startup_sec, total_sec, rows, nloops);
 			else
-				appendStringInfo(es->str,
-								 " (actual rows=%.0f loops=%.0f)",
-								 rows, nloops);
-		}
-		else
-		{
-			if (planstate->instrument->need_timer)
-			{
+				appendStringInfo(es->str, " (actual rows=%.0f loops=%.0f)",
+						rows, nloops);
+		} else {
+			if (planstate->instrument->need_timer) {
 				ExplainPropertyFloat("Actual Startup Time", startup_sec, 3, es);
 				ExplainPropertyFloat("Actual Total Time", total_sec, 3, es);
 			}
 			ExplainPropertyFloat("Actual Rows", rows, 0, es);
 			ExplainPropertyFloat("Actual Loops", nloops, 0, es);
 		}
-	}
-	else if (es->analyze)
-	{
+	} else if (es->analyze) {
 
 		if (es->format == EXPLAIN_FORMAT_TEXT)
 			appendStringInfoString(es->str, " (never executed)");
-		else if (planstate->instrument->need_timer)
-		{
+		else if (planstate->instrument->need_timer) {
 			ExplainPropertyFloat("Actual Startup Time", 0.0, 3, es);
 			ExplainPropertyFloat("Actual Total Time", 0.0, 3, es);
-		}
-		else
-		{
+		} else {
 			ExplainPropertyFloat("Actual Rows", 0.0, 0, es);
 			ExplainPropertyFloat("Actual Loops", 0.0, 0, es);
 		}
@@ -1243,306 +1126,353 @@ ExplainNode(PlanState *planstate, List *ancestors,
 		show_plan_tlist(planstate, ancestors, es);
 
 	/* quals, sort keys, etc */
-	switch (nodeTag(plan))
-	{
-		case T_IndexScan:
-			show_scan_qual(((IndexScan *) plan)->indexqualorig,
-						   "Index Cond", planstate, ancestors, es);
-			if (((IndexScan *) plan)->indexqualorig)
-				show_instrumentation_count("Rows Removed by Index Recheck", 2,
-										   planstate, es);
-			show_scan_qual(((IndexScan *) plan)->indexorderbyorig,
-						   "Order By", planstate, ancestors, es);
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_IndexOnlyScan:
-			show_scan_qual(((IndexOnlyScan *) plan)->indexqual,
-						   "Index Cond", planstate, ancestors, es);
-			if (((IndexOnlyScan *) plan)->indexqual)
-				show_instrumentation_count("Rows Removed by Index Recheck", 2,
-										   planstate, es);
-			show_scan_qual(((IndexOnlyScan *) plan)->indexorderby,
-						   "Order By", planstate, ancestors, es);
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			if (es->analyze)
-				ExplainPropertyLong("Heap Fetches",
-				   ((IndexOnlyScanState *) planstate)->ioss_HeapFetches, es);
-			break;
-		case T_BitmapIndexScan:
-			show_scan_qual(((BitmapIndexScan *) plan)->indexqualorig,
-						   "Index Cond", planstate, ancestors, es);
-			break;
-		case T_BitmapHeapScan:
-			show_scan_qual(((BitmapHeapScan *) plan)->bitmapqualorig,
-						   "Recheck Cond", planstate, ancestors, es);
-			if (((BitmapHeapScan *) plan)->bitmapqualorig)
-				show_instrumentation_count("Rows Removed by Index Recheck", 2,
-										   planstate, es);
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			if (es->analyze)
-				show_tidbitmap_info((BitmapHeapScanState *) planstate, es);
-			break;
-		case T_SeqScan:
-		case T_ValuesScan:
-		case T_CteScan:
-		case T_WorkTableScan:
-		case T_SubqueryScan:
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_FunctionScan:
-			if (es->verbose)
-			{
-				List	   *fexprs = NIL;
-				ListCell   *lc;
+	switch (nodeTag(plan)) {
+	case T_IndexScan:
+		show_scan_qual(((IndexScan *) plan)->indexqualorig, "Index Cond",
+				planstate, ancestors, es);
+
+		if (((IndexScan *) plan)->indexqualorig)
+			show_instrumentation_count("Rows Removed by Index Recheck", 2,
+					planstate, es);
+		show_scan_qual(((IndexScan *) plan)->indexorderbyorig, "Order By",
+				planstate, ancestors, es);
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
+				show_scan_parsed_qual(((IndexScan *) plan)->indexqualorig,
+						"PIndex Cond", es);
+			}
+		}
 
-				foreach(lc, ((FunctionScan *) plan)->functions)
-				{
-					RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);
+		break;
+	case T_IndexOnlyScan:
+		show_scan_qual(((IndexOnlyScan *) plan)->indexqual, "Index Cond",
+				planstate, ancestors, es);
+		if (((IndexOnlyScan *) plan)->indexqual)
+			show_instrumentation_count("Rows Removed by Index Recheck", 2,
+					planstate, es);
+		show_scan_qual(((IndexOnlyScan *) plan)->indexorderby, "Order By",
+				planstate, ancestors, es);
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
+				show_scan_parsed_qual(((IndexScan *) plan)->indexqualorig,
+									"PIndex Cond", es);
+			}
+		}
 
-					fexprs = lappend(fexprs, rtfunc->funcexpr);
-				}
-				/* We rely on show_expression to insert commas as needed */
-				show_expression((Node *) fexprs,
-								"Function Call", planstate, ancestors,
-								es->verbose, es);
+		if (es->analyze)
+			ExplainPropertyLong("Heap Fetches",
+					((IndexOnlyScanState *) planstate)->ioss_HeapFetches, es);
+
+		break;
+	case T_BitmapIndexScan:
+		show_scan_qual(((BitmapIndexScan *) plan)->indexqualorig, "Index Cond",
+				planstate, ancestors, es);
+		if (enable_explain_memo) {
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(((BitmapIndexScan *) plan)->indexqualorig,
+						"PIndex Cond", es);
 			}
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_TidScan:
-			{
-				/*
-				 * The tidquals list has OR semantics, so be sure to show it
-				 * as an OR condition.
-				 */
-				List	   *tidquals = ((TidScan *) plan)->tidquals;
-
-				if (list_length(tidquals) > 1)
-					tidquals = list_make1(make_orclause(tidquals));
-				show_scan_qual(tidquals, "TID Cond", planstate, ancestors, es);
-				show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-				if (plan->qual)
-					show_instrumentation_count("Rows Removed by Filter", 1,
-											   planstate, es);
+		}
+		break;
+	case T_BitmapHeapScan:
+		show_scan_qual(((BitmapHeapScan *) plan)->bitmapqualorig,
+				"Recheck Cond", planstate, ancestors, es);
+		if (((BitmapHeapScan *) plan)->bitmapqualorig)
+			show_instrumentation_count("Rows Removed by Index Recheck", 2,
+					planstate, es);
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
 			}
-			break;
-		case T_ForeignScan:
-			show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			show_foreignscan_info((ForeignScanState *) planstate, es);
-			break;
-		case T_NestLoop:
-			show_upper_qual(((NestLoop *) plan)->join.joinqual,
-							"Join Filter", planstate, ancestors, es);
-			if (((NestLoop *) plan)->join.joinqual)
-				show_instrumentation_count("Rows Removed by Join Filter", 1,
-										   planstate, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 2,
-										   planstate, es);
-			break;
-		case T_MergeJoin:
-			show_upper_qual(((MergeJoin *) plan)->mergeclauses,
-							"Merge Cond", planstate, ancestors, es);
-			show_upper_qual(((MergeJoin *) plan)->join.joinqual,
-							"Join Filter", planstate, ancestors, es);
-			if (((MergeJoin *) plan)->join.joinqual)
-				show_instrumentation_count("Rows Removed by Join Filter", 1,
-										   planstate, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 2,
-										   planstate, es);
-			break;
-		case T_HashJoin:
-			show_upper_qual(((HashJoin *) plan)->hashclauses,
-							"Hash Cond", planstate, ancestors, es);
-			show_upper_qual(((HashJoin *) plan)->join.joinqual,
-							"Join Filter", planstate, ancestors, es);
-			if (((HashJoin *) plan)->join.joinqual)
-				show_instrumentation_count("Rows Removed by Join Filter", 1,
-										   planstate, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 2,
-										   planstate, es);
-			break;
-		case T_Agg:
-			show_agg_keys((AggState *) planstate, ancestors, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_Group:
-			show_group_keys((GroupState *) planstate, ancestors, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_Sort:
-			show_sort_keys((SortState *) planstate, ancestors, es);
-			show_sort_info((SortState *) planstate, es);
-			break;
-		case T_MergeAppend:
-			show_merge_append_keys((MergeAppendState *) planstate,
-								   ancestors, es);
-			break;
-		case T_Result:
-			show_upper_qual((List *) ((Result *) plan)->resconstantqual,
-							"One-Time Filter", planstate, ancestors, es);
-			show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
-			if (plan->qual)
-				show_instrumentation_count("Rows Removed by Filter", 1,
-										   planstate, es);
-			break;
-		case T_ModifyTable:
-			show_modifytable_info((ModifyTableState *) planstate, es);
-			break;
-		case T_Hash:
-			show_hash_info((HashState *) planstate, es);
-			break;
-		default:
-			break;
+
+		}
+
+		if (es->analyze)
+			show_tidbitmap_info((BitmapHeapScanState *) planstate, es);
+		break;
+	case T_SeqScan:
+	case T_ValuesScan:
+	case T_CteScan:
+	case T_WorkTableScan:
+	case T_SubqueryScan:
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
+			}
+
+		}
+		if (enable_explain_memo) {
+		}
+		break;
+	case T_FunctionScan:
+		if (es->verbose) {
+			List *fexprs = NIL;
+			ListCell *lc;
+
+			foreach(lc, ((FunctionScan *) plan)->functions) {
+				RangeTblFunction *rtfunc = (RangeTblFunction *) lfirst(lc);
+
+				fexprs = lappend(fexprs, rtfunc->funcexpr);
+			}
+			/* We rely on show_expression to insert commas as needed */
+			show_expression((Node *) fexprs, "Function Call", planstate,
+					ancestors, es->verbose, es);
+		}
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
+			}
+		}
+		break;
+	case T_TidScan: {
+		/*
+		 * The tidquals list has OR semantics, so be sure to show it
+		 * as an OR condition.
+		 */
+		List *tidquals = ((TidScan *) plan)->tidquals;
+
+		if (list_length(tidquals) > 1)
+			tidquals = list_make1(make_orclause(tidquals));
+		show_scan_qual(tidquals, "TID Cond", planstate, ancestors, es);
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual) {
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+			if (enable_explain_memo) {
+				show_scan_parsed_qual(plan->qual, "PFilter", es);
+				//show_scan_parsed_qual(plan->qual, "TID Cond", es);
+			}
+		}
+	}
+
+		break;
+	case T_ForeignScan:
+		show_scan_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+		show_foreignscan_info((ForeignScanState *) planstate, es);
+		break;
+	case T_NestLoop:
+		show_upper_qual(((NestLoop *) plan)->join.joinqual, "Join Filter",
+				planstate, ancestors, es);
+		if (((NestLoop *) plan)->join.joinqual)
+			show_instrumentation_count("Rows Removed by Join Filter", 1,
+					planstate, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 2, planstate,
+					es);
+		if (enable_explain_memo) {
+			show_scan_parsed_qual(((NestLoop *) plan)->join.joinqual, "PJoin Filter", es);
+
+		}
+		break;
+	case T_MergeJoin:
+		show_upper_qual(((MergeJoin *) plan)->mergeclauses, "Merge Cond",
+				planstate, ancestors, es);
+		show_upper_qual(((MergeJoin *) plan)->join.joinqual, "Join Filter",
+				planstate, ancestors, es);
+		if (((MergeJoin *) plan)->join.joinqual)
+			show_instrumentation_count("Rows Removed by Join Filter", 1,
+					planstate, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 2, planstate,
+					es);
+		if (enable_explain_memo) {
+			show_scan_parsed_qual(((MergeJoin *) plan)->mergeclauses, "PMerge Cond", es);
+			show_scan_parsed_qual(((MergeJoin *) plan)->join.joinqual, "PJoin Filter", es);
+		}
+		break;
+	case T_HashJoin:
+		show_upper_qual(((HashJoin *) plan)->hashclauses, "Hash Cond",
+				planstate, ancestors, es);
+		show_upper_qual(((HashJoin *) plan)->join.joinqual, "Join Filter",
+				planstate, ancestors, es);
+		if (((HashJoin *) plan)->join.joinqual)
+			show_instrumentation_count("Rows Removed by Join Filter", 1,
+					planstate, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 2, planstate,
+					es);
+		if (enable_explain_memo) {
+			show_scan_parsed_qual(((HashJoin *) plan)->hashclauses, "PHash Cond", es);
+						show_scan_parsed_qual(((HashJoin *) plan)->join.joinqual, "PHash Filter", es);
+		}
+		break;
+	case T_Agg:
+		show_agg_keys((AggState *) planstate, ancestors, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+		break;
+	case T_Group:
+		show_group_keys((GroupState *) planstate, ancestors, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+		break;
+	case T_Sort:
+		show_sort_keys((SortState *) planstate, ancestors, es);
+		show_sort_info((SortState *) planstate, es);
+		break;
+	case T_MergeAppend:
+		show_merge_append_keys((MergeAppendState *) planstate, ancestors, es);
+		break;
+	case T_Result:
+		show_upper_qual((List *) ((Result *) plan)->resconstantqual,
+				"One-Time Filter", planstate, ancestors, es);
+		show_upper_qual(plan->qual, "Filter", planstate, ancestors, es);
+		if (plan->qual)
+			show_instrumentation_count("Rows Removed by Filter", 1, planstate,
+					es);
+		break;
+	case T_ModifyTable:
+		show_modifytable_info((ModifyTableState *) planstate, es);
+		break;
+	case T_Hash:
+		show_hash_info((HashState *) planstate, es);
+		break;
+	default:
+		break;
 	}
 
 	/* Show buffer usage */
-	if (es->buffers)
-	{
+	if (es->buffers) {
 		const BufferUsage *usage = &planstate->instrument->bufusage;
 
-		if (es->format == EXPLAIN_FORMAT_TEXT)
-		{
-			bool		has_shared = (usage->shared_blks_hit > 0 ||
-									  usage->shared_blks_read > 0 ||
-									  usage->shared_blks_dirtied > 0 ||
-									  usage->shared_blks_written > 0);
-			bool		has_local = (usage->local_blks_hit > 0 ||
-									 usage->local_blks_read > 0 ||
-									 usage->local_blks_dirtied > 0 ||
-									 usage->local_blks_written > 0);
-			bool		has_temp = (usage->temp_blks_read > 0 ||
-									usage->temp_blks_written > 0);
-			bool		has_timing = (!INSTR_TIME_IS_ZERO(usage->blk_read_time) ||
-								 !INSTR_TIME_IS_ZERO(usage->blk_write_time));
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
+			bool has_shared = (usage->shared_blks_hit > 0
+					|| usage->shared_blks_read > 0
+					|| usage->shared_blks_dirtied > 0
+					|| usage->shared_blks_written > 0);
+			bool has_local = (usage->local_blks_hit > 0
+					|| usage->local_blks_read > 0
+					|| usage->local_blks_dirtied > 0
+					|| usage->local_blks_written > 0);
+			bool has_temp = (usage->temp_blks_read > 0
+					|| usage->temp_blks_written > 0);
+			bool has_timing = (!INSTR_TIME_IS_ZERO(usage->blk_read_time)
+					|| !INSTR_TIME_IS_ZERO(usage->blk_write_time));
 
 			/* Show only positive counter values. */
-			if (has_shared || has_local || has_temp)
-			{
+			if (has_shared || has_local || has_temp) {
 				appendStringInfoSpaces(es->str, es->indent * 2);
 				appendStringInfoString(es->str, "Buffers:");
 
-				if (has_shared)
-				{
+				if (has_shared) {
 					appendStringInfoString(es->str, " shared");
 					if (usage->shared_blks_hit > 0)
 						appendStringInfo(es->str, " hit=%ld",
-										 usage->shared_blks_hit);
+								usage->shared_blks_hit);
 					if (usage->shared_blks_read > 0)
 						appendStringInfo(es->str, " read=%ld",
-										 usage->shared_blks_read);
+								usage->shared_blks_read);
 					if (usage->shared_blks_dirtied > 0)
 						appendStringInfo(es->str, " dirtied=%ld",
-										 usage->shared_blks_dirtied);
+								usage->shared_blks_dirtied);
 					if (usage->shared_blks_written > 0)
 						appendStringInfo(es->str, " written=%ld",
-										 usage->shared_blks_written);
+								usage->shared_blks_written);
 					if (has_local || has_temp)
 						appendStringInfoChar(es->str, ',');
 				}
-				if (has_local)
-				{
+				if (has_local) {
 					appendStringInfoString(es->str, " local");
 					if (usage->local_blks_hit > 0)
 						appendStringInfo(es->str, " hit=%ld",
-										 usage->local_blks_hit);
+								usage->local_blks_hit);
 					if (usage->local_blks_read > 0)
 						appendStringInfo(es->str, " read=%ld",
-										 usage->local_blks_read);
+								usage->local_blks_read);
 					if (usage->local_blks_dirtied > 0)
 						appendStringInfo(es->str, " dirtied=%ld",
-										 usage->local_blks_dirtied);
+								usage->local_blks_dirtied);
 					if (usage->local_blks_written > 0)
 						appendStringInfo(es->str, " written=%ld",
-										 usage->local_blks_written);
+								usage->local_blks_written);
 					if (has_temp)
 						appendStringInfoChar(es->str, ',');
 				}
-				if (has_temp)
-				{
+				if (has_temp) {
 					appendStringInfoString(es->str, " temp");
 					if (usage->temp_blks_read > 0)
 						appendStringInfo(es->str, " read=%ld",
-										 usage->temp_blks_read);
+								usage->temp_blks_read);
 					if (usage->temp_blks_written > 0)
 						appendStringInfo(es->str, " written=%ld",
-										 usage->temp_blks_written);
+								usage->temp_blks_written);
 				}
 				appendStringInfoChar(es->str, '\n');
 			}
 
 			/* As above, show only positive counter values. */
-			if (has_timing)
-			{
+			if (has_timing) {
 				appendStringInfoSpaces(es->str, es->indent * 2);
 				appendStringInfoString(es->str, "I/O Timings:");
 				if (!INSTR_TIME_IS_ZERO(usage->blk_read_time))
 					appendStringInfo(es->str, " read=%0.3f",
-							  INSTR_TIME_GET_MILLISEC(usage->blk_read_time));
+							INSTR_TIME_GET_MILLISEC(usage->blk_read_time));
 				if (!INSTR_TIME_IS_ZERO(usage->blk_write_time))
 					appendStringInfo(es->str, " write=%0.3f",
-							 INSTR_TIME_GET_MILLISEC(usage->blk_write_time));
+							INSTR_TIME_GET_MILLISEC(usage->blk_write_time));
 				appendStringInfoChar(es->str, '\n');
 			}
-		}
-		else
-		{
-			ExplainPropertyLong("Shared Hit Blocks", usage->shared_blks_hit, es);
-			ExplainPropertyLong("Shared Read Blocks", usage->shared_blks_read, es);
-			ExplainPropertyLong("Shared Dirtied Blocks", usage->shared_blks_dirtied, es);
-			ExplainPropertyLong("Shared Written Blocks", usage->shared_blks_written, es);
+		} else {
+			ExplainPropertyLong("Shared Hit Blocks", usage->shared_blks_hit,
+					es);
+			ExplainPropertyLong("Shared Read Blocks", usage->shared_blks_read,
+					es);
+			ExplainPropertyLong("Shared Dirtied Blocks",
+					usage->shared_blks_dirtied, es);
+			ExplainPropertyLong("Shared Written Blocks",
+					usage->shared_blks_written, es);
 			ExplainPropertyLong("Local Hit Blocks", usage->local_blks_hit, es);
-			ExplainPropertyLong("Local Read Blocks", usage->local_blks_read, es);
-			ExplainPropertyLong("Local Dirtied Blocks", usage->local_blks_dirtied, es);
-			ExplainPropertyLong("Local Written Blocks", usage->local_blks_written, es);
+			ExplainPropertyLong("Local Read Blocks", usage->local_blks_read,
+					es);
+			ExplainPropertyLong("Local Dirtied Blocks",
+					usage->local_blks_dirtied, es);
+			ExplainPropertyLong("Local Written Blocks",
+					usage->local_blks_written, es);
 			ExplainPropertyLong("Temp Read Blocks", usage->temp_blks_read, es);
-			ExplainPropertyLong("Temp Written Blocks", usage->temp_blks_written, es);
-			ExplainPropertyFloat("I/O Read Time", INSTR_TIME_GET_MILLISEC(usage->blk_read_time), 3, es);
-			ExplainPropertyFloat("I/O Write Time", INSTR_TIME_GET_MILLISEC(usage->blk_write_time), 3, es);
+			ExplainPropertyLong("Temp Written Blocks", usage->temp_blks_written,
+					es);
+			ExplainPropertyFloat("I/O Read Time",
+					INSTR_TIME_GET_MILLISEC(usage->blk_read_time), 3, es);
+			ExplainPropertyFloat("I/O Write Time",
+					INSTR_TIME_GET_MILLISEC(usage->blk_write_time), 3, es);
 		}
 	}
 
 	/* Get ready to display the child plans */
-	haschildren = planstate->initPlan ||
-		outerPlanState(planstate) ||
-		innerPlanState(planstate) ||
-		IsA(plan, ModifyTable) ||
-		IsA(plan, Append) ||
-		IsA(plan, MergeAppend) ||
-		IsA(plan, BitmapAnd) ||
-		IsA(plan, BitmapOr) ||
-		IsA(plan, SubqueryScan) ||
-		planstate->subPlan;
-	if (haschildren)
-	{
+	haschildren = planstate->initPlan || outerPlanState(planstate)
+			|| innerPlanState(planstate) || IsA(plan, ModifyTable)
+			|| IsA(plan, Append) || IsA(plan, MergeAppend)
+			|| IsA(plan, BitmapAnd) || IsA(plan, BitmapOr)
+			|| IsA(plan, SubqueryScan) || planstate->subPlan;
+	if (haschildren) {
 		ExplainOpenGroup("Plans", "Plans", false, es);
 		/* Pass current PlanState as head of ancestors list for children */
 		ancestors = lcons(planstate, ancestors);
@@ -1554,48 +1484,40 @@ ExplainNode(PlanState *planstate, List *ancestors,
 
 	/* lefttree */
 	if (outerPlanState(planstate))
-		ExplainNode(outerPlanState(planstate), ancestors,
-					"Outer", NULL, es);
+		ExplainNode(outerPlanState(planstate), ancestors, "Outer", NULL, es);
 
 	/* righttree */
 	if (innerPlanState(planstate))
-		ExplainNode(innerPlanState(planstate), ancestors,
-					"Inner", NULL, es);
+		ExplainNode(innerPlanState(planstate), ancestors, "Inner", NULL, es);
 
 	/* special child plans */
-	switch (nodeTag(plan))
-	{
-		case T_ModifyTable:
-			ExplainMemberNodes(((ModifyTable *) plan)->plans,
-							   ((ModifyTableState *) planstate)->mt_plans,
-							   ancestors, es);
-			break;
-		case T_Append:
-			ExplainMemberNodes(((Append *) plan)->appendplans,
-							   ((AppendState *) planstate)->appendplans,
-							   ancestors, es);
-			break;
-		case T_MergeAppend:
-			ExplainMemberNodes(((MergeAppend *) plan)->mergeplans,
-							   ((MergeAppendState *) planstate)->mergeplans,
-							   ancestors, es);
-			break;
-		case T_BitmapAnd:
-			ExplainMemberNodes(((BitmapAnd *) plan)->bitmapplans,
-							   ((BitmapAndState *) planstate)->bitmapplans,
-							   ancestors, es);
-			break;
-		case T_BitmapOr:
-			ExplainMemberNodes(((BitmapOr *) plan)->bitmapplans,
-							   ((BitmapOrState *) planstate)->bitmapplans,
-							   ancestors, es);
-			break;
-		case T_SubqueryScan:
-			ExplainNode(((SubqueryScanState *) planstate)->subplan, ancestors,
-						"Subquery", NULL, es);
-			break;
-		default:
-			break;
+	switch (nodeTag(plan)) {
+	case T_ModifyTable:
+		ExplainMemberNodes(((ModifyTable *) plan)->plans,
+				((ModifyTableState *) planstate)->mt_plans, ancestors, es);
+		break;
+	case T_Append:
+		ExplainMemberNodes(((Append *) plan)->appendplans,
+				((AppendState *) planstate)->appendplans, ancestors, es);
+		break;
+	case T_MergeAppend:
+		ExplainMemberNodes(((MergeAppend *) plan)->mergeplans,
+				((MergeAppendState *) planstate)->mergeplans, ancestors, es);
+		break;
+	case T_BitmapAnd:
+		ExplainMemberNodes(((BitmapAnd *) plan)->bitmapplans,
+				((BitmapAndState *) planstate)->bitmapplans, ancestors, es);
+		break;
+	case T_BitmapOr:
+		ExplainMemberNodes(((BitmapOr *) plan)->bitmapplans,
+				((BitmapOrState *) planstate)->bitmapplans, ancestors, es);
+		break;
+	case T_SubqueryScan:
+		ExplainNode(((SubqueryScanState *) planstate)->subplan, ancestors,
+				"Subquery", NULL, es);
+		break;
+	default:
+		break;
 	}
 
 	/* subPlan-s */
@@ -1603,8 +1525,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 		ExplainSubPlans(planstate->subPlan, ancestors, "SubPlan", es);
 
 	/* end of child plans */
-	if (haschildren)
-	{
+	if (haschildren) {
 		ancestors = list_delete_first(ancestors);
 		ExplainCloseGroup("Plans", "Plans", false, es);
 	}
@@ -1613,22 +1534,19 @@ ExplainNode(PlanState *planstate, List *ancestors,
 	if (es->format == EXPLAIN_FORMAT_TEXT)
 		es->indent = save_indent;
 
-	ExplainCloseGroup("Plan",
-					  relationship ? NULL : "Plan",
-					  true, es);
+	ExplainCloseGroup("Plan", relationship ? NULL : "Plan", true, es);
 }
 
 /*
  * Show the targetlist of a plan node
  */
-static void
-show_plan_tlist(PlanState *planstate, List *ancestors, ExplainState *es)
-{
-	Plan	   *plan = planstate->plan;
-	List	   *context;
-	List	   *result = NIL;
-	bool		useprefix;
-	ListCell   *lc;
+static void show_plan_tlist(PlanState *planstate, List *ancestors,
+		ExplainState *es) {
+	Plan *plan = planstate->plan;
+	List *context;
+	List *result = NIL;
+	bool useprefix;
+	ListCell *lc;
 
 	/* No work if empty tlist (this occurs eg in bitmap indexscans) */
 	if (plan->targetlist == NIL)
@@ -1643,20 +1561,16 @@ show_plan_tlist(PlanState *planstate, List *ancestors, ExplainState *es)
 		return;
 
 	/* Set up deparsing context */
-	context = deparse_context_for_planstate((Node *) planstate,
-											ancestors,
-											es->rtable,
-											es->rtable_names);
+	context = deparse_context_for_planstate((Node *) planstate, ancestors,
+			es->rtable, es->rtable_names);
 	useprefix = list_length(es->rtable) > 1;
 
-	/* Deparse each result column (we now include resjunk ones) */
-	foreach(lc, plan->targetlist)
-	{
+	/* Deparse each result column (we now include resjunk ones) */foreach(lc, plan->targetlist) {
 		TargetEntry *tle = (TargetEntry *) lfirst(lc);
 
 		result = lappend(result,
-						 deparse_expression((Node *) tle->expr, context,
-											useprefix, false));
+				deparse_expression((Node *) tle->expr, context, useprefix,
+						false));
 	}
 
 	/* Print results */
@@ -1666,19 +1580,14 @@ show_plan_tlist(PlanState *planstate, List *ancestors, ExplainState *es)
 /*
  * Show a generic expression
  */
-static void
-show_expression(Node *node, const char *qlabel,
-				PlanState *planstate, List *ancestors,
-				bool useprefix, ExplainState *es)
-{
-	List	   *context;
-	char	   *exprstr;
+static void show_expression(Node *node, const char *qlabel,
+		PlanState *planstate, List *ancestors, bool useprefix, ExplainState *es) {
+	List *context;
+	char *exprstr;
 
 	/* Set up deparsing context */
-	context = deparse_context_for_planstate((Node *) planstate,
-											ancestors,
-											es->rtable,
-											es->rtable_names);
+	context = deparse_context_for_planstate((Node *) planstate, ancestors,
+			es->rtable, es->rtable_names);
 
 	/* Deparse the expression */
 	exprstr = deparse_expression(node, context, useprefix, false);
@@ -1690,12 +1599,9 @@ show_expression(Node *node, const char *qlabel,
 /*
  * Show a qualifier expression (which is a List with implicit AND semantics)
  */
-static void
-show_qual(List *qual, const char *qlabel,
-		  PlanState *planstate, List *ancestors,
-		  bool useprefix, ExplainState *es)
-{
-	Node	   *node;
+static void show_qual(List *qual, const char *qlabel, PlanState *planstate,
+		List *ancestors, bool useprefix, ExplainState *es) {
+	Node *node;
 
 	/* No work if empty qual */
 	if (qual == NIL)
@@ -1711,26 +1617,20 @@ show_qual(List *qual, const char *qlabel,
 /*
  * Show a qualifier expression for a scan plan node
  */
-static void
-show_scan_qual(List *qual, const char *qlabel,
-			   PlanState *planstate, List *ancestors,
-			   ExplainState *es)
-{
-	bool		useprefix;
-
-	useprefix = (IsA(planstate->plan, SubqueryScan) ||es->verbose);
+static void show_scan_qual(List *qual, const char *qlabel, PlanState *planstate,
+		List *ancestors, ExplainState *es) {
+	bool useprefix;
+
+	useprefix = (IsA(planstate->plan, SubqueryScan) || es->verbose);
 	show_qual(qual, qlabel, planstate, ancestors, useprefix, es);
 }
 
 /*
  * Show a qualifier expression for an upper-level plan node
  */
-static void
-show_upper_qual(List *qual, const char *qlabel,
-				PlanState *planstate, List *ancestors,
-				ExplainState *es)
-{
-	bool		useprefix;
+static void show_upper_qual(List *qual, const char *qlabel,
+		PlanState *planstate, List *ancestors, ExplainState *es) {
+	bool useprefix;
 
 	useprefix = (list_length(es->rtable) > 1 || es->verbose);
 	show_qual(qual, qlabel, planstate, ancestors, useprefix, es);
@@ -1739,46 +1639,36 @@ show_upper_qual(List *qual, const char *qlabel,
 /*
  * Show the sort keys for a Sort node.
  */
-static void
-show_sort_keys(SortState *sortstate, List *ancestors, ExplainState *es)
-{
-	Sort	   *plan = (Sort *) sortstate->ss.ps.plan;
-
-	show_sort_group_keys((PlanState *) sortstate, "Sort Key",
-						 plan->numCols, plan->sortColIdx,
-						 ancestors, es);
+static void show_sort_keys(SortState *sortstate, List *ancestors,
+		ExplainState *es) {
+	Sort *plan = (Sort *) sortstate->ss.ps.plan;
+
+	show_sort_group_keys((PlanState *) sortstate, "Sort Key", plan->numCols,
+			plan->sortColIdx, ancestors, es);
 }
 
 /*
  * Likewise, for a MergeAppend node.
  */
-static void
-show_merge_append_keys(MergeAppendState *mstate, List *ancestors,
-					   ExplainState *es)
-{
+static void show_merge_append_keys(MergeAppendState *mstate, List *ancestors,
+		ExplainState *es) {
 	MergeAppend *plan = (MergeAppend *) mstate->ps.plan;
 
-	show_sort_group_keys((PlanState *) mstate, "Sort Key",
-						 plan->numCols, plan->sortColIdx,
-						 ancestors, es);
+	show_sort_group_keys((PlanState *) mstate, "Sort Key", plan->numCols,
+			plan->sortColIdx, ancestors, es);
 }
 
 /*
  * Show the grouping keys for an Agg node.
  */
-static void
-show_agg_keys(AggState *astate, List *ancestors,
-			  ExplainState *es)
-{
-	Agg		   *plan = (Agg *) astate->ss.ps.plan;
-
-	if (plan->numCols > 0)
-	{
+static void show_agg_keys(AggState *astate, List *ancestors, ExplainState *es) {
+	Agg *plan = (Agg *) astate->ss.ps.plan;
+
+	if (plan->numCols > 0) {
 		/* The key columns refer to the tlist of the child plan */
 		ancestors = lcons(astate, ancestors);
-		show_sort_group_keys(outerPlanState(astate), "Group Key",
-							 plan->numCols, plan->grpColIdx,
-							 ancestors, es);
+		show_sort_group_keys(outerPlanState(astate), "Group Key", plan->numCols,
+				plan->grpColIdx, ancestors, es);
 		ancestors = list_delete_first(ancestors);
 	}
 }
@@ -1786,17 +1676,14 @@ show_agg_keys(AggState *astate, List *ancestors,
 /*
  * Show the grouping keys for a Group node.
  */
-static void
-show_group_keys(GroupState *gstate, List *ancestors,
-				ExplainState *es)
-{
-	Group	   *plan = (Group *) gstate->ss.ps.plan;
+static void show_group_keys(GroupState *gstate, List *ancestors,
+		ExplainState *es) {
+	Group *plan = (Group *) gstate->ss.ps.plan;
 
 	/* The key columns refer to the tlist of the child plan */
 	ancestors = lcons(gstate, ancestors);
-	show_sort_group_keys(outerPlanState(gstate), "Group Key",
-						 plan->numCols, plan->grpColIdx,
-						 ancestors, es);
+	show_sort_group_keys(outerPlanState(gstate), "Group Key", plan->numCols,
+			plan->grpColIdx, ancestors, es);
 	ancestors = list_delete_first(ancestors);
 }
 
@@ -1804,40 +1691,33 @@ show_group_keys(GroupState *gstate, List *ancestors,
  * Common code to show sort/group keys, which are represented in plan nodes
  * as arrays of targetlist indexes
  */
-static void
-show_sort_group_keys(PlanState *planstate, const char *qlabel,
-					 int nkeys, AttrNumber *keycols,
-					 List *ancestors, ExplainState *es)
-{
-	Plan	   *plan = planstate->plan;
-	List	   *context;
-	List	   *result = NIL;
-	bool		useprefix;
-	int			keyno;
-	char	   *exprstr;
+static void show_sort_group_keys(PlanState *planstate, const char *qlabel,
+		int nkeys, AttrNumber *keycols, List *ancestors, ExplainState *es) {
+	Plan *plan = planstate->plan;
+	List *context;
+	List *result = NIL;
+	bool useprefix;
+	int keyno;
+	char *exprstr;
 
 	if (nkeys <= 0)
 		return;
 
 	/* Set up deparsing context */
-	context = deparse_context_for_planstate((Node *) planstate,
-											ancestors,
-											es->rtable,
-											es->rtable_names);
+	context = deparse_context_for_planstate((Node *) planstate, ancestors,
+			es->rtable, es->rtable_names);
 	useprefix = (list_length(es->rtable) > 1 || es->verbose);
 
-	for (keyno = 0; keyno < nkeys; keyno++)
-	{
+	for (keyno = 0; keyno < nkeys; keyno++) {
 		/* find key expression in tlist */
-		AttrNumber	keyresno = keycols[keyno];
-		TargetEntry *target = get_tle_by_resno(plan->targetlist,
-											   keyresno);
+		AttrNumber keyresno = keycols[keyno];
+		TargetEntry *target = get_tle_by_resno(plan->targetlist, keyresno);
 
 		if (!target)
 			elog(ERROR, "no tlist entry for key %d", keyresno);
 		/* Deparse the expression, showing any top-level cast */
-		exprstr = deparse_expression((Node *) target->expr, context,
-									 useprefix, true);
+		exprstr = deparse_expression((Node *) target->expr, context, useprefix,
+				true);
 		result = lappend(result, exprstr);
 	}
 
@@ -1847,28 +1727,21 @@ show_sort_group_keys(PlanState *planstate, const char *qlabel,
 /*
  * If it's EXPLAIN ANALYZE, show tuplesort stats for a sort node
  */
-static void
-show_sort_info(SortState *sortstate, ExplainState *es)
-{
+static void show_sort_info(SortState *sortstate, ExplainState *es) {
 	Assert(IsA(sortstate, SortState));
-	if (es->analyze && sortstate->sort_Done &&
-		sortstate->tuplesortstate != NULL)
-	{
+	if (es->analyze && sortstate->sort_Done && sortstate->tuplesortstate != NULL) {
 		Tuplesortstate *state = (Tuplesortstate *) sortstate->tuplesortstate;
 		const char *sortMethod;
 		const char *spaceType;
-		long		spaceUsed;
+		long spaceUsed;
 
 		tuplesort_get_stats(state, &sortMethod, &spaceType, &spaceUsed);
 
-		if (es->format == EXPLAIN_FORMAT_TEXT)
-		{
+		if (es->format == EXPLAIN_FORMAT_TEXT) {
 			appendStringInfoSpaces(es->str, es->indent * 2);
 			appendStringInfo(es->str, "Sort Method: %s  %s: %ldkB\n",
-							 sortMethod, spaceType, spaceUsed);
-		}
-		else
-		{
+					sortMethod, spaceType, spaceUsed);
+		} else {
 			ExplainPropertyText("Sort Method", sortMethod, es);
 			ExplainPropertyLong("Sort Space Used", spaceUsed, es);
 			ExplainPropertyText("Sort Space Type", spaceType, es);
@@ -1879,41 +1752,32 @@ show_sort_info(SortState *sortstate, ExplainState *es)
 /*
  * Show information on hash buckets/batches.
  */
-static void
-show_hash_info(HashState *hashstate, ExplainState *es)
-{
+static void show_hash_info(HashState *hashstate, ExplainState *es) {
 	HashJoinTable hashtable;
 
 	Assert(IsA(hashstate, HashState));
 	hashtable = hashstate->hashtable;
 
-	if (hashtable)
-	{
-		long		spacePeakKb = (hashtable->spacePeak + 1023) / 1024;
+	if (hashtable) {
+		long spacePeakKb = (hashtable->spacePeak + 1023) / 1024;
 
-		if (es->format != EXPLAIN_FORMAT_TEXT)
-		{
+		if (es->format != EXPLAIN_FORMAT_TEXT) {
 			ExplainPropertyLong("Hash Buckets", hashtable->nbuckets, es);
 			ExplainPropertyLong("Hash Batches", hashtable->nbatch, es);
 			ExplainPropertyLong("Original Hash Batches",
-								hashtable->nbatch_original, es);
+					hashtable->nbatch_original, es);
 			ExplainPropertyLong("Peak Memory Usage", spacePeakKb, es);
-		}
-		else if (hashtable->nbatch_original != hashtable->nbatch)
-		{
+		} else if (hashtable->nbatch_original != hashtable->nbatch) {
 			appendStringInfoSpaces(es->str, es->indent * 2);
 			appendStringInfo(es->str,
-			"Buckets: %d  Batches: %d (originally %d)  Memory Usage: %ldkB\n",
-							 hashtable->nbuckets, hashtable->nbatch,
-							 hashtable->nbatch_original, spacePeakKb);
-		}
-		else
-		{
+					"Buckets: %d  Batches: %d (originally %d)  Memory Usage: %ldkB\n",
+					hashtable->nbuckets, hashtable->nbatch,
+					hashtable->nbatch_original, spacePeakKb);
+		} else {
 			appendStringInfoSpaces(es->str, es->indent * 2);
 			appendStringInfo(es->str,
-						   "Buckets: %d  Batches: %d  Memory Usage: %ldkB\n",
-							 hashtable->nbuckets, hashtable->nbatch,
-							 spacePeakKb);
+					"Buckets: %d  Batches: %d  Memory Usage: %ldkB\n",
+					hashtable->nbuckets, hashtable->nbatch, spacePeakKb);
 		}
 	}
 }
@@ -1921,16 +1785,12 @@ show_hash_info(HashState *hashstate, ExplainState *es)
 /*
  * If it's EXPLAIN ANALYZE, show exact/lossy pages for a BitmapHeapScan node
  */
-static void
-show_tidbitmap_info(BitmapHeapScanState *planstate, ExplainState *es)
-{
-	if (es->format != EXPLAIN_FORMAT_TEXT)
-	{
+static void show_tidbitmap_info(BitmapHeapScanState *planstate,
+		ExplainState *es) {
+	if (es->format != EXPLAIN_FORMAT_TEXT) {
 		ExplainPropertyLong("Exact Heap Blocks", planstate->exact_pages, es);
 		ExplainPropertyLong("Lossy Heap Blocks", planstate->lossy_pages, es);
-	}
-	else
-	{
+	} else {
 		appendStringInfoSpaces(es->str, es->indent * 2);
 		appendStringInfoString(es->str, "Heap Blocks:");
 		if (planstate->exact_pages > 0)
@@ -1946,12 +1806,10 @@ show_tidbitmap_info(BitmapHeapScanState *planstate, ExplainState *es)
  *
  * "which" identifies which instrumentation counter to print
  */
-static void
-show_instrumentation_count(const char *qlabel, int which,
-						   PlanState *planstate, ExplainState *es)
-{
-	double		nfiltered;
-	double		nloops;
+static void show_instrumentation_count(const char *qlabel, int which,
+		PlanState *planstate, ExplainState *es) {
+	double nfiltered;
+	double nloops;
 
 	if (!es->analyze || !planstate->instrument)
 		return;
@@ -1963,8 +1821,7 @@ show_instrumentation_count(const char *qlabel, int which,
 	nloops = planstate->instrument->nloops;
 
 	/* In text mode, suppress zero counts; they're not interesting enough */
-	if (nfiltered > 0 || es->format != EXPLAIN_FORMAT_TEXT)
-	{
+	if (nfiltered > 0 || es->format != EXPLAIN_FORMAT_TEXT) {
 		if (nloops > 0)
 			ExplainPropertyFloat(qlabel, nfiltered / nloops, 0, es);
 		else
@@ -1975,9 +1832,7 @@ show_instrumentation_count(const char *qlabel, int which,
 /*
  * Show extra information for a ForeignScan node.
  */
-static void
-show_foreignscan_info(ForeignScanState *fsstate, ExplainState *es)
-{
+static void show_foreignscan_info(ForeignScanState *fsstate, ExplainState *es) {
 	FdwRoutine *fdwroutine = fsstate->fdwroutine;
 
 	/* Let the FDW emit whatever fields it wants */
@@ -1992,16 +1847,14 @@ show_foreignscan_info(ForeignScanState *fsstate, ExplainState *es)
  * indexes can be explained.
  */
 static const char *
-explain_get_index_name(Oid indexId)
-{
+explain_get_index_name(Oid indexId) {
 	const char *result;
 
 	if (explain_get_index_name_hook)
-		result = (*explain_get_index_name_hook) (indexId);
+		result = (*explain_get_index_name_hook)(indexId);
 	else
 		result = NULL;
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		/* default behavior: look in the catalogs and quote it */
 		result = get_rel_name(indexId);
 		if (result == NULL)
@@ -2014,36 +1867,30 @@ explain_get_index_name(Oid indexId)
 /*
  * Add some additional details about an IndexScan or IndexOnlyScan
  */
-static void
-ExplainIndexScanDetails(Oid indexid, ScanDirection indexorderdir,
-						ExplainState *es)
-{
+static void ExplainIndexScanDetails(Oid indexid, ScanDirection indexorderdir,
+		ExplainState *es) {
 	const char *indexname = explain_get_index_name(indexid);
 
-	if (es->format == EXPLAIN_FORMAT_TEXT)
-	{
+	if (es->format == EXPLAIN_FORMAT_TEXT) {
 		if (ScanDirectionIsBackward(indexorderdir))
 			appendStringInfoString(es->str, " Backward");
 		appendStringInfo(es->str, " using %s", indexname);
-	}
-	else
-	{
+	} else {
 		const char *scandir;
 
-		switch (indexorderdir)
-		{
-			case BackwardScanDirection:
-				scandir = "Backward";
-				break;
-			case NoMovementScanDirection:
-				scandir = "NoMovement";
-				break;
-			case ForwardScanDirection:
-				scandir = "Forward";
-				break;
-			default:
-				scandir = "???";
-				break;
+		switch (indexorderdir) {
+		case BackwardScanDirection:
+			scandir = "Backward";
+			break;
+		case NoMovementScanDirection:
+			scandir = "NoMovement";
+			break;
+		case ForwardScanDirection:
+			scandir = "Forward";
+			break;
+		default:
+			scandir = "???";
+			break;
 		}
 		ExplainPropertyText("Scan Direction", scandir, es);
 		ExplainPropertyText("Index Name", indexname, es);
@@ -2053,19 +1900,15 @@ ExplainIndexScanDetails(Oid indexid, ScanDirection indexorderdir,
 /*
  * Show the target of a Scan node
  */
-static void
-ExplainScanTarget(Scan *plan, ExplainState *es)
-{
+static void ExplainScanTarget(Scan *plan, ExplainState *es) {
 	ExplainTargetRel((Plan *) plan, plan->scanrelid, es);
 }
 
 /*
  * Show the target of a ModifyTable node
  */
-static void
-ExplainModifyTarget(ModifyTable *plan, ExplainState *es)
-{
-	Index		rti;
+static void ExplainModifyTarget(ModifyTable *plan, ExplainState *es) {
+	Index rti;
 
 	/*
 	 * We show the name of the first target relation.  In multi-target-table
@@ -2080,101 +1923,92 @@ ExplainModifyTarget(ModifyTable *plan, ExplainState *es)
 /*
  * Show the target relation of a scan or modify node
  */
-static void
-ExplainTargetRel(Plan *plan, Index rti, ExplainState *es)
-{
-	char	   *objectname = NULL;
-	char	   *namespace = NULL;
+static void ExplainTargetRel(Plan *plan, Index rti, ExplainState *es) {
+	char *objectname = NULL;
+	char *namespace = NULL;
 	const char *objecttag = NULL;
 	RangeTblEntry *rte;
-	char	   *refname;
+	char *refname;
 
 	rte = rt_fetch(rti, es->rtable);
 	refname = (char *) list_nth(es->rtable_names, rti - 1);
 	if (refname == NULL)
 		refname = rte->eref->aliasname;
 
-	switch (nodeTag(plan))
-	{
-		case T_SeqScan:
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-		case T_BitmapHeapScan:
-		case T_TidScan:
-		case T_ForeignScan:
-		case T_ModifyTable:
-			/* Assert it's on a real relation */
-			Assert(rte->rtekind == RTE_RELATION);
-			objectname = get_rel_name(rte->relid);
-			if (es->verbose)
-				namespace = get_namespace_name(get_rel_namespace(rte->relid));
-			objecttag = "Relation Name";
-			break;
-		case T_FunctionScan:
-			{
-				FunctionScan *fscan = (FunctionScan *) plan;
-
-				/* Assert it's on a RangeFunction */
-				Assert(rte->rtekind == RTE_FUNCTION);
-
-				/*
-				 * If the expression is still a function call of a single
-				 * function, we can get the real name of the function.
-				 * Otherwise, punt.  (Even if it was a single function call
-				 * originally, the optimizer could have simplified it away.)
-				 */
-				if (list_length(fscan->functions) == 1)
-				{
-					RangeTblFunction *rtfunc = (RangeTblFunction *) linitial(fscan->functions);
-
-					if (IsA(rtfunc->funcexpr, FuncExpr))
-					{
-						FuncExpr   *funcexpr = (FuncExpr *) rtfunc->funcexpr;
-						Oid			funcid = funcexpr->funcid;
-
-						objectname = get_func_name(funcid);
-						if (es->verbose)
-							namespace =
-								get_namespace_name(get_func_namespace(funcid));
-					}
-				}
-				objecttag = "Function Name";
+	switch (nodeTag(plan)) {
+	case T_SeqScan:
+	case T_IndexScan:
+	case T_IndexOnlyScan:
+	case T_BitmapHeapScan:
+	case T_TidScan:
+	case T_ForeignScan:
+	case T_ModifyTable:
+		/* Assert it's on a real relation */
+		Assert(rte->rtekind == RTE_RELATION);
+		objectname = get_rel_name(rte->relid);
+		if (es->verbose)
+			namespace = get_namespace_name(get_rel_namespace(rte->relid));
+		objecttag = "Relation Name";
+		break;
+	case T_FunctionScan: {
+		FunctionScan *fscan = (FunctionScan *) plan;
+
+		/* Assert it's on a RangeFunction */
+		Assert(rte->rtekind == RTE_FUNCTION);
+
+		/*
+		 * If the expression is still a function call of a single
+		 * function, we can get the real name of the function.
+		 * Otherwise, punt.  (Even if it was a single function call
+		 * originally, the optimizer could have simplified it away.)
+		 */
+		if (list_length(fscan->functions) == 1) {
+			RangeTblFunction *rtfunc =
+					(RangeTblFunction *) linitial(fscan->functions);
+
+			if (IsA(rtfunc->funcexpr, FuncExpr)) {
+				FuncExpr *funcexpr = (FuncExpr *) rtfunc->funcexpr;
+				Oid funcid = funcexpr->funcid;
+
+				objectname = get_func_name(funcid);
+				if (es->verbose)
+					namespace = get_namespace_name(get_func_namespace(funcid));
 			}
-			break;
-		case T_ValuesScan:
-			Assert(rte->rtekind == RTE_VALUES);
-			break;
-		case T_CteScan:
-			/* Assert it's on a non-self-reference CTE */
-			Assert(rte->rtekind == RTE_CTE);
-			Assert(!rte->self_reference);
-			objectname = rte->ctename;
-			objecttag = "CTE Name";
-			break;
-		case T_WorkTableScan:
-			/* Assert it's on a self-reference CTE */
-			Assert(rte->rtekind == RTE_CTE);
-			Assert(rte->self_reference);
-			objectname = rte->ctename;
-			objecttag = "CTE Name";
-			break;
-		default:
-			break;
+		}
+		objecttag = "Function Name";
+	}
+		break;
+	case T_ValuesScan:
+		Assert(rte->rtekind == RTE_VALUES);
+		break;
+	case T_CteScan:
+		/* Assert it's on a non-self-reference CTE */
+		Assert(rte->rtekind == RTE_CTE);
+		Assert(!rte->self_reference);
+		objectname = rte->ctename;
+		objecttag = "CTE Name";
+		break;
+	case T_WorkTableScan:
+		/* Assert it's on a self-reference CTE */
+		Assert(rte->rtekind == RTE_CTE);
+		Assert(rte->self_reference);
+		objectname = rte->ctename;
+		objecttag = "CTE Name";
+		break;
+	default:
+		break;
 	}
 
-	if (es->format == EXPLAIN_FORMAT_TEXT)
-	{
+	if (es->format == EXPLAIN_FORMAT_TEXT) {
 		appendStringInfoString(es->str, " on");
 		if (namespace != NULL)
 			appendStringInfo(es->str, " %s.%s", quote_identifier(namespace),
-							 quote_identifier(objectname));
+					quote_identifier(objectname));
 		else if (objectname != NULL)
 			appendStringInfo(es->str, " %s", quote_identifier(objectname));
 		if (objectname == NULL || strcmp(refname, objectname) != 0)
 			appendStringInfo(es->str, " %s", quote_identifier(refname));
-	}
-	else
-	{
+	} else {
 		if (objecttag != NULL && objectname != NULL)
 			ExplainPropertyText(objecttag, objectname, es);
 		if (namespace != NULL)
@@ -2186,9 +2020,7 @@ ExplainTargetRel(Plan *plan, Index rti, ExplainState *es)
 /*
  * Show extra information for a ModifyTable node
  */
-static void
-show_modifytable_info(ModifyTableState *mtstate, ExplainState *es)
-{
+static void show_modifytable_info(ModifyTableState *mtstate, ExplainState *es) {
 	FdwRoutine *fdwroutine = mtstate->resultRelInfo->ri_FdwRoutine;
 
 	/*
@@ -2197,17 +2029,12 @@ show_modifytable_info(ModifyTableState *mtstate, ExplainState *es)
 	 * possibility of other targets being foreign tables, although the API for
 	 * ExplainForeignModify is designed to allow them to be processed.
 	 */
-	if (fdwroutine != NULL &&
-		fdwroutine->ExplainForeignModify != NULL)
-	{
+	if (fdwroutine != NULL && fdwroutine->ExplainForeignModify != NULL) {
 		ModifyTable *node = (ModifyTable *) mtstate->ps.plan;
-		List	   *fdw_private = (List *) linitial(node->fdwPrivLists);
+		List *fdw_private = (List *) linitial(node->fdwPrivLists);
 
-		fdwroutine->ExplainForeignModify(mtstate,
-										 mtstate->resultRelInfo,
-										 fdw_private,
-										 0,
-										 es);
+		fdwroutine->ExplainForeignModify(mtstate, mtstate->resultRelInfo,
+				fdw_private, 0, es);
 	}
 }
 
@@ -2221,16 +2048,13 @@ show_modifytable_info(ModifyTableState *mtstate, ExplainState *es)
  * Note: we don't actually need to examine the Plan list members, but
  * we need the list in order to determine the length of the PlanState array.
  */
-static void
-ExplainMemberNodes(List *plans, PlanState **planstates,
-				   List *ancestors, ExplainState *es)
-{
-	int			nplans = list_length(plans);
-	int			j;
+static void ExplainMemberNodes(List *plans, PlanState **planstates,
+		List *ancestors, ExplainState *es) {
+	int nplans = list_length(plans);
+	int j;
 
 	for (j = 0; j < nplans; j++)
-		ExplainNode(planstates[j], ancestors,
-					"Member", NULL, es);
+		ExplainNode(planstates[j], ancestors, "Member", NULL, es);
 }
 
 /*
@@ -2239,19 +2063,15 @@ ExplainMemberNodes(List *plans, PlanState **planstates,
  * The ancestors list should already contain the immediate parent of these
  * SubPlanStates.
  */
-static void
-ExplainSubPlans(List *plans, List *ancestors,
-				const char *relationship, ExplainState *es)
-{
-	ListCell   *lst;
-
-	foreach(lst, plans)
-	{
+static void ExplainSubPlans(List *plans, List *ancestors,
+		const char *relationship, ExplainState *es) {
+	ListCell *lst;
+
+	foreach(lst, plans) {
 		SubPlanState *sps = (SubPlanState *) lfirst(lst);
-		SubPlan    *sp = (SubPlan *) sps->xprstate.expr;
+		SubPlan *sp = (SubPlan *) sps->xprstate.expr;
 
-		ExplainNode(sps->planstate, ancestors,
-					relationship, sp->plan_name, es);
+		ExplainNode(sps->planstate, ancestors, relationship, sp->plan_name, es);
 	}
 }
 
@@ -2259,69 +2079,62 @@ ExplainSubPlans(List *plans, List *ancestors,
  * Explain a property, such as sort keys or targets, that takes the form of
  * a list of unlabeled items.  "data" is a list of C strings.
  */
-void
-ExplainPropertyList(const char *qlabel, List *data, ExplainState *es)
-{
-	ListCell   *lc;
-	bool		first = true;
-
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			appendStringInfoSpaces(es->str, es->indent * 2);
-			appendStringInfo(es->str, "%s: ", qlabel);
-			foreach(lc, data)
-			{
-				if (!first)
-					appendStringInfoString(es->str, ", ");
-				appendStringInfoString(es->str, (const char *) lfirst(lc));
-				first = false;
-			}
-			appendStringInfoChar(es->str, '\n');
-			break;
+void ExplainPropertyList(const char *qlabel, List *data, ExplainState *es) {
+	ListCell *lc;
+	bool first = true;
 
-		case EXPLAIN_FORMAT_XML:
-			ExplainXMLTag(qlabel, X_OPENING, es);
-			foreach(lc, data)
-			{
-				char	   *str;
-
-				appendStringInfoSpaces(es->str, es->indent * 2 + 2);
-				appendStringInfoString(es->str, "<Item>");
-				str = escape_xml((const char *) lfirst(lc));
-				appendStringInfoString(es->str, str);
-				pfree(str);
-				appendStringInfoString(es->str, "</Item>\n");
-			}
-			ExplainXMLTag(qlabel, X_CLOSING, es);
-			break;
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		appendStringInfoSpaces(es->str, es->indent * 2);
+		appendStringInfo(es->str, "%s: ", qlabel);
+		foreach(lc, data) {
+			if (!first)
+				appendStringInfoString(es->str, ", ");
+			appendStringInfoString(es->str, (const char *) lfirst(lc));
+			first = false;
+		}
+		appendStringInfoChar(es->str, '\n');
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		ExplainXMLTag(qlabel, X_OPENING, es);
+		foreach(lc, data) {
+			char *str;
+
+			appendStringInfoSpaces(es->str, es->indent * 2 + 2);
+			appendStringInfoString(es->str, "<Item>");
+			str = escape_xml((const char *) lfirst(lc));
+			appendStringInfoString(es->str, str);
+			pfree(str);
+			appendStringInfoString(es->str, "</Item>\n");
+		}
+		ExplainXMLTag(qlabel, X_CLOSING, es);
+		break;
 
-		case EXPLAIN_FORMAT_JSON:
-			ExplainJSONLineEnding(es);
-			appendStringInfoSpaces(es->str, es->indent * 2);
-			escape_json(es->str, qlabel);
-			appendStringInfoString(es->str, ": [");
-			foreach(lc, data)
-			{
-				if (!first)
-					appendStringInfoString(es->str, ", ");
-				escape_json(es->str, (const char *) lfirst(lc));
-				first = false;
-			}
-			appendStringInfoChar(es->str, ']');
-			break;
+	case EXPLAIN_FORMAT_JSON:
+		ExplainJSONLineEnding(es);
+		appendStringInfoSpaces(es->str, es->indent * 2);
+		escape_json(es->str, qlabel);
+		appendStringInfoString(es->str, ": [");
+		foreach(lc, data) {
+			if (!first)
+				appendStringInfoString(es->str, ", ");
+			escape_json(es->str, (const char *) lfirst(lc));
+			first = false;
+		}
+		appendStringInfoChar(es->str, ']');
+		break;
 
-		case EXPLAIN_FORMAT_YAML:
-			ExplainYAMLLineStarting(es);
-			appendStringInfo(es->str, "%s: ", qlabel);
-			foreach(lc, data)
-			{
-				appendStringInfoChar(es->str, '\n');
-				appendStringInfoSpaces(es->str, es->indent * 2 + 2);
-				appendStringInfoString(es->str, "- ");
-				escape_yaml(es->str, (const char *) lfirst(lc));
-			}
-			break;
+	case EXPLAIN_FORMAT_YAML:
+		ExplainYAMLLineStarting(es);
+		appendStringInfo(es->str, "%s: ", qlabel);
+		foreach(lc, data) {
+			appendStringInfoChar(es->str, '\n');
+			appendStringInfoSpaces(es->str, es->indent * 2 + 2);
+			appendStringInfoString(es->str, "- ");
+			escape_yaml(es->str, (const char *) lfirst(lc));
+		}
+		break;
 	}
 }
 
@@ -2334,69 +2147,62 @@ ExplainPropertyList(const char *qlabel, List *data, ExplainState *es)
  * This usually should not be invoked directly, but via one of the datatype
  * specific routines ExplainPropertyText, ExplainPropertyInteger, etc.
  */
-static void
-ExplainProperty(const char *qlabel, const char *value, bool numeric,
-				ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			appendStringInfoSpaces(es->str, es->indent * 2);
-			appendStringInfo(es->str, "%s: %s\n", qlabel, value);
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			{
-				char	   *str;
+static void ExplainProperty(const char *qlabel, const char *value, bool numeric,
+		ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		appendStringInfoSpaces(es->str, es->indent * 2);
+		appendStringInfo(es->str, "%s: %s\n", qlabel, value);
+		break;
 
-				appendStringInfoSpaces(es->str, es->indent * 2);
-				ExplainXMLTag(qlabel, X_OPENING | X_NOWHITESPACE, es);
-				str = escape_xml(value);
-				appendStringInfoString(es->str, str);
-				pfree(str);
-				ExplainXMLTag(qlabel, X_CLOSING | X_NOWHITESPACE, es);
-				appendStringInfoChar(es->str, '\n');
-			}
-			break;
+	case EXPLAIN_FORMAT_XML: {
+		char *str;
 
-		case EXPLAIN_FORMAT_JSON:
-			ExplainJSONLineEnding(es);
-			appendStringInfoSpaces(es->str, es->indent * 2);
-			escape_json(es->str, qlabel);
-			appendStringInfoString(es->str, ": ");
-			if (numeric)
-				appendStringInfoString(es->str, value);
-			else
-				escape_json(es->str, value);
-			break;
+		appendStringInfoSpaces(es->str, es->indent * 2);
+		ExplainXMLTag(qlabel, X_OPENING | X_NOWHITESPACE, es);
+		str = escape_xml(value);
+		appendStringInfoString(es->str, str);
+		pfree(str);
+		ExplainXMLTag(qlabel, X_CLOSING | X_NOWHITESPACE, es);
+		appendStringInfoChar(es->str, '\n');
+	}
+		break;
 
-		case EXPLAIN_FORMAT_YAML:
-			ExplainYAMLLineStarting(es);
-			appendStringInfo(es->str, "%s: ", qlabel);
-			if (numeric)
-				appendStringInfoString(es->str, value);
-			else
-				escape_yaml(es->str, value);
-			break;
+	case EXPLAIN_FORMAT_JSON:
+		ExplainJSONLineEnding(es);
+		appendStringInfoSpaces(es->str, es->indent * 2);
+		escape_json(es->str, qlabel);
+		appendStringInfoString(es->str, ": ");
+		if (numeric)
+			appendStringInfoString(es->str, value);
+		else
+			escape_json(es->str, value);
+		break;
+
+	case EXPLAIN_FORMAT_YAML:
+		ExplainYAMLLineStarting(es);
+		appendStringInfo(es->str, "%s: ", qlabel);
+		if (numeric)
+			appendStringInfoString(es->str, value);
+		else
+			escape_yaml(es->str, value);
+		break;
 	}
 }
 
 /*
  * Explain a string-valued property.
  */
-void
-ExplainPropertyText(const char *qlabel, const char *value, ExplainState *es)
-{
+void ExplainPropertyText(const char *qlabel, const char *value,
+		ExplainState *es) {
 	ExplainProperty(qlabel, value, false, es);
 }
 
 /*
  * Explain an integer-valued property.
  */
-void
-ExplainPropertyInteger(const char *qlabel, int value, ExplainState *es)
-{
-	char		buf[32];
+void ExplainPropertyInteger(const char *qlabel, int value, ExplainState *es) {
+	char buf[32];
 
 	snprintf(buf, sizeof(buf), "%d", value);
 	ExplainProperty(qlabel, buf, true, es);
@@ -2405,10 +2211,8 @@ ExplainPropertyInteger(const char *qlabel, int value, ExplainState *es)
 /*
  * Explain a long-integer-valued property.
  */
-void
-ExplainPropertyLong(const char *qlabel, long value, ExplainState *es)
-{
-	char		buf[32];
+void ExplainPropertyLong(const char *qlabel, long value, ExplainState *es) {
+	char buf[32];
 
 	snprintf(buf, sizeof(buf), "%ld", value);
 	ExplainProperty(qlabel, buf, true, es);
@@ -2418,11 +2222,9 @@ ExplainPropertyLong(const char *qlabel, long value, ExplainState *es)
  * Explain a float-valued property, using the specified number of
  * fractional digits.
  */
-void
-ExplainPropertyFloat(const char *qlabel, double value, int ndigits,
-					 ExplainState *es)
-{
-	char		buf[256];
+void ExplainPropertyFloat(const char *qlabel, double value, int ndigits,
+		ExplainState *es) {
+	char buf[256];
 
 	snprintf(buf, sizeof(buf), "%.*f", ndigits, value);
 	ExplainProperty(qlabel, buf, true, es);
@@ -2437,62 +2239,55 @@ ExplainPropertyFloat(const char *qlabel, double value, int ndigits,
  * If labeled is true, the group members will be labeled properties,
  * while if it's false, they'll be unlabeled objects.
  */
-static void
-ExplainOpenGroup(const char *objtype, const char *labelname,
-				 bool labeled, ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* nothing to do */
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			ExplainXMLTag(objtype, X_OPENING, es);
-			es->indent++;
-			break;
+static void ExplainOpenGroup(const char *objtype, const char *labelname,
+		bool labeled, ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* nothing to do */
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		ExplainXMLTag(objtype, X_OPENING, es);
+		es->indent++;
+		break;
 
-		case EXPLAIN_FORMAT_JSON:
-			ExplainJSONLineEnding(es);
-			appendStringInfoSpaces(es->str, 2 * es->indent);
-			if (labelname)
-			{
-				escape_json(es->str, labelname);
-				appendStringInfoString(es->str, ": ");
-			}
-			appendStringInfoChar(es->str, labeled ? '{' : '[');
+	case EXPLAIN_FORMAT_JSON:
+		ExplainJSONLineEnding(es);
+		appendStringInfoSpaces(es->str, 2 * es->indent);
+		if (labelname) {
+			escape_json(es->str, labelname);
+			appendStringInfoString(es->str, ": ");
+		}
+		appendStringInfoChar(es->str, labeled ? '{' : '[');
 
-			/*
-			 * In JSON format, the grouping_stack is an integer list.  0 means
-			 * we've emitted nothing at this grouping level, 1 means we've
-			 * emitted something (and so the next item needs a comma). See
-			 * ExplainJSONLineEnding().
-			 */
-			es->grouping_stack = lcons_int(0, es->grouping_stack);
-			es->indent++;
-			break;
+		/*
+		 * In JSON format, the grouping_stack is an integer list.  0 means
+		 * we've emitted nothing at this grouping level, 1 means we've
+		 * emitted something (and so the next item needs a comma). See
+		 * ExplainJSONLineEnding().
+		 */
+		es->grouping_stack = lcons_int(0, es->grouping_stack);
+		es->indent++;
+		break;
 
-		case EXPLAIN_FORMAT_YAML:
+	case EXPLAIN_FORMAT_YAML:
 
-			/*
-			 * In YAML format, the grouping stack is an integer list.  0 means
-			 * we've emitted nothing at this grouping level AND this grouping
-			 * level is unlabelled and must be marked with "- ".  See
-			 * ExplainYAMLLineStarting().
-			 */
-			ExplainYAMLLineStarting(es);
-			if (labelname)
-			{
-				appendStringInfo(es->str, "%s: ", labelname);
-				es->grouping_stack = lcons_int(1, es->grouping_stack);
-			}
-			else
-			{
-				appendStringInfoString(es->str, "- ");
-				es->grouping_stack = lcons_int(0, es->grouping_stack);
-			}
-			es->indent++;
-			break;
+		/*
+		 * In YAML format, the grouping stack is an integer list.  0 means
+		 * we've emitted nothing at this grouping level AND this grouping
+		 * level is unlabelled and must be marked with "- ".  See
+		 * ExplainYAMLLineStarting().
+		 */
+		ExplainYAMLLineStarting(es);
+		if (labelname) {
+			appendStringInfo(es->str, "%s: ", labelname);
+			es->grouping_stack = lcons_int(1, es->grouping_stack);
+		} else {
+			appendStringInfoString(es->str, "- ");
+			es->grouping_stack = lcons_int(0, es->grouping_stack);
+		}
+		es->indent++;
+		break;
 	}
 }
 
@@ -2500,33 +2295,30 @@ ExplainOpenGroup(const char *objtype, const char *labelname,
  * Close a group of related objects.
  * Parameters must match the corresponding ExplainOpenGroup call.
  */
-static void
-ExplainCloseGroup(const char *objtype, const char *labelname,
-				  bool labeled, ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* nothing to do */
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			es->indent--;
-			ExplainXMLTag(objtype, X_CLOSING, es);
-			break;
-
-		case EXPLAIN_FORMAT_JSON:
-			es->indent--;
-			appendStringInfoChar(es->str, '\n');
-			appendStringInfoSpaces(es->str, 2 * es->indent);
-			appendStringInfoChar(es->str, labeled ? '}' : ']');
-			es->grouping_stack = list_delete_first(es->grouping_stack);
-			break;
-
-		case EXPLAIN_FORMAT_YAML:
-			es->indent--;
-			es->grouping_stack = list_delete_first(es->grouping_stack);
-			break;
+static void ExplainCloseGroup(const char *objtype, const char *labelname,
+		bool labeled, ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* nothing to do */
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		es->indent--;
+		ExplainXMLTag(objtype, X_CLOSING, es);
+		break;
+
+	case EXPLAIN_FORMAT_JSON:
+		es->indent--;
+		appendStringInfoChar(es->str, '\n');
+		appendStringInfoSpaces(es->str, 2 * es->indent);
+		appendStringInfoChar(es->str, labeled ? '}' : ']');
+		es->grouping_stack = list_delete_first(es->grouping_stack);
+		break;
+
+	case EXPLAIN_FORMAT_YAML:
+		es->indent--;
+		es->grouping_stack = list_delete_first(es->grouping_stack);
+		break;
 	}
 }
 
@@ -2536,43 +2328,37 @@ ExplainCloseGroup(const char *objtype, const char *labelname,
  * objtype is the type of the group object, labelname is its label within
  * a containing object (if any).
  */
-static void
-ExplainDummyGroup(const char *objtype, const char *labelname, ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* nothing to do */
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			ExplainXMLTag(objtype, X_CLOSE_IMMEDIATE, es);
-			break;
-
-		case EXPLAIN_FORMAT_JSON:
-			ExplainJSONLineEnding(es);
-			appendStringInfoSpaces(es->str, 2 * es->indent);
-			if (labelname)
-			{
-				escape_json(es->str, labelname);
-				appendStringInfoString(es->str, ": ");
-			}
-			escape_json(es->str, objtype);
-			break;
+static void ExplainDummyGroup(const char *objtype, const char *labelname,
+		ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* nothing to do */
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		ExplainXMLTag(objtype, X_CLOSE_IMMEDIATE, es);
+		break;
+
+	case EXPLAIN_FORMAT_JSON:
+		ExplainJSONLineEnding(es);
+		appendStringInfoSpaces(es->str, 2 * es->indent);
+		if (labelname) {
+			escape_json(es->str, labelname);
+			appendStringInfoString(es->str, ": ");
+		}
+		escape_json(es->str, objtype);
+		break;
 
-		case EXPLAIN_FORMAT_YAML:
-			ExplainYAMLLineStarting(es);
-			if (labelname)
-			{
-				escape_yaml(es->str, labelname);
-				appendStringInfoString(es->str, ": ");
-			}
-			else
-			{
-				appendStringInfoString(es->str, "- ");
-			}
-			escape_yaml(es->str, objtype);
-			break;
+	case EXPLAIN_FORMAT_YAML:
+		ExplainYAMLLineStarting(es);
+		if (labelname) {
+			escape_yaml(es->str, labelname);
+			appendStringInfoString(es->str, ": ");
+		} else {
+			appendStringInfoString(es->str, "- ");
+		}
+		escape_yaml(es->str, objtype);
+		break;
 	}
 }
 
@@ -2582,81 +2368,72 @@ ExplainDummyGroup(const char *objtype, const char *labelname, ExplainState *es)
  * This is just enough different from processing a subgroup that we need
  * a separate pair of subroutines.
  */
-void
-ExplainBeginOutput(ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* nothing to do */
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			appendStringInfoString(es->str,
-			 "<explain xmlns=\"http://www.postgresql.org/2009/explain\">\n");
-			es->indent++;
-			break;
+void ExplainBeginOutput(ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* nothing to do */
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		appendStringInfoString(es->str,
+				"<explain xmlns=\"http://www.postgresql.org/2009/explain\">\n");
+		es->indent++;
+		break;
 
-		case EXPLAIN_FORMAT_JSON:
-			/* top-level structure is an array of plans */
-			appendStringInfoChar(es->str, '[');
-			es->grouping_stack = lcons_int(0, es->grouping_stack);
-			es->indent++;
-			break;
+	case EXPLAIN_FORMAT_JSON:
+		/* top-level structure is an array of plans */
+		appendStringInfoChar(es->str, '[');
+		es->grouping_stack = lcons_int(0, es->grouping_stack);
+		es->indent++;
+		break;
 
-		case EXPLAIN_FORMAT_YAML:
-			es->grouping_stack = lcons_int(0, es->grouping_stack);
-			break;
+	case EXPLAIN_FORMAT_YAML:
+		es->grouping_stack = lcons_int(0, es->grouping_stack);
+		break;
 	}
 }
 
 /*
  * Emit the end-of-output boilerplate.
  */
-void
-ExplainEndOutput(ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* nothing to do */
-			break;
-
-		case EXPLAIN_FORMAT_XML:
-			es->indent--;
-			appendStringInfoString(es->str, "</explain>");
-			break;
-
-		case EXPLAIN_FORMAT_JSON:
-			es->indent--;
-			appendStringInfoString(es->str, "\n]");
-			es->grouping_stack = list_delete_first(es->grouping_stack);
-			break;
-
-		case EXPLAIN_FORMAT_YAML:
-			es->grouping_stack = list_delete_first(es->grouping_stack);
-			break;
+void ExplainEndOutput(ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* nothing to do */
+		break;
+
+	case EXPLAIN_FORMAT_XML:
+		es->indent--;
+		appendStringInfoString(es->str, "</explain>");
+		break;
+
+	case EXPLAIN_FORMAT_JSON:
+		es->indent--;
+		appendStringInfoString(es->str, "\n]");
+		es->grouping_stack = list_delete_first(es->grouping_stack);
+		break;
+
+	case EXPLAIN_FORMAT_YAML:
+		es->grouping_stack = list_delete_first(es->grouping_stack);
+		break;
 	}
 }
 
 /*
  * Put an appropriate separator between multiple plans
  */
-void
-ExplainSeparatePlans(ExplainState *es)
-{
-	switch (es->format)
-	{
-		case EXPLAIN_FORMAT_TEXT:
-			/* add a blank line */
-			appendStringInfoChar(es->str, '\n');
-			break;
+void ExplainSeparatePlans(ExplainState *es) {
+	switch (es->format) {
+	case EXPLAIN_FORMAT_TEXT:
+		/* add a blank line */
+		appendStringInfoChar(es->str, '\n');
+		break;
 
-		case EXPLAIN_FORMAT_XML:
-		case EXPLAIN_FORMAT_JSON:
-		case EXPLAIN_FORMAT_YAML:
-			/* nothing to do */
-			break;
+	case EXPLAIN_FORMAT_XML:
+	case EXPLAIN_FORMAT_JSON:
+	case EXPLAIN_FORMAT_YAML:
+		/* nothing to do */
+		break;
 	}
 }
 
@@ -2670,9 +2447,7 @@ ExplainSeparatePlans(ExplainState *es)
  * XML tag names can't contain white space, so we replace any spaces in
  * "tagname" with dashes.
  */
-static void
-ExplainXMLTag(const char *tagname, int flags, ExplainState *es)
-{
+static void ExplainXMLTag(const char *tagname, int flags, ExplainState *es) {
 	const char *s;
 
 	if ((flags & X_NOWHITESPACE) == 0)
@@ -2696,9 +2471,7 @@ ExplainXMLTag(const char *tagname, int flags, ExplainState *es)
  * in JSON format, the text emitted for each property begins just prior to the
  * preceding line-break (and comma, if applicable).
  */
-static void
-ExplainJSONLineEnding(ExplainState *es)
-{
+static void ExplainJSONLineEnding(ExplainState *es) {
 	Assert(es->format == EXPLAIN_FORMAT_JSON);
 	if (linitial_int(es->grouping_stack) != 0)
 		appendStringInfoChar(es->str, ',');
@@ -2716,16 +2489,11 @@ ExplainJSONLineEnding(ExplainState *es)
  * it begins immediately after the "- " that introduces the group.	The first
  * property of the group appears on the same line as the opening "- ".
  */
-static void
-ExplainYAMLLineStarting(ExplainState *es)
-{
+static void ExplainYAMLLineStarting(ExplainState *es) {
 	Assert(es->format == EXPLAIN_FORMAT_YAML);
-	if (linitial_int(es->grouping_stack) == 0)
-	{
+	if (linitial_int(es->grouping_stack) == 0) {
 		linitial_int(es->grouping_stack) = 1;
-	}
-	else
-	{
+	} else {
 		appendStringInfoChar(es->str, '\n');
 		appendStringInfoSpaces(es->str, es->indent * 2);
 	}
@@ -2741,8 +2509,15 @@ ExplainYAMLLineStarting(ExplainState *es)
  * "true" must be quoted, lest they be interpreted as a hexadecimal or Boolean
  * constant rather than a string.
  */
-static void
-escape_yaml(StringInfo buf, const char *str)
-{
+static void escape_yaml(StringInfo buf, const char *str) {
 	escape_json(buf, str);
 }
+static void show_scan_parsed_qual(List *quals, const char *qlabel,
+		ExplainState *es) {
+	Node *node = (Node *)make_ands_explicit(quals);
+	char *res = nodeSimToString(node);
+
+	ExplainPropertyText(qlabel, res, es);
+
+}
+
diff --git a/src/backend/nodes/outfuncs.c b/src/backend/nodes/outfuncs.c
index bfb4b9f..0ff6615 100644
--- a/src/backend/nodes/outfuncs.c
+++ b/src/backend/nodes/outfuncs.c
@@ -25,10 +25,11 @@
 
 #include "lib/stringinfo.h"
 #include "nodes/plannodes.h"
+#include "nodes/outfuncs.h"
+
 #include "nodes/relation.h"
 #include "utils/datum.h"
 
-
 /*
  * Macros to simplify output of different kinds of fields.	Use these
  * wherever possible to reduce the chance for silly typos.	Note that these
@@ -87,18 +88,17 @@
 #define WRITE_NODE_FIELD(fldname) \
 	(appendStringInfo(str, " :" CppAsString(fldname) " "), \
 	 _outNode(str, node->fldname))
-
+/* Write a Node field */
+#define WRITE_NODE_SIM_FIELD(fldname) \
+	(appendStringInfo(str, " :" CppAsString(fldname) " "), \
+	 _outSimNode(str, node->fldname))
 /* Write a bitmapset field */
 #define WRITE_BITMAPSET_FIELD(fldname) \
 	(appendStringInfo(str, " :" CppAsString(fldname) " "), \
 	 _outBitmapset(str, node->fldname))
 
-
 #define booltostr(x)  ((x) ? "true" : "false")
 
-static void _outNode(StringInfo str, const void *obj);
-
-
 /*
  * _outToken
  *	  Convert an ordinary string (eg, an identifier) into a form that
@@ -106,11 +106,8 @@ static void _outNode(StringInfo str, const void *obj);
  *
  *	  If a null or empty string is given, it is encoded as "<>".
  */
-static void
-_outToken(StringInfo str, const char *s)
-{
-	if (s == NULL || *s == '\0')
-	{
+static void _outToken(StringInfo str, const char *s) {
+	if (s == NULL || *s == '\0') {
 		appendStringInfoString(str, "<>");
 		return;
 	}
@@ -121,26 +118,20 @@ _outToken(StringInfo str, const char *s)
 	 * protective backslash.
 	 */
 	/* These characters only need to be quoted at the start of the string */
-	if (*s == '<' ||
-		*s == '\"' ||
-		isdigit((unsigned char) *s) ||
-		((*s == '+' || *s == '-') &&
-		 (isdigit((unsigned char) s[1]) || s[1] == '.')))
+	if (*s == '<' || *s == '\"' || isdigit((unsigned char) *s)
+			|| ((*s == '+' || *s == '-')
+					&& (isdigit((unsigned char) s[1]) || s[1] == '.')))
 		appendStringInfoChar(str, '\\');
-	while (*s)
-	{
+	while (*s) {
 		/* These chars must be backslashed anywhere in the string */
-		if (*s == ' ' || *s == '\n' || *s == '\t' ||
-			*s == '(' || *s == ')' || *s == '{' || *s == '}' ||
-			*s == '\\')
+		if (*s == ' ' || *s == '\n' || *s == '\t' || *s == '(' || *s == ')'
+				|| *s == '{' || *s == '}' || *s == '\\')
 			appendStringInfoChar(str, '\\');
 		appendStringInfoChar(str, *s++);
 	}
 }
 
-static void
-_outList(StringInfo str, const List *node)
-{
+static void _outList(StringInfo str, const List *node, bool sim) {
 	const ListCell *lc;
 
 	appendStringInfoChar(str, '(');
@@ -150,29 +141,44 @@ _outList(StringInfo str, const List *node)
 	else if (IsA(node, OidList))
 		appendStringInfoChar(str, 'o');
 
-	foreach(lc, node)
-	{
+	foreach(lc, node) {
 		/*
 		 * For the sake of backward compatibility, we emit a slightly
 		 * different whitespace format for lists of nodes vs. other types of
 		 * lists. XXX: is this necessary?
 		 */
-		if (IsA(node, List))
-		{
-			_outNode(str, lfirst(lc));
-			if (lnext(lc))
+		if (IsA(node, List)) {
+
+			if (!sim)
+				_outNode(str, lfirst(lc));
+			else
+				_outSimNode(str, lfirst(lc));
+			if (lnext(lc)) {
 				appendStringInfoChar(str, ' ');
-		}
-		else if (IsA(node, IntList))
+				switch (nodeTag(lfirst(lc))) {
+
+				case T_SubPlan:
+				case T_OpExpr:
+				case T_BoolExpr:
+				case T_RestrictInfo:
+					appendStringInfoChar(str, ',');
+					appendStringInfoChar(str, ' ');
+					break;
+				default:
+					break;
+				}
+
+			}
+		} else if (IsA(node, IntList))
 			appendStringInfo(str, " %d", lfirst_int(lc));
 		else if (IsA(node, OidList))
 			appendStringInfo(str, " %u", lfirst_oid(lc));
 		else
-			elog(ERROR, "unrecognized list node type: %d",
-				 (int) node->type);
+			elog(ERROR, "unrecognized list node type: %d", (int) node->type);
 	}
 
 	appendStringInfoChar(str, ')');
+
 }
 
 /*
@@ -181,11 +187,9 @@ _outList(StringInfo str, const List *node)
  *
  * Note: the output format is "(b int int ...)", similar to an integer List.
  */
-static void
-_outBitmapset(StringInfo str, const Bitmapset *bms)
-{
-	Bitmapset  *tmpset;
-	int			x;
+static void _outBitmapset(StringInfo str, const Bitmapset *bms) {
+	Bitmapset *tmpset;
+	int x;
 
 	appendStringInfoChar(str, '(');
 	appendStringInfoChar(str, 'b');
@@ -199,30 +203,23 @@ _outBitmapset(StringInfo str, const Bitmapset *bms)
 /*
  * Print the value of a Datum given its type.
  */
-static void
-_outDatum(StringInfo str, Datum value, int typlen, bool typbyval)
-{
-	Size		length,
-				i;
-	char	   *s;
+static void _outDatum(StringInfo str, Datum value, int typlen, bool typbyval) {
+	Size length, i;
+	char *s;
 
 	length = datumGetSize(value, typbyval, typlen);
 
-	if (typbyval)
-	{
+	if (typbyval) {
 		s = (char *) (&value);
 		appendStringInfo(str, "%u [ ", (unsigned int) length);
 		for (i = 0; i < (Size) sizeof(Datum); i++)
 			appendStringInfo(str, "%d ", (int) (s[i]));
 		appendStringInfoChar(str, ']');
-	}
-	else
-	{
+	} else {
 		s = (char *) DatumGetPointer(value);
 		if (!PointerIsValid(s))
 			appendStringInfoString(str, "0 [ ]");
-		else
-		{
+		else {
 			appendStringInfo(str, "%u [ ", (unsigned int) length);
 			for (i = 0; i < length; i++)
 				appendStringInfo(str, "%d ", (int) (s[i]));
@@ -231,14 +228,11 @@ _outDatum(StringInfo str, Datum value, int typlen, bool typbyval)
 	}
 }
 
-
 /*
  *	Stuff from plannodes.h
  */
 
-static void
-_outPlannedStmt(StringInfo str, const PlannedStmt *node)
-{
+static void _outPlannedStmt(StringInfo str, const PlannedStmt *node) {
 	WRITE_NODE_TYPE("PLANNEDSTMT");
 
 	WRITE_ENUM_FIELD(commandType, CmdType);
@@ -262,9 +256,7 @@ _outPlannedStmt(StringInfo str, const PlannedStmt *node)
 /*
  * print the basic stuff of all nodes that inherit from Plan
  */
-static void
-_outPlanInfo(StringInfo str, const Plan *node)
-{
+static void _outPlanInfo(StringInfo str, const Plan *node) {
 	WRITE_FLOAT_FIELD(startup_cost, "%.2f");
 	WRITE_FLOAT_FIELD(total_cost, "%.2f");
 	WRITE_FLOAT_FIELD(plan_rows, "%.0f");
@@ -281,9 +273,7 @@ _outPlanInfo(StringInfo str, const Plan *node)
 /*
  * print the basic stuff of all nodes that inherit from Scan
  */
-static void
-_outScanInfo(StringInfo str, const Scan *node)
-{
+static void _outScanInfo(StringInfo str, const Scan *node) {
 	_outPlanInfo(str, (const Plan *) node);
 
 	WRITE_UINT_FIELD(scanrelid);
@@ -292,27 +282,20 @@ _outScanInfo(StringInfo str, const Scan *node)
 /*
  * print the basic stuff of all nodes that inherit from Join
  */
-static void
-_outJoinPlanInfo(StringInfo str, const Join *node)
-{
+static void _outJoinPlanInfo(StringInfo str, const Join *node) {
 	_outPlanInfo(str, (const Plan *) node);
 
 	WRITE_ENUM_FIELD(jointype, JoinType);
 	WRITE_NODE_FIELD(joinqual);
 }
 
-
-static void
-_outPlan(StringInfo str, const Plan *node)
-{
+static void _outPlan(StringInfo str, const Plan *node) {
 	WRITE_NODE_TYPE("PLAN");
 
 	_outPlanInfo(str, (const Plan *) node);
 }
 
-static void
-_outResult(StringInfo str, const Result *node)
-{
+static void _outResult(StringInfo str, const Result *node) {
 	WRITE_NODE_TYPE("RESULT");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -320,9 +303,7 @@ _outResult(StringInfo str, const Result *node)
 	WRITE_NODE_FIELD(resconstantqual);
 }
 
-static void
-_outModifyTable(StringInfo str, const ModifyTable *node)
-{
+static void _outModifyTable(StringInfo str, const ModifyTable *node) {
 	WRITE_NODE_TYPE("MODIFYTABLE");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -339,9 +320,7 @@ _outModifyTable(StringInfo str, const ModifyTable *node)
 	WRITE_INT_FIELD(epqParam);
 }
 
-static void
-_outAppend(StringInfo str, const Append *node)
-{
+static void _outAppend(StringInfo str, const Append *node) {
 	WRITE_NODE_TYPE("APPEND");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -349,10 +328,8 @@ _outAppend(StringInfo str, const Append *node)
 	WRITE_NODE_FIELD(appendplans);
 }
 
-static void
-_outMergeAppend(StringInfo str, const MergeAppend *node)
-{
-	int			i;
+static void _outMergeAppend(StringInfo str, const MergeAppend *node) {
+	int i;
 
 	WRITE_NODE_TYPE("MERGEAPPEND");
 
@@ -379,10 +356,8 @@ _outMergeAppend(StringInfo str, const MergeAppend *node)
 		appendStringInfo(str, " %s", booltostr(node->nullsFirst[i]));
 }
 
-static void
-_outRecursiveUnion(StringInfo str, const RecursiveUnion *node)
-{
-	int			i;
+static void _outRecursiveUnion(StringInfo str, const RecursiveUnion *node) {
+	int i;
 
 	WRITE_NODE_TYPE("RECURSIVEUNION");
 
@@ -402,9 +377,7 @@ _outRecursiveUnion(StringInfo str, const RecursiveUnion *node)
 	WRITE_LONG_FIELD(numGroups);
 }
 
-static void
-_outBitmapAnd(StringInfo str, const BitmapAnd *node)
-{
+static void _outBitmapAnd(StringInfo str, const BitmapAnd *node) {
 	WRITE_NODE_TYPE("BITMAPAND");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -412,9 +385,7 @@ _outBitmapAnd(StringInfo str, const BitmapAnd *node)
 	WRITE_NODE_FIELD(bitmapplans);
 }
 
-static void
-_outBitmapOr(StringInfo str, const BitmapOr *node)
-{
+static void _outBitmapOr(StringInfo str, const BitmapOr *node) {
 	WRITE_NODE_TYPE("BITMAPOR");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -422,25 +393,19 @@ _outBitmapOr(StringInfo str, const BitmapOr *node)
 	WRITE_NODE_FIELD(bitmapplans);
 }
 
-static void
-_outScan(StringInfo str, const Scan *node)
-{
+static void _outScan(StringInfo str, const Scan *node) {
 	WRITE_NODE_TYPE("SCAN");
 
 	_outScanInfo(str, node);
 }
 
-static void
-_outSeqScan(StringInfo str, const SeqScan *node)
-{
+static void _outSeqScan(StringInfo str, const SeqScan *node) {
 	WRITE_NODE_TYPE("SEQSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
 }
 
-static void
-_outIndexScan(StringInfo str, const IndexScan *node)
-{
+static void _outIndexScan(StringInfo str, const IndexScan *node) {
 	WRITE_NODE_TYPE("INDEXSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -453,9 +418,7 @@ _outIndexScan(StringInfo str, const IndexScan *node)
 	WRITE_ENUM_FIELD(indexorderdir, ScanDirection);
 }
 
-static void
-_outIndexOnlyScan(StringInfo str, const IndexOnlyScan *node)
-{
+static void _outIndexOnlyScan(StringInfo str, const IndexOnlyScan *node) {
 	WRITE_NODE_TYPE("INDEXONLYSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -467,9 +430,7 @@ _outIndexOnlyScan(StringInfo str, const IndexOnlyScan *node)
 	WRITE_ENUM_FIELD(indexorderdir, ScanDirection);
 }
 
-static void
-_outBitmapIndexScan(StringInfo str, const BitmapIndexScan *node)
-{
+static void _outBitmapIndexScan(StringInfo str, const BitmapIndexScan *node) {
 	WRITE_NODE_TYPE("BITMAPINDEXSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -479,9 +440,7 @@ _outBitmapIndexScan(StringInfo str, const BitmapIndexScan *node)
 	WRITE_NODE_FIELD(indexqualorig);
 }
 
-static void
-_outBitmapHeapScan(StringInfo str, const BitmapHeapScan *node)
-{
+static void _outBitmapHeapScan(StringInfo str, const BitmapHeapScan *node) {
 	WRITE_NODE_TYPE("BITMAPHEAPSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -489,9 +448,7 @@ _outBitmapHeapScan(StringInfo str, const BitmapHeapScan *node)
 	WRITE_NODE_FIELD(bitmapqualorig);
 }
 
-static void
-_outTidScan(StringInfo str, const TidScan *node)
-{
+static void _outTidScan(StringInfo str, const TidScan *node) {
 	WRITE_NODE_TYPE("TIDSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -499,9 +456,7 @@ _outTidScan(StringInfo str, const TidScan *node)
 	WRITE_NODE_FIELD(tidquals);
 }
 
-static void
-_outSubqueryScan(StringInfo str, const SubqueryScan *node)
-{
+static void _outSubqueryScan(StringInfo str, const SubqueryScan *node) {
 	WRITE_NODE_TYPE("SUBQUERYSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -509,9 +464,7 @@ _outSubqueryScan(StringInfo str, const SubqueryScan *node)
 	WRITE_NODE_FIELD(subplan);
 }
 
-static void
-_outFunctionScan(StringInfo str, const FunctionScan *node)
-{
+static void _outFunctionScan(StringInfo str, const FunctionScan *node) {
 	WRITE_NODE_TYPE("FUNCTIONSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -520,9 +473,7 @@ _outFunctionScan(StringInfo str, const FunctionScan *node)
 	WRITE_BOOL_FIELD(funcordinality);
 }
 
-static void
-_outValuesScan(StringInfo str, const ValuesScan *node)
-{
+static void _outValuesScan(StringInfo str, const ValuesScan *node) {
 	WRITE_NODE_TYPE("VALUESSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -530,9 +481,7 @@ _outValuesScan(StringInfo str, const ValuesScan *node)
 	WRITE_NODE_FIELD(values_lists);
 }
 
-static void
-_outCteScan(StringInfo str, const CteScan *node)
-{
+static void _outCteScan(StringInfo str, const CteScan *node) {
 	WRITE_NODE_TYPE("CTESCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -541,9 +490,7 @@ _outCteScan(StringInfo str, const CteScan *node)
 	WRITE_INT_FIELD(cteParam);
 }
 
-static void
-_outWorkTableScan(StringInfo str, const WorkTableScan *node)
-{
+static void _outWorkTableScan(StringInfo str, const WorkTableScan *node) {
 	WRITE_NODE_TYPE("WORKTABLESCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -551,9 +498,7 @@ _outWorkTableScan(StringInfo str, const WorkTableScan *node)
 	WRITE_INT_FIELD(wtParam);
 }
 
-static void
-_outForeignScan(StringInfo str, const ForeignScan *node)
-{
+static void _outForeignScan(StringInfo str, const ForeignScan *node) {
 	WRITE_NODE_TYPE("FOREIGNSCAN");
 
 	_outScanInfo(str, (const Scan *) node);
@@ -563,17 +508,13 @@ _outForeignScan(StringInfo str, const ForeignScan *node)
 	WRITE_BOOL_FIELD(fsSystemCol);
 }
 
-static void
-_outJoin(StringInfo str, const Join *node)
-{
+static void _outJoin(StringInfo str, const Join *node) {
 	WRITE_NODE_TYPE("JOIN");
 
 	_outJoinPlanInfo(str, (const Join *) node);
 }
 
-static void
-_outNestLoop(StringInfo str, const NestLoop *node)
-{
+static void _outNestLoop(StringInfo str, const NestLoop *node) {
 	WRITE_NODE_TYPE("NESTLOOP");
 
 	_outJoinPlanInfo(str, (const Join *) node);
@@ -581,11 +522,9 @@ _outNestLoop(StringInfo str, const NestLoop *node)
 	WRITE_NODE_FIELD(nestParams);
 }
 
-static void
-_outMergeJoin(StringInfo str, const MergeJoin *node)
-{
-	int			numCols;
-	int			i;
+static void _outMergeJoin(StringInfo str, const MergeJoin *node) {
+	int numCols;
+	int i;
 
 	WRITE_NODE_TYPE("MERGEJOIN");
 
@@ -612,9 +551,7 @@ _outMergeJoin(StringInfo str, const MergeJoin *node)
 		appendStringInfo(str, " %d", (int) node->mergeNullsFirst[i]);
 }
 
-static void
-_outHashJoin(StringInfo str, const HashJoin *node)
-{
+static void _outHashJoin(StringInfo str, const HashJoin *node) {
 	WRITE_NODE_TYPE("HASHJOIN");
 
 	_outJoinPlanInfo(str, (const Join *) node);
@@ -622,10 +559,8 @@ _outHashJoin(StringInfo str, const HashJoin *node)
 	WRITE_NODE_FIELD(hashclauses);
 }
 
-static void
-_outAgg(StringInfo str, const Agg *node)
-{
-	int			i;
+static void _outAgg(StringInfo str, const Agg *node) {
+	int i;
 
 	WRITE_NODE_TYPE("AGG");
 
@@ -645,10 +580,8 @@ _outAgg(StringInfo str, const Agg *node)
 	WRITE_LONG_FIELD(numGroups);
 }
 
-static void
-_outWindowAgg(StringInfo str, const WindowAgg *node)
-{
-	int			i;
+static void _outWindowAgg(StringInfo str, const WindowAgg *node) {
+	int i;
 
 	WRITE_NODE_TYPE("WINDOWAGG");
 
@@ -680,10 +613,8 @@ _outWindowAgg(StringInfo str, const WindowAgg *node)
 	WRITE_NODE_FIELD(endOffset);
 }
 
-static void
-_outGroup(StringInfo str, const Group *node)
-{
-	int			i;
+static void _outGroup(StringInfo str, const Group *node) {
+	int i;
 
 	WRITE_NODE_TYPE("GROUP");
 
@@ -700,18 +631,14 @@ _outGroup(StringInfo str, const Group *node)
 		appendStringInfo(str, " %u", node->grpOperators[i]);
 }
 
-static void
-_outMaterial(StringInfo str, const Material *node)
-{
+static void _outMaterial(StringInfo str, const Material *node) {
 	WRITE_NODE_TYPE("MATERIAL");
 
 	_outPlanInfo(str, (const Plan *) node);
 }
 
-static void
-_outSort(StringInfo str, const Sort *node)
-{
-	int			i;
+static void _outSort(StringInfo str, const Sort *node) {
+	int i;
 
 	WRITE_NODE_TYPE("SORT");
 
@@ -736,10 +663,8 @@ _outSort(StringInfo str, const Sort *node)
 		appendStringInfo(str, " %s", booltostr(node->nullsFirst[i]));
 }
 
-static void
-_outUnique(StringInfo str, const Unique *node)
-{
-	int			i;
+static void _outUnique(StringInfo str, const Unique *node) {
+	int i;
 
 	WRITE_NODE_TYPE("UNIQUE");
 
@@ -756,9 +681,7 @@ _outUnique(StringInfo str, const Unique *node)
 		appendStringInfo(str, " %u", node->uniqOperators[i]);
 }
 
-static void
-_outHash(StringInfo str, const Hash *node)
-{
+static void _outHash(StringInfo str, const Hash *node) {
 	WRITE_NODE_TYPE("HASH");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -770,10 +693,8 @@ _outHash(StringInfo str, const Hash *node)
 	WRITE_INT_FIELD(skewColTypmod);
 }
 
-static void
-_outSetOp(StringInfo str, const SetOp *node)
-{
-	int			i;
+static void _outSetOp(StringInfo str, const SetOp *node) {
+	int i;
 
 	WRITE_NODE_TYPE("SETOP");
 
@@ -796,9 +717,7 @@ _outSetOp(StringInfo str, const SetOp *node)
 	WRITE_LONG_FIELD(numGroups);
 }
 
-static void
-_outLockRows(StringInfo str, const LockRows *node)
-{
+static void _outLockRows(StringInfo str, const LockRows *node) {
 	WRITE_NODE_TYPE("LOCKROWS");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -807,9 +726,7 @@ _outLockRows(StringInfo str, const LockRows *node)
 	WRITE_INT_FIELD(epqParam);
 }
 
-static void
-_outLimit(StringInfo str, const Limit *node)
-{
+static void _outLimit(StringInfo str, const Limit *node) {
 	WRITE_NODE_TYPE("LIMIT");
 
 	_outPlanInfo(str, (const Plan *) node);
@@ -818,18 +735,14 @@ _outLimit(StringInfo str, const Limit *node)
 	WRITE_NODE_FIELD(limitCount);
 }
 
-static void
-_outNestLoopParam(StringInfo str, const NestLoopParam *node)
-{
+static void _outNestLoopParam(StringInfo str, const NestLoopParam *node) {
 	WRITE_NODE_TYPE("NESTLOOPPARAM");
 
 	WRITE_INT_FIELD(paramno);
 	WRITE_NODE_FIELD(paramval);
 }
 
-static void
-_outPlanRowMark(StringInfo str, const PlanRowMark *node)
-{
+static void _outPlanRowMark(StringInfo str, const PlanRowMark *node) {
 	WRITE_NODE_TYPE("PLANROWMARK");
 
 	WRITE_UINT_FIELD(rti);
@@ -840,9 +753,7 @@ _outPlanRowMark(StringInfo str, const PlanRowMark *node)
 	WRITE_BOOL_FIELD(isParent);
 }
 
-static void
-_outPlanInvalItem(StringInfo str, const PlanInvalItem *node)
-{
+static void _outPlanInvalItem(StringInfo str, const PlanInvalItem *node) {
 	WRITE_NODE_TYPE("PLANINVALITEM");
 
 	WRITE_INT_FIELD(cacheId);
@@ -855,18 +766,14 @@ _outPlanInvalItem(StringInfo str, const PlanInvalItem *node)
  *
  *****************************************************************************/
 
-static void
-_outAlias(StringInfo str, const Alias *node)
-{
+static void _outAlias(StringInfo str, const Alias *node) {
 	WRITE_NODE_TYPE("ALIAS");
 
 	WRITE_STRING_FIELD(aliasname);
 	WRITE_NODE_FIELD(colnames);
 }
 
-static void
-_outRangeVar(StringInfo str, const RangeVar *node)
-{
+static void _outRangeVar(StringInfo str, const RangeVar *node) {
 	WRITE_NODE_TYPE("RANGEVAR");
 
 	/*
@@ -881,9 +788,7 @@ _outRangeVar(StringInfo str, const RangeVar *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outIntoClause(StringInfo str, const IntoClause *node)
-{
+static void _outIntoClause(StringInfo str, const IntoClause *node) {
 	WRITE_NODE_TYPE("INTOCLAUSE");
 
 	WRITE_NODE_FIELD(rel);
@@ -895,9 +800,7 @@ _outIntoClause(StringInfo str, const IntoClause *node)
 	WRITE_BOOL_FIELD(skipData);
 }
 
-static void
-_outVar(StringInfo str, const Var *node)
-{
+static void _outVar(StringInfo str, const Var *node) {
 	WRITE_NODE_TYPE("VAR");
 
 	WRITE_UINT_FIELD(varno);
@@ -911,9 +814,7 @@ _outVar(StringInfo str, const Var *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outConst(StringInfo str, const Const *node)
-{
+static void _outConst(StringInfo str, const Const *node) {
 	WRITE_NODE_TYPE("CONST");
 
 	WRITE_OID_FIELD(consttype);
@@ -931,9 +832,7 @@ _outConst(StringInfo str, const Const *node)
 		_outDatum(str, node->constvalue, node->constlen, node->constbyval);
 }
 
-static void
-_outParam(StringInfo str, const Param *node)
-{
+static void _outParam(StringInfo str, const Param *node) {
 	WRITE_NODE_TYPE("PARAM");
 
 	WRITE_ENUM_FIELD(paramkind, ParamKind);
@@ -944,9 +843,7 @@ _outParam(StringInfo str, const Param *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outAggref(StringInfo str, const Aggref *node)
-{
+static void _outAggref(StringInfo str, const Aggref *node) {
 	WRITE_NODE_TYPE("AGGREF");
 
 	WRITE_OID_FIELD(aggfnoid);
@@ -965,9 +862,7 @@ _outAggref(StringInfo str, const Aggref *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outWindowFunc(StringInfo str, const WindowFunc *node)
-{
+static void _outWindowFunc(StringInfo str, const WindowFunc *node) {
 	WRITE_NODE_TYPE("WINDOWFUNC");
 
 	WRITE_OID_FIELD(winfnoid);
@@ -982,9 +877,7 @@ _outWindowFunc(StringInfo str, const WindowFunc *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outArrayRef(StringInfo str, const ArrayRef *node)
-{
+static void _outArrayRef(StringInfo str, const ArrayRef *node) {
 	WRITE_NODE_TYPE("ARRAYREF");
 
 	WRITE_OID_FIELD(refarraytype);
@@ -997,9 +890,7 @@ _outArrayRef(StringInfo str, const ArrayRef *node)
 	WRITE_NODE_FIELD(refassgnexpr);
 }
 
-static void
-_outFuncExpr(StringInfo str, const FuncExpr *node)
-{
+static void _outFuncExpr(StringInfo str, const FuncExpr *node) {
 	WRITE_NODE_TYPE("FUNCEXPR");
 
 	WRITE_OID_FIELD(funcid);
@@ -1013,9 +904,7 @@ _outFuncExpr(StringInfo str, const FuncExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outNamedArgExpr(StringInfo str, const NamedArgExpr *node)
-{
+static void _outNamedArgExpr(StringInfo str, const NamedArgExpr *node) {
 	WRITE_NODE_TYPE("NAMEDARGEXPR");
 
 	WRITE_NODE_FIELD(arg);
@@ -1024,9 +913,7 @@ _outNamedArgExpr(StringInfo str, const NamedArgExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outOpExpr(StringInfo str, const OpExpr *node)
-{
+static void _outOpExpr(StringInfo str, const OpExpr *node) {
 	WRITE_NODE_TYPE("OPEXPR");
 
 	WRITE_OID_FIELD(opno);
@@ -1039,9 +926,7 @@ _outOpExpr(StringInfo str, const OpExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outDistinctExpr(StringInfo str, const DistinctExpr *node)
-{
+static void _outDistinctExpr(StringInfo str, const DistinctExpr *node) {
 	WRITE_NODE_TYPE("DISTINCTEXPR");
 
 	WRITE_OID_FIELD(opno);
@@ -1054,9 +939,7 @@ _outDistinctExpr(StringInfo str, const DistinctExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outNullIfExpr(StringInfo str, const NullIfExpr *node)
-{
+static void _outNullIfExpr(StringInfo str, const NullIfExpr *node) {
 	WRITE_NODE_TYPE("NULLIFEXPR");
 
 	WRITE_OID_FIELD(opno);
@@ -1069,9 +952,7 @@ _outNullIfExpr(StringInfo str, const NullIfExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outScalarArrayOpExpr(StringInfo str, const ScalarArrayOpExpr *node)
-{
+static void _outScalarArrayOpExpr(StringInfo str, const ScalarArrayOpExpr *node) {
 	WRITE_NODE_TYPE("SCALARARRAYOPEXPR");
 
 	WRITE_OID_FIELD(opno);
@@ -1082,25 +963,22 @@ _outScalarArrayOpExpr(StringInfo str, const ScalarArrayOpExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outBoolExpr(StringInfo str, const BoolExpr *node)
-{
-	char	   *opstr = NULL;
+static void _outBoolExpr(StringInfo str, const BoolExpr *node) {
+	char *opstr = NULL;
 
 	WRITE_NODE_TYPE("BOOLEXPR");
 
 	/* do-it-yourself enum representation */
-	switch (node->boolop)
-	{
-		case AND_EXPR:
-			opstr = "and";
-			break;
-		case OR_EXPR:
-			opstr = "or";
-			break;
-		case NOT_EXPR:
-			opstr = "not";
-			break;
+	switch (node->boolop) {
+	case AND_EXPR:
+		opstr = "and";
+		break;
+	case OR_EXPR:
+		opstr = "or";
+		break;
+	case NOT_EXPR:
+		opstr = "not";
+		break;
 	}
 	appendStringInfoString(str, " :boolop ");
 	_outToken(str, opstr);
@@ -1109,9 +987,7 @@ _outBoolExpr(StringInfo str, const BoolExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outSubLink(StringInfo str, const SubLink *node)
-{
+static void _outSubLink(StringInfo str, const SubLink *node) {
 	WRITE_NODE_TYPE("SUBLINK");
 
 	WRITE_ENUM_FIELD(subLinkType, SubLinkType);
@@ -1121,9 +997,7 @@ _outSubLink(StringInfo str, const SubLink *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outSubPlan(StringInfo str, const SubPlan *node)
-{
+static void _outSubPlan(StringInfo str, const SubPlan *node) {
 	WRITE_NODE_TYPE("SUBPLAN");
 
 	WRITE_ENUM_FIELD(subLinkType, SubLinkType);
@@ -1143,17 +1017,14 @@ _outSubPlan(StringInfo str, const SubPlan *node)
 	WRITE_FLOAT_FIELD(per_call_cost, "%.2f");
 }
 
-static void
-_outAlternativeSubPlan(StringInfo str, const AlternativeSubPlan *node)
-{
+static void _outAlternativeSubPlan(StringInfo str,
+		const AlternativeSubPlan *node) {
 	WRITE_NODE_TYPE("ALTERNATIVESUBPLAN");
 
 	WRITE_NODE_FIELD(subplans);
 }
 
-static void
-_outFieldSelect(StringInfo str, const FieldSelect *node)
-{
+static void _outFieldSelect(StringInfo str, const FieldSelect *node) {
 	WRITE_NODE_TYPE("FIELDSELECT");
 
 	WRITE_NODE_FIELD(arg);
@@ -1163,9 +1034,7 @@ _outFieldSelect(StringInfo str, const FieldSelect *node)
 	WRITE_OID_FIELD(resultcollid);
 }
 
-static void
-_outFieldStore(StringInfo str, const FieldStore *node)
-{
+static void _outFieldStore(StringInfo str, const FieldStore *node) {
 	WRITE_NODE_TYPE("FIELDSTORE");
 
 	WRITE_NODE_FIELD(arg);
@@ -1174,9 +1043,7 @@ _outFieldStore(StringInfo str, const FieldStore *node)
 	WRITE_OID_FIELD(resulttype);
 }
 
-static void
-_outRelabelType(StringInfo str, const RelabelType *node)
-{
+static void _outRelabelType(StringInfo str, const RelabelType *node) {
 	WRITE_NODE_TYPE("RELABELTYPE");
 
 	WRITE_NODE_FIELD(arg);
@@ -1187,9 +1054,7 @@ _outRelabelType(StringInfo str, const RelabelType *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCoerceViaIO(StringInfo str, const CoerceViaIO *node)
-{
+static void _outCoerceViaIO(StringInfo str, const CoerceViaIO *node) {
 	WRITE_NODE_TYPE("COERCEVIAIO");
 
 	WRITE_NODE_FIELD(arg);
@@ -1199,9 +1064,7 @@ _outCoerceViaIO(StringInfo str, const CoerceViaIO *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outArrayCoerceExpr(StringInfo str, const ArrayCoerceExpr *node)
-{
+static void _outArrayCoerceExpr(StringInfo str, const ArrayCoerceExpr *node) {
 	WRITE_NODE_TYPE("ARRAYCOERCEEXPR");
 
 	WRITE_NODE_FIELD(arg);
@@ -1214,9 +1077,8 @@ _outArrayCoerceExpr(StringInfo str, const ArrayCoerceExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outConvertRowtypeExpr(StringInfo str, const ConvertRowtypeExpr *node)
-{
+static void _outConvertRowtypeExpr(StringInfo str,
+		const ConvertRowtypeExpr *node) {
 	WRITE_NODE_TYPE("CONVERTROWTYPEEXPR");
 
 	WRITE_NODE_FIELD(arg);
@@ -1225,9 +1087,7 @@ _outConvertRowtypeExpr(StringInfo str, const ConvertRowtypeExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCollateExpr(StringInfo str, const CollateExpr *node)
-{
+static void _outCollateExpr(StringInfo str, const CollateExpr *node) {
 	WRITE_NODE_TYPE("COLLATE");
 
 	WRITE_NODE_FIELD(arg);
@@ -1235,9 +1095,7 @@ _outCollateExpr(StringInfo str, const CollateExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCaseExpr(StringInfo str, const CaseExpr *node)
-{
+static void _outCaseExpr(StringInfo str, const CaseExpr *node) {
 	WRITE_NODE_TYPE("CASE");
 
 	WRITE_OID_FIELD(casetype);
@@ -1248,9 +1106,7 @@ _outCaseExpr(StringInfo str, const CaseExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCaseWhen(StringInfo str, const CaseWhen *node)
-{
+static void _outCaseWhen(StringInfo str, const CaseWhen *node) {
 	WRITE_NODE_TYPE("WHEN");
 
 	WRITE_NODE_FIELD(expr);
@@ -1258,9 +1114,7 @@ _outCaseWhen(StringInfo str, const CaseWhen *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCaseTestExpr(StringInfo str, const CaseTestExpr *node)
-{
+static void _outCaseTestExpr(StringInfo str, const CaseTestExpr *node) {
 	WRITE_NODE_TYPE("CASETESTEXPR");
 
 	WRITE_OID_FIELD(typeId);
@@ -1268,9 +1122,7 @@ _outCaseTestExpr(StringInfo str, const CaseTestExpr *node)
 	WRITE_OID_FIELD(collation);
 }
 
-static void
-_outArrayExpr(StringInfo str, const ArrayExpr *node)
-{
+static void _outArrayExpr(StringInfo str, const ArrayExpr *node) {
 	WRITE_NODE_TYPE("ARRAY");
 
 	WRITE_OID_FIELD(array_typeid);
@@ -1281,9 +1133,7 @@ _outArrayExpr(StringInfo str, const ArrayExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outRowExpr(StringInfo str, const RowExpr *node)
-{
+static void _outRowExpr(StringInfo str, const RowExpr *node) {
 	WRITE_NODE_TYPE("ROW");
 
 	WRITE_NODE_FIELD(args);
@@ -1293,9 +1143,7 @@ _outRowExpr(StringInfo str, const RowExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outRowCompareExpr(StringInfo str, const RowCompareExpr *node)
-{
+static void _outRowCompareExpr(StringInfo str, const RowCompareExpr *node) {
 	WRITE_NODE_TYPE("ROWCOMPARE");
 
 	WRITE_ENUM_FIELD(rctype, RowCompareType);
@@ -1306,9 +1154,7 @@ _outRowCompareExpr(StringInfo str, const RowCompareExpr *node)
 	WRITE_NODE_FIELD(rargs);
 }
 
-static void
-_outCoalesceExpr(StringInfo str, const CoalesceExpr *node)
-{
+static void _outCoalesceExpr(StringInfo str, const CoalesceExpr *node) {
 	WRITE_NODE_TYPE("COALESCE");
 
 	WRITE_OID_FIELD(coalescetype);
@@ -1317,9 +1163,7 @@ _outCoalesceExpr(StringInfo str, const CoalesceExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outMinMaxExpr(StringInfo str, const MinMaxExpr *node)
-{
+static void _outMinMaxExpr(StringInfo str, const MinMaxExpr *node) {
 	WRITE_NODE_TYPE("MINMAX");
 
 	WRITE_OID_FIELD(minmaxtype);
@@ -1330,9 +1174,7 @@ _outMinMaxExpr(StringInfo str, const MinMaxExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outXmlExpr(StringInfo str, const XmlExpr *node)
-{
+static void _outXmlExpr(StringInfo str, const XmlExpr *node) {
 	WRITE_NODE_TYPE("XMLEXPR");
 
 	WRITE_ENUM_FIELD(op, XmlExprOp);
@@ -1346,9 +1188,7 @@ _outXmlExpr(StringInfo str, const XmlExpr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outNullTest(StringInfo str, const NullTest *node)
-{
+static void _outNullTest(StringInfo str, const NullTest *node) {
 	WRITE_NODE_TYPE("NULLTEST");
 
 	WRITE_NODE_FIELD(arg);
@@ -1356,18 +1196,14 @@ _outNullTest(StringInfo str, const NullTest *node)
 	WRITE_BOOL_FIELD(argisrow);
 }
 
-static void
-_outBooleanTest(StringInfo str, const BooleanTest *node)
-{
+static void _outBooleanTest(StringInfo str, const BooleanTest *node) {
 	WRITE_NODE_TYPE("BOOLEANTEST");
 
 	WRITE_NODE_FIELD(arg);
 	WRITE_ENUM_FIELD(booltesttype, BoolTestType);
 }
 
-static void
-_outCoerceToDomain(StringInfo str, const CoerceToDomain *node)
-{
+static void _outCoerceToDomain(StringInfo str, const CoerceToDomain *node) {
 	WRITE_NODE_TYPE("COERCETODOMAIN");
 
 	WRITE_NODE_FIELD(arg);
@@ -1378,9 +1214,8 @@ _outCoerceToDomain(StringInfo str, const CoerceToDomain *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCoerceToDomainValue(StringInfo str, const CoerceToDomainValue *node)
-{
+static void _outCoerceToDomainValue(StringInfo str,
+		const CoerceToDomainValue *node) {
 	WRITE_NODE_TYPE("COERCETODOMAINVALUE");
 
 	WRITE_OID_FIELD(typeId);
@@ -1389,9 +1224,7 @@ _outCoerceToDomainValue(StringInfo str, const CoerceToDomainValue *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outSetToDefault(StringInfo str, const SetToDefault *node)
-{
+static void _outSetToDefault(StringInfo str, const SetToDefault *node) {
 	WRITE_NODE_TYPE("SETTODEFAULT");
 
 	WRITE_OID_FIELD(typeId);
@@ -1400,9 +1233,7 @@ _outSetToDefault(StringInfo str, const SetToDefault *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCurrentOfExpr(StringInfo str, const CurrentOfExpr *node)
-{
+static void _outCurrentOfExpr(StringInfo str, const CurrentOfExpr *node) {
 	WRITE_NODE_TYPE("CURRENTOFEXPR");
 
 	WRITE_UINT_FIELD(cvarno);
@@ -1410,9 +1241,7 @@ _outCurrentOfExpr(StringInfo str, const CurrentOfExpr *node)
 	WRITE_INT_FIELD(cursor_param);
 }
 
-static void
-_outTargetEntry(StringInfo str, const TargetEntry *node)
-{
+static void _outTargetEntry(StringInfo str, const TargetEntry *node) {
 	WRITE_NODE_TYPE("TARGETENTRY");
 
 	WRITE_NODE_FIELD(expr);
@@ -1424,17 +1253,13 @@ _outTargetEntry(StringInfo str, const TargetEntry *node)
 	WRITE_BOOL_FIELD(resjunk);
 }
 
-static void
-_outRangeTblRef(StringInfo str, const RangeTblRef *node)
-{
+static void _outRangeTblRef(StringInfo str, const RangeTblRef *node) {
 	WRITE_NODE_TYPE("RANGETBLREF");
 
 	WRITE_INT_FIELD(rtindex);
 }
 
-static void
-_outJoinExpr(StringInfo str, const JoinExpr *node)
-{
+static void _outJoinExpr(StringInfo str, const JoinExpr *node) {
 	WRITE_NODE_TYPE("JOINEXPR");
 
 	WRITE_ENUM_FIELD(jointype, JoinType);
@@ -1447,9 +1272,7 @@ _outJoinExpr(StringInfo str, const JoinExpr *node)
 	WRITE_INT_FIELD(rtindex);
 }
 
-static void
-_outFromExpr(StringInfo str, const FromExpr *node)
-{
+static void _outFromExpr(StringInfo str, const FromExpr *node) {
 	WRITE_NODE_TYPE("FROMEXPR");
 
 	WRITE_NODE_FIELD(fromlist);
@@ -1471,9 +1294,7 @@ _outFromExpr(StringInfo str, const FromExpr *node)
  * _outRelOptInfo; it's sufficient and less cluttering to print just the
  * required outer relids.
  */
-static void
-_outPathInfo(StringInfo str, const Path *node)
-{
+static void _outPathInfo(StringInfo str, const Path *node) {
 	WRITE_ENUM_FIELD(pathtype, NodeTag);
 	appendStringInfoString(str, " :parent_relids ");
 	_outBitmapset(str, node->parent->relids);
@@ -1491,9 +1312,7 @@ _outPathInfo(StringInfo str, const Path *node)
 /*
  * print the basic stuff of all nodes that inherit from JoinPath
  */
-static void
-_outJoinPathInfo(StringInfo str, const JoinPath *node)
-{
+static void _outJoinPathInfo(StringInfo str, const JoinPath *node) {
 	_outPathInfo(str, (const Path *) node);
 
 	WRITE_ENUM_FIELD(jointype, JoinType);
@@ -1502,17 +1321,13 @@ _outJoinPathInfo(StringInfo str, const JoinPath *node)
 	WRITE_NODE_FIELD(joinrestrictinfo);
 }
 
-static void
-_outPath(StringInfo str, const Path *node)
-{
+static void _outPath(StringInfo str, const Path *node) {
 	WRITE_NODE_TYPE("PATH");
 
 	_outPathInfo(str, (const Path *) node);
 }
 
-static void
-_outIndexPath(StringInfo str, const IndexPath *node)
-{
+static void _outIndexPath(StringInfo str, const IndexPath *node) {
 	WRITE_NODE_TYPE("INDEXPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1528,9 +1343,7 @@ _outIndexPath(StringInfo str, const IndexPath *node)
 	WRITE_FLOAT_FIELD(indexselectivity, "%.4f");
 }
 
-static void
-_outBitmapHeapPath(StringInfo str, const BitmapHeapPath *node)
-{
+static void _outBitmapHeapPath(StringInfo str, const BitmapHeapPath *node) {
 	WRITE_NODE_TYPE("BITMAPHEAPPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1538,9 +1351,7 @@ _outBitmapHeapPath(StringInfo str, const BitmapHeapPath *node)
 	WRITE_NODE_FIELD(bitmapqual);
 }
 
-static void
-_outBitmapAndPath(StringInfo str, const BitmapAndPath *node)
-{
+static void _outBitmapAndPath(StringInfo str, const BitmapAndPath *node) {
 	WRITE_NODE_TYPE("BITMAPANDPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1549,9 +1360,7 @@ _outBitmapAndPath(StringInfo str, const BitmapAndPath *node)
 	WRITE_FLOAT_FIELD(bitmapselectivity, "%.4f");
 }
 
-static void
-_outBitmapOrPath(StringInfo str, const BitmapOrPath *node)
-{
+static void _outBitmapOrPath(StringInfo str, const BitmapOrPath *node) {
 	WRITE_NODE_TYPE("BITMAPORPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1560,9 +1369,7 @@ _outBitmapOrPath(StringInfo str, const BitmapOrPath *node)
 	WRITE_FLOAT_FIELD(bitmapselectivity, "%.4f");
 }
 
-static void
-_outTidPath(StringInfo str, const TidPath *node)
-{
+static void _outTidPath(StringInfo str, const TidPath *node) {
 	WRITE_NODE_TYPE("TIDPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1570,9 +1377,7 @@ _outTidPath(StringInfo str, const TidPath *node)
 	WRITE_NODE_FIELD(tidquals);
 }
 
-static void
-_outForeignPath(StringInfo str, const ForeignPath *node)
-{
+static void _outForeignPath(StringInfo str, const ForeignPath *node) {
 	WRITE_NODE_TYPE("FOREIGNPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1580,9 +1385,7 @@ _outForeignPath(StringInfo str, const ForeignPath *node)
 	WRITE_NODE_FIELD(fdw_private);
 }
 
-static void
-_outAppendPath(StringInfo str, const AppendPath *node)
-{
+static void _outAppendPath(StringInfo str, const AppendPath *node) {
 	WRITE_NODE_TYPE("APPENDPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1590,9 +1393,7 @@ _outAppendPath(StringInfo str, const AppendPath *node)
 	WRITE_NODE_FIELD(subpaths);
 }
 
-static void
-_outMergeAppendPath(StringInfo str, const MergeAppendPath *node)
-{
+static void _outMergeAppendPath(StringInfo str, const MergeAppendPath *node) {
 	WRITE_NODE_TYPE("MERGEAPPENDPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1601,9 +1402,7 @@ _outMergeAppendPath(StringInfo str, const MergeAppendPath *node)
 	WRITE_FLOAT_FIELD(limit_tuples, "%.0f");
 }
 
-static void
-_outResultPath(StringInfo str, const ResultPath *node)
-{
+static void _outResultPath(StringInfo str, const ResultPath *node) {
 	WRITE_NODE_TYPE("RESULTPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1611,9 +1410,7 @@ _outResultPath(StringInfo str, const ResultPath *node)
 	WRITE_NODE_FIELD(quals);
 }
 
-static void
-_outMaterialPath(StringInfo str, const MaterialPath *node)
-{
+static void _outMaterialPath(StringInfo str, const MaterialPath *node) {
 	WRITE_NODE_TYPE("MATERIALPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1621,9 +1418,7 @@ _outMaterialPath(StringInfo str, const MaterialPath *node)
 	WRITE_NODE_FIELD(subpath);
 }
 
-static void
-_outUniquePath(StringInfo str, const UniquePath *node)
-{
+static void _outUniquePath(StringInfo str, const UniquePath *node) {
 	WRITE_NODE_TYPE("UNIQUEPATH");
 
 	_outPathInfo(str, (const Path *) node);
@@ -1634,17 +1429,13 @@ _outUniquePath(StringInfo str, const UniquePath *node)
 	WRITE_NODE_FIELD(uniq_exprs);
 }
 
-static void
-_outNestPath(StringInfo str, const NestPath *node)
-{
+static void _outNestPath(StringInfo str, const NestPath *node) {
 	WRITE_NODE_TYPE("NESTPATH");
 
 	_outJoinPathInfo(str, (const JoinPath *) node);
 }
 
-static void
-_outMergePath(StringInfo str, const MergePath *node)
-{
+static void _outMergePath(StringInfo str, const MergePath *node) {
 	WRITE_NODE_TYPE("MERGEPATH");
 
 	_outJoinPathInfo(str, (const JoinPath *) node);
@@ -1655,9 +1446,7 @@ _outMergePath(StringInfo str, const MergePath *node)
 	WRITE_BOOL_FIELD(materialize_inner);
 }
 
-static void
-_outHashPath(StringInfo str, const HashPath *node)
-{
+static void _outHashPath(StringInfo str, const HashPath *node) {
 	WRITE_NODE_TYPE("HASHPATH");
 
 	_outJoinPathInfo(str, (const JoinPath *) node);
@@ -1666,9 +1455,7 @@ _outHashPath(StringInfo str, const HashPath *node)
 	WRITE_INT_FIELD(num_batches);
 }
 
-static void
-_outPlannerGlobal(StringInfo str, const PlannerGlobal *node)
-{
+static void _outPlannerGlobal(StringInfo str, const PlannerGlobal *node) {
 	WRITE_NODE_TYPE("PLANNERGLOBAL");
 
 	/* NB: this isn't a complete set of fields */
@@ -1685,9 +1472,7 @@ _outPlannerGlobal(StringInfo str, const PlannerGlobal *node)
 	WRITE_BOOL_FIELD(transientPlan);
 }
 
-static void
-_outPlannerInfo(StringInfo str, const PlannerInfo *node)
-{
+static void _outPlannerInfo(StringInfo str, const PlannerInfo *node) {
 	WRITE_NODE_TYPE("PLANNERINFO");
 
 	/* NB: this isn't a complete set of fields */
@@ -1731,9 +1516,7 @@ _outPlannerInfo(StringInfo str, const PlannerInfo *node)
 	WRITE_NODE_FIELD(curOuterParams);
 }
 
-static void
-_outRelOptInfo(StringInfo str, const RelOptInfo *node)
-{
+static void _outRelOptInfo(StringInfo str, const RelOptInfo *node) {
 	WRITE_NODE_TYPE("RELOPTINFO");
 
 	/* NB: this isn't a complete set of fields */
@@ -1770,9 +1553,7 @@ _outRelOptInfo(StringInfo str, const RelOptInfo *node)
 	WRITE_BOOL_FIELD(has_eclass_joins);
 }
 
-static void
-_outIndexOptInfo(StringInfo str, const IndexOptInfo *node)
-{
+static void _outIndexOptInfo(StringInfo str, const IndexOptInfo *node) {
 	WRITE_NODE_TYPE("INDEXOPTINFO");
 
 	/* NB: this isn't a complete set of fields */
@@ -1794,9 +1575,7 @@ _outIndexOptInfo(StringInfo str, const IndexOptInfo *node)
 	/* we don't bother with fields copied from the pg_am entry */
 }
 
-static void
-_outEquivalenceClass(StringInfo str, const EquivalenceClass *node)
-{
+static void _outEquivalenceClass(StringInfo str, const EquivalenceClass *node) {
 	/*
 	 * To simplify reading, we just chase up to the topmost merged EC and
 	 * print that, without bothering to show the merge-ees separately.
@@ -1819,9 +1598,7 @@ _outEquivalenceClass(StringInfo str, const EquivalenceClass *node)
 	WRITE_UINT_FIELD(ec_sortref);
 }
 
-static void
-_outEquivalenceMember(StringInfo str, const EquivalenceMember *node)
-{
+static void _outEquivalenceMember(StringInfo str, const EquivalenceMember *node) {
 	WRITE_NODE_TYPE("EQUIVALENCEMEMBER");
 
 	WRITE_NODE_FIELD(em_expr);
@@ -1832,9 +1609,7 @@ _outEquivalenceMember(StringInfo str, const EquivalenceMember *node)
 	WRITE_OID_FIELD(em_datatype);
 }
 
-static void
-_outPathKey(StringInfo str, const PathKey *node)
-{
+static void _outPathKey(StringInfo str, const PathKey *node) {
 	WRITE_NODE_TYPE("PATHKEY");
 
 	WRITE_NODE_FIELD(pk_eclass);
@@ -1843,9 +1618,7 @@ _outPathKey(StringInfo str, const PathKey *node)
 	WRITE_BOOL_FIELD(pk_nulls_first);
 }
 
-static void
-_outParamPathInfo(StringInfo str, const ParamPathInfo *node)
-{
+static void _outParamPathInfo(StringInfo str, const ParamPathInfo *node) {
 	WRITE_NODE_TYPE("PARAMPATHINFO");
 
 	WRITE_BITMAPSET_FIELD(ppi_req_outer);
@@ -1853,9 +1626,7 @@ _outParamPathInfo(StringInfo str, const ParamPathInfo *node)
 	WRITE_NODE_FIELD(ppi_clauses);
 }
 
-static void
-_outRestrictInfo(StringInfo str, const RestrictInfo *node)
-{
+static void _outRestrictInfo(StringInfo str, const RestrictInfo *node) {
 	WRITE_NODE_TYPE("RESTRICTINFO");
 
 	/* NB: this isn't a complete set of fields */
@@ -1883,9 +1654,7 @@ _outRestrictInfo(StringInfo str, const RestrictInfo *node)
 	WRITE_OID_FIELD(hashjoinoperator);
 }
 
-static void
-_outPlaceHolderVar(StringInfo str, const PlaceHolderVar *node)
-{
+static void _outPlaceHolderVar(StringInfo str, const PlaceHolderVar *node) {
 	WRITE_NODE_TYPE("PLACEHOLDERVAR");
 
 	WRITE_NODE_FIELD(phexpr);
@@ -1894,9 +1663,7 @@ _outPlaceHolderVar(StringInfo str, const PlaceHolderVar *node)
 	WRITE_UINT_FIELD(phlevelsup);
 }
 
-static void
-_outSpecialJoinInfo(StringInfo str, const SpecialJoinInfo *node)
-{
+static void _outSpecialJoinInfo(StringInfo str, const SpecialJoinInfo *node) {
 	WRITE_NODE_TYPE("SPECIALJOININFO");
 
 	WRITE_BITMAPSET_FIELD(min_lefthand);
@@ -1909,18 +1676,14 @@ _outSpecialJoinInfo(StringInfo str, const SpecialJoinInfo *node)
 	WRITE_NODE_FIELD(join_quals);
 }
 
-static void
-_outLateralJoinInfo(StringInfo str, const LateralJoinInfo *node)
-{
+static void _outLateralJoinInfo(StringInfo str, const LateralJoinInfo *node) {
 	WRITE_NODE_TYPE("LATERALJOININFO");
 
 	WRITE_BITMAPSET_FIELD(lateral_lhs);
 	WRITE_BITMAPSET_FIELD(lateral_rhs);
 }
 
-static void
-_outAppendRelInfo(StringInfo str, const AppendRelInfo *node)
-{
+static void _outAppendRelInfo(StringInfo str, const AppendRelInfo *node) {
 	WRITE_NODE_TYPE("APPENDRELINFO");
 
 	WRITE_UINT_FIELD(parent_relid);
@@ -1931,9 +1694,7 @@ _outAppendRelInfo(StringInfo str, const AppendRelInfo *node)
 	WRITE_OID_FIELD(parent_reloid);
 }
 
-static void
-_outPlaceHolderInfo(StringInfo str, const PlaceHolderInfo *node)
-{
+static void _outPlaceHolderInfo(StringInfo str, const PlaceHolderInfo *node) {
 	WRITE_NODE_TYPE("PLACEHOLDERINFO");
 
 	WRITE_UINT_FIELD(phid);
@@ -1944,9 +1705,7 @@ _outPlaceHolderInfo(StringInfo str, const PlaceHolderInfo *node)
 	WRITE_INT_FIELD(ph_width);
 }
 
-static void
-_outMinMaxAggInfo(StringInfo str, const MinMaxAggInfo *node)
-{
+static void _outMinMaxAggInfo(StringInfo str, const MinMaxAggInfo *node) {
 	WRITE_NODE_TYPE("MINMAXAGGINFO");
 
 	WRITE_OID_FIELD(aggfnoid);
@@ -1958,9 +1717,7 @@ _outMinMaxAggInfo(StringInfo str, const MinMaxAggInfo *node)
 	WRITE_NODE_FIELD(param);
 }
 
-static void
-_outPlannerParamItem(StringInfo str, const PlannerParamItem *node)
-{
+static void _outPlannerParamItem(StringInfo str, const PlannerParamItem *node) {
 	WRITE_NODE_TYPE("PLANNERPARAMITEM");
 
 	WRITE_NODE_FIELD(item);
@@ -1976,9 +1733,7 @@ _outPlannerParamItem(StringInfo str, const PlannerParamItem *node)
 /*
  * print the basic stuff of all nodes that inherit from CreateStmt
  */
-static void
-_outCreateStmtInfo(StringInfo str, const CreateStmt *node)
-{
+static void _outCreateStmtInfo(StringInfo str, const CreateStmt *node) {
 	WRITE_NODE_FIELD(relation);
 	WRITE_NODE_FIELD(tableElts);
 	WRITE_NODE_FIELD(inhRelations);
@@ -1990,17 +1745,14 @@ _outCreateStmtInfo(StringInfo str, const CreateStmt *node)
 	WRITE_BOOL_FIELD(if_not_exists);
 }
 
-static void
-_outCreateStmt(StringInfo str, const CreateStmt *node)
-{
+static void _outCreateStmt(StringInfo str, const CreateStmt *node) {
 	WRITE_NODE_TYPE("CREATESTMT");
 
 	_outCreateStmtInfo(str, (const CreateStmt *) node);
 }
 
-static void
-_outCreateForeignTableStmt(StringInfo str, const CreateForeignTableStmt *node)
-{
+static void _outCreateForeignTableStmt(StringInfo str,
+		const CreateForeignTableStmt *node) {
 	WRITE_NODE_TYPE("CREATEFOREIGNTABLESTMT");
 
 	_outCreateStmtInfo(str, (const CreateStmt *) node);
@@ -2009,9 +1761,7 @@ _outCreateForeignTableStmt(StringInfo str, const CreateForeignTableStmt *node)
 	WRITE_NODE_FIELD(options);
 }
 
-static void
-_outIndexStmt(StringInfo str, const IndexStmt *node)
-{
+static void _outIndexStmt(StringInfo str, const IndexStmt *node) {
 	WRITE_NODE_TYPE("INDEXSTMT");
 
 	WRITE_STRING_FIELD(idxname);
@@ -2033,18 +1783,14 @@ _outIndexStmt(StringInfo str, const IndexStmt *node)
 	WRITE_BOOL_FIELD(concurrent);
 }
 
-static void
-_outNotifyStmt(StringInfo str, const NotifyStmt *node)
-{
+static void _outNotifyStmt(StringInfo str, const NotifyStmt *node) {
 	WRITE_NODE_TYPE("NOTIFY");
 
 	WRITE_STRING_FIELD(conditionname);
 	WRITE_STRING_FIELD(payload);
 }
 
-static void
-_outDeclareCursorStmt(StringInfo str, const DeclareCursorStmt *node)
-{
+static void _outDeclareCursorStmt(StringInfo str, const DeclareCursorStmt *node) {
 	WRITE_NODE_TYPE("DECLARECURSOR");
 
 	WRITE_STRING_FIELD(portalname);
@@ -2052,9 +1798,7 @@ _outDeclareCursorStmt(StringInfo str, const DeclareCursorStmt *node)
 	WRITE_NODE_FIELD(query);
 }
 
-static void
-_outSelectStmt(StringInfo str, const SelectStmt *node)
-{
+static void _outSelectStmt(StringInfo str, const SelectStmt *node) {
 	WRITE_NODE_TYPE("SELECT");
 
 	WRITE_NODE_FIELD(distinctClause);
@@ -2077,9 +1821,7 @@ _outSelectStmt(StringInfo str, const SelectStmt *node)
 	WRITE_NODE_FIELD(rarg);
 }
 
-static void
-_outFuncCall(StringInfo str, const FuncCall *node)
-{
+static void _outFuncCall(StringInfo str, const FuncCall *node) {
 	WRITE_NODE_TYPE("FUNCCALL");
 
 	WRITE_NODE_FIELD(funcname);
@@ -2094,9 +1836,7 @@ _outFuncCall(StringInfo str, const FuncCall *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outDefElem(StringInfo str, const DefElem *node)
-{
+static void _outDefElem(StringInfo str, const DefElem *node) {
 	WRITE_NODE_TYPE("DEFELEM");
 
 	WRITE_STRING_FIELD(defnamespace);
@@ -2105,18 +1845,14 @@ _outDefElem(StringInfo str, const DefElem *node)
 	WRITE_ENUM_FIELD(defaction, DefElemAction);
 }
 
-static void
-_outTableLikeClause(StringInfo str, const TableLikeClause *node)
-{
+static void _outTableLikeClause(StringInfo str, const TableLikeClause *node) {
 	WRITE_NODE_TYPE("TABLELIKECLAUSE");
 
 	WRITE_NODE_FIELD(relation);
 	WRITE_UINT_FIELD(options);
 }
 
-static void
-_outLockingClause(StringInfo str, const LockingClause *node)
-{
+static void _outLockingClause(StringInfo str, const LockingClause *node) {
 	WRITE_NODE_TYPE("LOCKINGCLAUSE");
 
 	WRITE_NODE_FIELD(lockedRels);
@@ -2124,9 +1860,7 @@ _outLockingClause(StringInfo str, const LockingClause *node)
 	WRITE_BOOL_FIELD(noWait);
 }
 
-static void
-_outXmlSerialize(StringInfo str, const XmlSerialize *node)
-{
+static void _outXmlSerialize(StringInfo str, const XmlSerialize *node) {
 	WRITE_NODE_TYPE("XMLSERIALIZE");
 
 	WRITE_ENUM_FIELD(xmloption, XmlOptionType);
@@ -2135,9 +1869,7 @@ _outXmlSerialize(StringInfo str, const XmlSerialize *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outColumnDef(StringInfo str, const ColumnDef *node)
-{
+static void _outColumnDef(StringInfo str, const ColumnDef *node) {
 	WRITE_NODE_TYPE("COLUMNDEF");
 
 	WRITE_STRING_FIELD(colname);
@@ -2156,9 +1888,7 @@ _outColumnDef(StringInfo str, const ColumnDef *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outTypeName(StringInfo str, const TypeName *node)
-{
+static void _outTypeName(StringInfo str, const TypeName *node) {
 	WRITE_NODE_TYPE("TYPENAME");
 
 	WRITE_NODE_FIELD(names);
@@ -2171,9 +1901,7 @@ _outTypeName(StringInfo str, const TypeName *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outTypeCast(StringInfo str, const TypeCast *node)
-{
+static void _outTypeCast(StringInfo str, const TypeCast *node) {
 	WRITE_NODE_TYPE("TYPECAST");
 
 	WRITE_NODE_FIELD(arg);
@@ -2181,9 +1909,7 @@ _outTypeCast(StringInfo str, const TypeCast *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCollateClause(StringInfo str, const CollateClause *node)
-{
+static void _outCollateClause(StringInfo str, const CollateClause *node) {
 	WRITE_NODE_TYPE("COLLATECLAUSE");
 
 	WRITE_NODE_FIELD(arg);
@@ -2191,9 +1917,7 @@ _outCollateClause(StringInfo str, const CollateClause *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outIndexElem(StringInfo str, const IndexElem *node)
-{
+static void _outIndexElem(StringInfo str, const IndexElem *node) {
 	WRITE_NODE_TYPE("INDEXELEM");
 
 	WRITE_STRING_FIELD(name);
@@ -2205,9 +1929,7 @@ _outIndexElem(StringInfo str, const IndexElem *node)
 	WRITE_ENUM_FIELD(nulls_ordering, SortByNulls);
 }
 
-static void
-_outQuery(StringInfo str, const Query *node)
-{
+static void _outQuery(StringInfo str, const Query *node) {
 	WRITE_NODE_TYPE("QUERY");
 
 	WRITE_ENUM_FIELD(commandType, CmdType);
@@ -2222,22 +1944,19 @@ _outQuery(StringInfo str, const Query *node)
 	 * for the meantime do this to avoid getting lots of warnings when running
 	 * with debug_print_parse on.
 	 */
-	if (node->utilityStmt)
-	{
-		switch (nodeTag(node->utilityStmt))
-		{
-			case T_CreateStmt:
-			case T_IndexStmt:
-			case T_NotifyStmt:
-			case T_DeclareCursorStmt:
-				WRITE_NODE_FIELD(utilityStmt);
-				break;
-			default:
-				appendStringInfoString(str, " :utilityStmt ?");
-				break;
+	if (node->utilityStmt) {
+		switch (nodeTag(node->utilityStmt)) {
+		case T_CreateStmt:
+		case T_IndexStmt:
+		case T_NotifyStmt:
+		case T_DeclareCursorStmt:
+			WRITE_NODE_FIELD(utilityStmt);
+			break;
+		default:
+			appendStringInfoString(str, " :utilityStmt ?");
+			break;
 		}
-	}
-	else
+	} else
 		appendStringInfoString(str, " :utilityStmt <>");
 
 	WRITE_INT_FIELD(resultRelation);
@@ -2266,9 +1985,7 @@ _outQuery(StringInfo str, const Query *node)
 	WRITE_NODE_FIELD(constraintDeps);
 }
 
-static void
-_outWithCheckOption(StringInfo str, const WithCheckOption *node)
-{
+static void _outWithCheckOption(StringInfo str, const WithCheckOption *node) {
 	WRITE_NODE_TYPE("WITHCHECKOPTION");
 
 	WRITE_STRING_FIELD(viewname);
@@ -2276,9 +1993,7 @@ _outWithCheckOption(StringInfo str, const WithCheckOption *node)
 	WRITE_BOOL_FIELD(cascaded);
 }
 
-static void
-_outSortGroupClause(StringInfo str, const SortGroupClause *node)
-{
+static void _outSortGroupClause(StringInfo str, const SortGroupClause *node) {
 	WRITE_NODE_TYPE("SORTGROUPCLAUSE");
 
 	WRITE_UINT_FIELD(tleSortGroupRef);
@@ -2288,9 +2003,7 @@ _outSortGroupClause(StringInfo str, const SortGroupClause *node)
 	WRITE_BOOL_FIELD(hashable);
 }
 
-static void
-_outWindowClause(StringInfo str, const WindowClause *node)
-{
+static void _outWindowClause(StringInfo str, const WindowClause *node) {
 	WRITE_NODE_TYPE("WINDOWCLAUSE");
 
 	WRITE_STRING_FIELD(name);
@@ -2304,9 +2017,7 @@ _outWindowClause(StringInfo str, const WindowClause *node)
 	WRITE_BOOL_FIELD(copiedOrder);
 }
 
-static void
-_outRowMarkClause(StringInfo str, const RowMarkClause *node)
-{
+static void _outRowMarkClause(StringInfo str, const RowMarkClause *node) {
 	WRITE_NODE_TYPE("ROWMARKCLAUSE");
 
 	WRITE_UINT_FIELD(rti);
@@ -2315,9 +2026,7 @@ _outRowMarkClause(StringInfo str, const RowMarkClause *node)
 	WRITE_BOOL_FIELD(pushedDown);
 }
 
-static void
-_outWithClause(StringInfo str, const WithClause *node)
-{
+static void _outWithClause(StringInfo str, const WithClause *node) {
 	WRITE_NODE_TYPE("WITHCLAUSE");
 
 	WRITE_NODE_FIELD(ctes);
@@ -2325,9 +2034,7 @@ _outWithClause(StringInfo str, const WithClause *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outCommonTableExpr(StringInfo str, const CommonTableExpr *node)
-{
+static void _outCommonTableExpr(StringInfo str, const CommonTableExpr *node) {
 	WRITE_NODE_TYPE("COMMONTABLEEXPR");
 
 	WRITE_STRING_FIELD(ctename);
@@ -2342,9 +2049,7 @@ _outCommonTableExpr(StringInfo str, const CommonTableExpr *node)
 	WRITE_NODE_FIELD(ctecolcollations);
 }
 
-static void
-_outSetOperationStmt(StringInfo str, const SetOperationStmt *node)
-{
+static void _outSetOperationStmt(StringInfo str, const SetOperationStmt *node) {
 	WRITE_NODE_TYPE("SETOPERATIONSTMT");
 
 	WRITE_ENUM_FIELD(op, SetOperation);
@@ -2357,9 +2062,7 @@ _outSetOperationStmt(StringInfo str, const SetOperationStmt *node)
 	WRITE_NODE_FIELD(groupClauses);
 }
 
-static void
-_outRangeTblEntry(StringInfo str, const RangeTblEntry *node)
-{
+static void _outRangeTblEntry(StringInfo str, const RangeTblEntry *node) {
 	WRITE_NODE_TYPE("RTE");
 
 	/* put alias + eref first to make dump more legible */
@@ -2367,39 +2070,38 @@ _outRangeTblEntry(StringInfo str, const RangeTblEntry *node)
 	WRITE_NODE_FIELD(eref);
 	WRITE_ENUM_FIELD(rtekind, RTEKind);
 
-	switch (node->rtekind)
-	{
-		case RTE_RELATION:
-			WRITE_OID_FIELD(relid);
-			WRITE_CHAR_FIELD(relkind);
-			break;
-		case RTE_SUBQUERY:
-			WRITE_NODE_FIELD(subquery);
-			WRITE_BOOL_FIELD(security_barrier);
-			break;
-		case RTE_JOIN:
-			WRITE_ENUM_FIELD(jointype, JoinType);
-			WRITE_NODE_FIELD(joinaliasvars);
-			break;
-		case RTE_FUNCTION:
-			WRITE_NODE_FIELD(functions);
-			WRITE_BOOL_FIELD(funcordinality);
-			break;
-		case RTE_VALUES:
-			WRITE_NODE_FIELD(values_lists);
-			WRITE_NODE_FIELD(values_collations);
-			break;
-		case RTE_CTE:
-			WRITE_STRING_FIELD(ctename);
-			WRITE_UINT_FIELD(ctelevelsup);
-			WRITE_BOOL_FIELD(self_reference);
-			WRITE_NODE_FIELD(ctecoltypes);
-			WRITE_NODE_FIELD(ctecoltypmods);
-			WRITE_NODE_FIELD(ctecolcollations);
-			break;
-		default:
-			elog(ERROR, "unrecognized RTE kind: %d", (int) node->rtekind);
-			break;
+	switch (node->rtekind) {
+	case RTE_RELATION:
+		WRITE_OID_FIELD(relid);
+		WRITE_CHAR_FIELD(relkind);
+		break;
+	case RTE_SUBQUERY:
+		WRITE_NODE_FIELD(subquery);
+		WRITE_BOOL_FIELD(security_barrier);
+		break;
+	case RTE_JOIN:
+		WRITE_ENUM_FIELD(jointype, JoinType);
+		WRITE_NODE_FIELD(joinaliasvars);
+		break;
+	case RTE_FUNCTION:
+		WRITE_NODE_FIELD(functions);
+		WRITE_BOOL_FIELD(funcordinality);
+		break;
+	case RTE_VALUES:
+		WRITE_NODE_FIELD(values_lists);
+		WRITE_NODE_FIELD(values_collations);
+		break;
+	case RTE_CTE:
+		WRITE_STRING_FIELD(ctename);
+		WRITE_UINT_FIELD(ctelevelsup);
+		WRITE_BOOL_FIELD(self_reference);
+		WRITE_NODE_FIELD(ctecoltypes);
+		WRITE_NODE_FIELD(ctecoltypmods);
+		WRITE_NODE_FIELD(ctecolcollations);
+		break;
+	default:
+		elog(ERROR, "unrecognized RTE kind: %d", (int) node->rtekind);
+		break;
 	}
 
 	WRITE_BOOL_FIELD(lateral);
@@ -2411,9 +2113,7 @@ _outRangeTblEntry(StringInfo str, const RangeTblEntry *node)
 	WRITE_BITMAPSET_FIELD(modifiedCols);
 }
 
-static void
-_outRangeTblFunction(StringInfo str, const RangeTblFunction *node)
-{
+static void _outRangeTblFunction(StringInfo str, const RangeTblFunction *node) {
 	WRITE_NODE_TYPE("RANGETBLFUNCTION");
 
 	WRITE_NODE_FIELD(funcexpr);
@@ -2425,55 +2125,52 @@ _outRangeTblFunction(StringInfo str, const RangeTblFunction *node)
 	WRITE_BITMAPSET_FIELD(funcparams);
 }
 
-static void
-_outAExpr(StringInfo str, const A_Expr *node)
-{
+static void _outAExpr(StringInfo str, const A_Expr *node) {
 	WRITE_NODE_TYPE("AEXPR");
 
-	switch (node->kind)
-	{
-		case AEXPR_OP:
-			appendStringInfoChar(str, ' ');
-			WRITE_NODE_FIELD(name);
-			break;
-		case AEXPR_AND:
-			appendStringInfoString(str, " AND");
-			break;
-		case AEXPR_OR:
-			appendStringInfoString(str, " OR");
-			break;
-		case AEXPR_NOT:
-			appendStringInfoString(str, " NOT");
-			break;
-		case AEXPR_OP_ANY:
-			appendStringInfoChar(str, ' ');
-			WRITE_NODE_FIELD(name);
-			appendStringInfoString(str, " ANY ");
-			break;
-		case AEXPR_OP_ALL:
-			appendStringInfoChar(str, ' ');
-			WRITE_NODE_FIELD(name);
-			appendStringInfoString(str, " ALL ");
-			break;
-		case AEXPR_DISTINCT:
-			appendStringInfoString(str, " DISTINCT ");
-			WRITE_NODE_FIELD(name);
-			break;
-		case AEXPR_NULLIF:
-			appendStringInfoString(str, " NULLIF ");
-			WRITE_NODE_FIELD(name);
-			break;
-		case AEXPR_OF:
-			appendStringInfoString(str, " OF ");
-			WRITE_NODE_FIELD(name);
-			break;
-		case AEXPR_IN:
-			appendStringInfoString(str, " IN ");
-			WRITE_NODE_FIELD(name);
-			break;
-		default:
-			appendStringInfoString(str, " ??");
-			break;
+	switch (node->kind) {
+	case AEXPR_OP:
+		appendStringInfoChar(str, ' ');
+		WRITE_NODE_FIELD(name);
+		break;
+	case AEXPR_AND:
+		appendStringInfoString(str, " AND");
+		break;
+	case AEXPR_OR:
+		appendStringInfoString(str, " OR");
+		break;
+	case AEXPR_NOT:
+		appendStringInfoString(str, " NOT");
+		break;
+	case AEXPR_OP_ANY:
+		appendStringInfoChar(str, ' ');
+		WRITE_NODE_FIELD(name);
+		appendStringInfoString(str, " ANY ");
+		break;
+	case AEXPR_OP_ALL:
+		appendStringInfoChar(str, ' ');
+		WRITE_NODE_FIELD(name);
+		appendStringInfoString(str, " ALL ");
+		break;
+	case AEXPR_DISTINCT:
+		appendStringInfoString(str, " DISTINCT ");
+		WRITE_NODE_FIELD(name);
+		break;
+	case AEXPR_NULLIF:
+		appendStringInfoString(str, " NULLIF ");
+		WRITE_NODE_FIELD(name);
+		break;
+	case AEXPR_OF:
+		appendStringInfoString(str, " OF ");
+		WRITE_NODE_FIELD(name);
+		break;
+	case AEXPR_IN:
+		appendStringInfoString(str, " IN ");
+		WRITE_NODE_FIELD(name);
+		break;
+	default:
+		appendStringInfoString(str, " ??");
+		break;
 	}
 
 	WRITE_NODE_FIELD(lexpr);
@@ -2481,62 +2178,53 @@ _outAExpr(StringInfo str, const A_Expr *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outValue(StringInfo str, const Value *value)
-{
-	switch (value->type)
-	{
-		case T_Integer:
-			appendStringInfo(str, "%ld", value->val.ival);
-			break;
-		case T_Float:
+static void _outValue(StringInfo str, const Value *value) {
+	switch (value->type) {
+	case T_Integer:
+		appendStringInfo(str, "%ld", value->val.ival);
+		break;
+	case T_Float:
 
-			/*
-			 * We assume the value is a valid numeric literal and so does not
-			 * need quoting.
-			 */
-			appendStringInfoString(str, value->val.str);
-			break;
-		case T_String:
-			appendStringInfoChar(str, '"');
-			_outToken(str, value->val.str);
-			appendStringInfoChar(str, '"');
-			break;
-		case T_BitString:
-			/* internal representation already has leading 'b' */
-			appendStringInfoString(str, value->val.str);
-			break;
-		case T_Null:
-			/* this is seen only within A_Const, not in transformed trees */
-			appendStringInfoString(str, "NULL");
-			break;
-		default:
-			elog(ERROR, "unrecognized node type: %d", (int) value->type);
-			break;
+		/*
+		 * We assume the value is a valid numeric literal and so does not
+		 * need quoting.
+		 */
+		appendStringInfoString(str, value->val.str);
+		break;
+	case T_String:
+		appendStringInfoChar(str, '"');
+		_outToken(str, value->val.str);
+		appendStringInfoChar(str, '"');
+		break;
+	case T_BitString:
+		/* internal representation already has leading 'b' */
+		appendStringInfoString(str, value->val.str);
+		break;
+	case T_Null:
+		/* this is seen only within A_Const, not in transformed trees */
+		appendStringInfoString(str, "NULL");
+		break;
+	default:
+		elog(ERROR, "unrecognized node type: %d", (int) value->type);
+		break;
 	}
 }
 
-static void
-_outColumnRef(StringInfo str, const ColumnRef *node)
-{
+static void _outColumnRef(StringInfo str, const ColumnRef *node) {
 	WRITE_NODE_TYPE("COLUMNREF");
 
 	WRITE_NODE_FIELD(fields);
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outParamRef(StringInfo str, const ParamRef *node)
-{
+static void _outParamRef(StringInfo str, const ParamRef *node) {
 	WRITE_NODE_TYPE("PARAMREF");
 
 	WRITE_INT_FIELD(number);
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outAConst(StringInfo str, const A_Const *node)
-{
+static void _outAConst(StringInfo str, const A_Const *node) {
 	WRITE_NODE_TYPE("A_CONST");
 
 	appendStringInfoString(str, " :val ");
@@ -2544,42 +2232,32 @@ _outAConst(StringInfo str, const A_Const *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outA_Star(StringInfo str, const A_Star *node)
-{
+static void _outA_Star(StringInfo str, const A_Star *node) {
 	WRITE_NODE_TYPE("A_STAR");
 }
 
-static void
-_outA_Indices(StringInfo str, const A_Indices *node)
-{
+static void _outA_Indices(StringInfo str, const A_Indices *node) {
 	WRITE_NODE_TYPE("A_INDICES");
 
 	WRITE_NODE_FIELD(lidx);
 	WRITE_NODE_FIELD(uidx);
 }
 
-static void
-_outA_Indirection(StringInfo str, const A_Indirection *node)
-{
+static void _outA_Indirection(StringInfo str, const A_Indirection *node) {
 	WRITE_NODE_TYPE("A_INDIRECTION");
 
 	WRITE_NODE_FIELD(arg);
 	WRITE_NODE_FIELD(indirection);
 }
 
-static void
-_outA_ArrayExpr(StringInfo str, const A_ArrayExpr *node)
-{
+static void _outA_ArrayExpr(StringInfo str, const A_ArrayExpr *node) {
 	WRITE_NODE_TYPE("A_ARRAYEXPR");
 
 	WRITE_NODE_FIELD(elements);
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outResTarget(StringInfo str, const ResTarget *node)
-{
+static void _outResTarget(StringInfo str, const ResTarget *node) {
 	WRITE_NODE_TYPE("RESTARGET");
 
 	WRITE_STRING_FIELD(name);
@@ -2588,9 +2266,7 @@ _outResTarget(StringInfo str, const ResTarget *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outSortBy(StringInfo str, const SortBy *node)
-{
+static void _outSortBy(StringInfo str, const SortBy *node) {
 	WRITE_NODE_TYPE("SORTBY");
 
 	WRITE_NODE_FIELD(node);
@@ -2600,9 +2276,7 @@ _outSortBy(StringInfo str, const SortBy *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outWindowDef(StringInfo str, const WindowDef *node)
-{
+static void _outWindowDef(StringInfo str, const WindowDef *node) {
 	WRITE_NODE_TYPE("WINDOWDEF");
 
 	WRITE_STRING_FIELD(name);
@@ -2615,9 +2289,7 @@ _outWindowDef(StringInfo str, const WindowDef *node)
 	WRITE_LOCATION_FIELD(location);
 }
 
-static void
-_outRangeSubselect(StringInfo str, const RangeSubselect *node)
-{
+static void _outRangeSubselect(StringInfo str, const RangeSubselect *node) {
 	WRITE_NODE_TYPE("RANGESUBSELECT");
 
 	WRITE_BOOL_FIELD(lateral);
@@ -2625,9 +2297,7 @@ _outRangeSubselect(StringInfo str, const RangeSubselect *node)
 	WRITE_NODE_FIELD(alias);
 }
 
-static void
-_outRangeFunction(StringInfo str, const RangeFunction *node)
-{
+static void _outRangeFunction(StringInfo str, const RangeFunction *node) {
 	WRITE_NODE_TYPE("RANGEFUNCTION");
 
 	WRITE_BOOL_FIELD(lateral);
@@ -2638,9 +2308,7 @@ _outRangeFunction(StringInfo str, const RangeFunction *node)
 	WRITE_NODE_FIELD(coldeflist);
 }
 
-static void
-_outConstraint(StringInfo str, const Constraint *node)
-{
+static void _outConstraint(StringInfo str, const Constraint *node) {
 	WRITE_NODE_TYPE("CONSTRAINT");
 
 	WRITE_STRING_FIELD(conname);
@@ -2649,612 +2317,730 @@ _outConstraint(StringInfo str, const Constraint *node)
 	WRITE_LOCATION_FIELD(location);
 
 	appendStringInfoString(str, " :contype ");
-	switch (node->contype)
-	{
-		case CONSTR_NULL:
-			appendStringInfoString(str, "NULL");
-			break;
+	switch (node->contype) {
+	case CONSTR_NULL:
+		appendStringInfoString(str, "NULL");
+		break;
+
+	case CONSTR_NOTNULL:
+		appendStringInfoString(str, "NOT_NULL");
+		break;
+
+	case CONSTR_DEFAULT:
+		appendStringInfoString(str, "DEFAULT");
+		WRITE_NODE_FIELD(raw_expr);
+		WRITE_STRING_FIELD(cooked_expr);
+		break;
+
+	case CONSTR_CHECK:
+		appendStringInfoString(str, "CHECK");
+		WRITE_BOOL_FIELD(is_no_inherit);
+		WRITE_NODE_FIELD(raw_expr);
+		WRITE_STRING_FIELD(cooked_expr);
+		break;
+
+	case CONSTR_PRIMARY:
+		appendStringInfoString(str, "PRIMARY_KEY");
+		WRITE_NODE_FIELD(keys);
+		WRITE_NODE_FIELD(options);
+		WRITE_STRING_FIELD(indexname);
+		WRITE_STRING_FIELD(indexspace);
+		/* access_method and where_clause not currently used */
+		break;
+
+	case CONSTR_UNIQUE:
+		appendStringInfoString(str, "UNIQUE");
+		WRITE_NODE_FIELD(keys);
+		WRITE_NODE_FIELD(options);
+		WRITE_STRING_FIELD(indexname);
+		WRITE_STRING_FIELD(indexspace);
+		/* access_method and where_clause not currently used */
+		break;
+
+	case CONSTR_EXCLUSION:
+		appendStringInfoString(str, "EXCLUSION");
+		WRITE_NODE_FIELD(exclusions);
+		WRITE_NODE_FIELD(options);
+		WRITE_STRING_FIELD(indexname);
+		WRITE_STRING_FIELD(indexspace);
+		WRITE_STRING_FIELD(access_method);
+		WRITE_NODE_FIELD(where_clause);
+		break;
+
+	case CONSTR_FOREIGN:
+		appendStringInfoString(str, "FOREIGN_KEY");
+		WRITE_NODE_FIELD(pktable);
+		WRITE_NODE_FIELD(fk_attrs);
+		WRITE_NODE_FIELD(pk_attrs);
+		WRITE_CHAR_FIELD(fk_matchtype);
+		WRITE_CHAR_FIELD(fk_upd_action);
+		WRITE_CHAR_FIELD(fk_del_action);
+		WRITE_NODE_FIELD(old_conpfeqop);
+		WRITE_OID_FIELD(old_pktable_oid);
+		WRITE_BOOL_FIELD(skip_validation);
+		WRITE_BOOL_FIELD(initially_valid);
+		break;
+
+	case CONSTR_ATTR_DEFERRABLE:
+		appendStringInfoString(str, "ATTR_DEFERRABLE");
+		break;
+
+	case CONSTR_ATTR_NOT_DEFERRABLE:
+		appendStringInfoString(str, "ATTR_NOT_DEFERRABLE");
+		break;
+
+	case CONSTR_ATTR_DEFERRED:
+		appendStringInfoString(str, "ATTR_DEFERRED");
+		break;
+
+	case CONSTR_ATTR_IMMEDIATE:
+		appendStringInfoString(str, "ATTR_IMMEDIATE");
+		break;
+
+	default:
+		appendStringInfo(str, "<unrecognized_constraint %d>",
+				(int) node->contype);
+		break;
+	}
+}
 
-		case CONSTR_NOTNULL:
-			appendStringInfoString(str, "NOT_NULL");
-			break;
+/*
+ * _outNode -
+ *	  converts a Node into ascii string and append it to 'str'
+ */
+void _outNode(StringInfo str, const void *obj) {
+	if (obj == NULL)
+		appendStringInfoString(str, "<>");
+	else if (IsA(obj, List) || IsA(obj, IntList) || IsA(obj, OidList))
+		_outList(str, obj, false);
+	else if (IsA(obj, Integer) || IsA(obj, Float) || IsA(obj, String)
+			|| IsA(obj, BitString)) {
+		/* nodeRead does not want to see { } around these! */
+		_outValue(str, obj);
+	} else {
+		appendStringInfoChar(str, '{');
 
-		case CONSTR_DEFAULT:
-			appendStringInfoString(str, "DEFAULT");
-			WRITE_NODE_FIELD(raw_expr);
-			WRITE_STRING_FIELD(cooked_expr);
-			break;
+		switch (nodeTag(obj)) {
 
-		case CONSTR_CHECK:
-			appendStringInfoString(str, "CHECK");
-			WRITE_BOOL_FIELD(is_no_inherit);
-			WRITE_NODE_FIELD(raw_expr);
-			WRITE_STRING_FIELD(cooked_expr);
+		case T_PlannedStmt:
+			_outPlannedStmt(str, obj);
 			break;
-
-		case CONSTR_PRIMARY:
-			appendStringInfoString(str, "PRIMARY_KEY");
-			WRITE_NODE_FIELD(keys);
-			WRITE_NODE_FIELD(options);
-			WRITE_STRING_FIELD(indexname);
-			WRITE_STRING_FIELD(indexspace);
-			/* access_method and where_clause not currently used */
+		case T_Plan:
+			_outPlan(str, obj);
 			break;
-
-		case CONSTR_UNIQUE:
-			appendStringInfoString(str, "UNIQUE");
-			WRITE_NODE_FIELD(keys);
-			WRITE_NODE_FIELD(options);
-			WRITE_STRING_FIELD(indexname);
-			WRITE_STRING_FIELD(indexspace);
-			/* access_method and where_clause not currently used */
+		case T_Result:
+			_outResult(str, obj);
 			break;
-
-		case CONSTR_EXCLUSION:
-			appendStringInfoString(str, "EXCLUSION");
-			WRITE_NODE_FIELD(exclusions);
-			WRITE_NODE_FIELD(options);
-			WRITE_STRING_FIELD(indexname);
-			WRITE_STRING_FIELD(indexspace);
-			WRITE_STRING_FIELD(access_method);
-			WRITE_NODE_FIELD(where_clause);
+		case T_ModifyTable:
+			_outModifyTable(str, obj);
 			break;
-
-		case CONSTR_FOREIGN:
-			appendStringInfoString(str, "FOREIGN_KEY");
-			WRITE_NODE_FIELD(pktable);
-			WRITE_NODE_FIELD(fk_attrs);
-			WRITE_NODE_FIELD(pk_attrs);
-			WRITE_CHAR_FIELD(fk_matchtype);
-			WRITE_CHAR_FIELD(fk_upd_action);
-			WRITE_CHAR_FIELD(fk_del_action);
-			WRITE_NODE_FIELD(old_conpfeqop);
-			WRITE_OID_FIELD(old_pktable_oid);
-			WRITE_BOOL_FIELD(skip_validation);
-			WRITE_BOOL_FIELD(initially_valid);
+		case T_Append:
+			_outAppend(str, obj);
 			break;
-
-		case CONSTR_ATTR_DEFERRABLE:
-			appendStringInfoString(str, "ATTR_DEFERRABLE");
+		case T_MergeAppend:
+			_outMergeAppend(str, obj);
 			break;
-
-		case CONSTR_ATTR_NOT_DEFERRABLE:
-			appendStringInfoString(str, "ATTR_NOT_DEFERRABLE");
+		case T_RecursiveUnion:
+			_outRecursiveUnion(str, obj);
+			break;
+		case T_BitmapAnd:
+			_outBitmapAnd(str, obj);
+			break;
+		case T_BitmapOr:
+			_outBitmapOr(str, obj);
+			break;
+		case T_Scan:
+			_outScan(str, obj);
+			break;
+		case T_SeqScan:
+			_outSeqScan(str, obj);
+			break;
+		case T_IndexScan:
+			_outIndexScan(str, obj);
+			break;
+		case T_IndexOnlyScan:
+			_outIndexOnlyScan(str, obj);
+			break;
+		case T_BitmapIndexScan:
+			_outBitmapIndexScan(str, obj);
+			break;
+		case T_BitmapHeapScan:
+			_outBitmapHeapScan(str, obj);
+			break;
+		case T_TidScan:
+			_outTidScan(str, obj);
+			break;
+		case T_SubqueryScan:
+			_outSubqueryScan(str, obj);
+			break;
+		case T_FunctionScan:
+			_outFunctionScan(str, obj);
+			break;
+		case T_ValuesScan:
+			_outValuesScan(str, obj);
+			break;
+		case T_CteScan:
+			_outCteScan(str, obj);
+			break;
+		case T_WorkTableScan:
+			_outWorkTableScan(str, obj);
+			break;
+		case T_ForeignScan:
+			_outForeignScan(str, obj);
+			break;
+		case T_Join:
+			_outJoin(str, obj);
+			break;
+		case T_NestLoop:
+			_outNestLoop(str, obj);
+			break;
+		case T_MergeJoin:
+			_outMergeJoin(str, obj);
+			break;
+		case T_HashJoin:
+			_outHashJoin(str, obj);
+			break;
+		case T_Agg:
+			_outAgg(str, obj);
+			break;
+		case T_WindowAgg:
+			_outWindowAgg(str, obj);
+			break;
+		case T_Group:
+			_outGroup(str, obj);
+			break;
+		case T_Material:
+			_outMaterial(str, obj);
+			break;
+		case T_Sort:
+			_outSort(str, obj);
+			break;
+		case T_Unique:
+			_outUnique(str, obj);
+			break;
+		case T_Hash:
+			_outHash(str, obj);
+			break;
+		case T_SetOp:
+			_outSetOp(str, obj);
+			break;
+		case T_LockRows:
+			_outLockRows(str, obj);
+			break;
+		case T_Limit:
+			_outLimit(str, obj);
+			break;
+		case T_NestLoopParam:
+			_outNestLoopParam(str, obj);
+			break;
+		case T_PlanRowMark:
+			_outPlanRowMark(str, obj);
+			break;
+		case T_PlanInvalItem:
+			_outPlanInvalItem(str, obj);
+			break;
+		case T_Alias:
+			_outAlias(str, obj);
+			break;
+		case T_RangeVar:
+			_outRangeVar(str, obj);
+			break;
+		case T_IntoClause:
+			_outIntoClause(str, obj);
+			break;
+		case T_Var:
+			_outVar(str, obj);
+			break;
+		case T_Const:
+			_outConst(str, obj);
+			break;
+		case T_Param:
+			_outParam(str, obj);
+			break;
+		case T_Aggref:
+			_outAggref(str, obj);
+			break;
+		case T_WindowFunc:
+			_outWindowFunc(str, obj);
+			break;
+		case T_ArrayRef:
+			_outArrayRef(str, obj);
+			break;
+		case T_FuncExpr:
+			_outFuncExpr(str, obj);
+			break;
+		case T_NamedArgExpr:
+			_outNamedArgExpr(str, obj);
+			break;
+		case T_OpExpr:
+			_outOpExpr(str, obj);
+			break;
+		case T_DistinctExpr:
+			_outDistinctExpr(str, obj);
+			break;
+		case T_NullIfExpr:
+			_outNullIfExpr(str, obj);
+			break;
+		case T_ScalarArrayOpExpr:
+			_outScalarArrayOpExpr(str, obj);
+			break;
+		case T_BoolExpr:
+			_outBoolExpr(str, obj);
+			break;
+		case T_SubLink:
+			_outSubLink(str, obj);
+			break;
+		case T_SubPlan:
+			_outSubPlan(str, obj);
+			break;
+		case T_AlternativeSubPlan:
+			_outAlternativeSubPlan(str, obj);
+			break;
+		case T_FieldSelect:
+			_outFieldSelect(str, obj);
+			break;
+		case T_FieldStore:
+			_outFieldStore(str, obj);
+			break;
+		case T_RelabelType:
+			_outRelabelType(str, obj);
+			break;
+		case T_CoerceViaIO:
+			_outCoerceViaIO(str, obj);
+			break;
+		case T_ArrayCoerceExpr:
+			_outArrayCoerceExpr(str, obj);
+			break;
+		case T_ConvertRowtypeExpr:
+			_outConvertRowtypeExpr(str, obj);
+			break;
+		case T_CollateExpr:
+			_outCollateExpr(str, obj);
+			break;
+		case T_CaseExpr:
+			_outCaseExpr(str, obj);
+			break;
+		case T_CaseWhen:
+			_outCaseWhen(str, obj);
+			break;
+		case T_CaseTestExpr:
+			_outCaseTestExpr(str, obj);
+			break;
+		case T_ArrayExpr:
+			_outArrayExpr(str, obj);
+			break;
+		case T_RowExpr:
+			_outRowExpr(str, obj);
+			break;
+		case T_RowCompareExpr:
+			_outRowCompareExpr(str, obj);
+			break;
+		case T_CoalesceExpr:
+			_outCoalesceExpr(str, obj);
+			break;
+		case T_MinMaxExpr:
+			_outMinMaxExpr(str, obj);
+			break;
+		case T_XmlExpr:
+			_outXmlExpr(str, obj);
+			break;
+		case T_NullTest:
+			_outNullTest(str, obj);
+			break;
+		case T_BooleanTest:
+			_outBooleanTest(str, obj);
+			break;
+		case T_CoerceToDomain:
+			_outCoerceToDomain(str, obj);
+			break;
+		case T_CoerceToDomainValue:
+			_outCoerceToDomainValue(str, obj);
+			break;
+		case T_SetToDefault:
+			_outSetToDefault(str, obj);
+			break;
+		case T_CurrentOfExpr:
+			_outCurrentOfExpr(str, obj);
+			break;
+		case T_TargetEntry:
+			_outTargetEntry(str, obj);
+			break;
+		case T_RangeTblRef:
+			_outRangeTblRef(str, obj);
+			break;
+		case T_JoinExpr:
+			_outJoinExpr(str, obj);
+			break;
+		case T_FromExpr:
+			_outFromExpr(str, obj);
 			break;
 
-		case CONSTR_ATTR_DEFERRED:
-			appendStringInfoString(str, "ATTR_DEFERRED");
+		case T_Path:
+			_outPath(str, obj);
+			break;
+		case T_IndexPath:
+			_outIndexPath(str, obj);
+			break;
+		case T_BitmapHeapPath:
+			_outBitmapHeapPath(str, obj);
+			break;
+		case T_BitmapAndPath:
+			_outBitmapAndPath(str, obj);
+			break;
+		case T_BitmapOrPath:
+			_outBitmapOrPath(str, obj);
+			break;
+		case T_TidPath:
+			_outTidPath(str, obj);
+			break;
+		case T_ForeignPath:
+			_outForeignPath(str, obj);
+			break;
+		case T_AppendPath:
+			_outAppendPath(str, obj);
+			break;
+		case T_MergeAppendPath:
+			_outMergeAppendPath(str, obj);
+			break;
+		case T_ResultPath:
+			_outResultPath(str, obj);
+			break;
+		case T_MaterialPath:
+			_outMaterialPath(str, obj);
+			break;
+		case T_UniquePath:
+			_outUniquePath(str, obj);
+			break;
+		case T_NestPath:
+			_outNestPath(str, obj);
+			break;
+		case T_MergePath:
+			_outMergePath(str, obj);
+			break;
+		case T_HashPath:
+			_outHashPath(str, obj);
+			break;
+		case T_PlannerGlobal:
+			_outPlannerGlobal(str, obj);
+			break;
+		case T_PlannerInfo:
+			_outPlannerInfo(str, obj);
+			break;
+		case T_RelOptInfo:
+			_outRelOptInfo(str, obj);
+			break;
+		case T_IndexOptInfo:
+			_outIndexOptInfo(str, obj);
+			break;
+		case T_EquivalenceClass:
+			_outEquivalenceClass(str, obj);
+			break;
+		case T_EquivalenceMember:
+			_outEquivalenceMember(str, obj);
+			break;
+		case T_PathKey:
+			_outPathKey(str, obj);
+			break;
+		case T_ParamPathInfo:
+			_outParamPathInfo(str, obj);
+			break;
+		case T_RestrictInfo:
+			_outRestrictInfo(str, obj);
+			break;
+		case T_PlaceHolderVar:
+			_outPlaceHolderVar(str, obj);
+			break;
+		case T_SpecialJoinInfo:
+			_outSpecialJoinInfo(str, obj);
+			break;
+		case T_LateralJoinInfo:
+			_outLateralJoinInfo(str, obj);
+			break;
+		case T_AppendRelInfo:
+			_outAppendRelInfo(str, obj);
+			break;
+		case T_PlaceHolderInfo:
+			_outPlaceHolderInfo(str, obj);
+			break;
+		case T_MinMaxAggInfo:
+			_outMinMaxAggInfo(str, obj);
+			break;
+		case T_PlannerParamItem:
+			_outPlannerParamItem(str, obj);
 			break;
 
-		case CONSTR_ATTR_IMMEDIATE:
-			appendStringInfoString(str, "ATTR_IMMEDIATE");
+		case T_CreateStmt:
+			_outCreateStmt(str, obj);
+			break;
+		case T_CreateForeignTableStmt:
+			_outCreateForeignTableStmt(str, obj);
+			break;
+		case T_IndexStmt:
+			_outIndexStmt(str, obj);
+			break;
+		case T_NotifyStmt:
+			_outNotifyStmt(str, obj);
+			break;
+		case T_DeclareCursorStmt:
+			_outDeclareCursorStmt(str, obj);
+			break;
+		case T_SelectStmt:
+			_outSelectStmt(str, obj);
+			break;
+		case T_ColumnDef:
+			_outColumnDef(str, obj);
+			break;
+		case T_TypeName:
+			_outTypeName(str, obj);
+			break;
+		case T_TypeCast:
+			_outTypeCast(str, obj);
+			break;
+		case T_CollateClause:
+			_outCollateClause(str, obj);
+			break;
+		case T_IndexElem:
+			_outIndexElem(str, obj);
+			break;
+		case T_Query:
+			_outQuery(str, obj);
+			break;
+		case T_WithCheckOption:
+			_outWithCheckOption(str, obj);
+			break;
+		case T_SortGroupClause:
+			_outSortGroupClause(str, obj);
+			break;
+		case T_WindowClause:
+			_outWindowClause(str, obj);
+			break;
+		case T_RowMarkClause:
+			_outRowMarkClause(str, obj);
+			break;
+		case T_WithClause:
+			_outWithClause(str, obj);
+			break;
+		case T_CommonTableExpr:
+			_outCommonTableExpr(str, obj);
+			break;
+		case T_SetOperationStmt:
+			_outSetOperationStmt(str, obj);
+			break;
+		case T_RangeTblEntry:
+			_outRangeTblEntry(str, obj);
+			break;
+		case T_RangeTblFunction:
+			_outRangeTblFunction(str, obj);
+			break;
+		case T_A_Expr:
+			_outAExpr(str, obj);
+			break;
+		case T_ColumnRef:
+			_outColumnRef(str, obj);
+			break;
+		case T_ParamRef:
+			_outParamRef(str, obj);
+			break;
+		case T_A_Const:
+			_outAConst(str, obj);
+			break;
+		case T_A_Star:
+			_outA_Star(str, obj);
+			break;
+		case T_A_Indices:
+			_outA_Indices(str, obj);
+			break;
+		case T_A_Indirection:
+			_outA_Indirection(str, obj);
+			break;
+		case T_A_ArrayExpr:
+			_outA_ArrayExpr(str, obj);
+			break;
+		case T_ResTarget:
+			_outResTarget(str, obj);
+			break;
+		case T_SortBy:
+			_outSortBy(str, obj);
+			break;
+		case T_WindowDef:
+			_outWindowDef(str, obj);
+			break;
+		case T_RangeSubselect:
+			_outRangeSubselect(str, obj);
+			break;
+		case T_RangeFunction:
+			_outRangeFunction(str, obj);
+			break;
+		case T_Constraint:
+			_outConstraint(str, obj);
+			break;
+		case T_FuncCall:
+			_outFuncCall(str, obj);
+			break;
+		case T_DefElem:
+			_outDefElem(str, obj);
+			break;
+		case T_TableLikeClause:
+			_outTableLikeClause(str, obj);
+			break;
+		case T_LockingClause:
+			_outLockingClause(str, obj);
+			break;
+		case T_XmlSerialize:
+			_outXmlSerialize(str, obj);
 			break;
 
 		default:
-			appendStringInfo(str, "<unrecognized_constraint %d>",
-							 (int) node->contype);
+
+			/*
+			 * This should be an ERROR, but it's too useful to be able to
+			 * dump structures that _outNode only understands part of.
+			 */
+			elog(WARNING,
+					"could not dump unrecognized node type: %d", (int) nodeTag(obj));
 			break;
+		}
+		appendStringInfoChar(str, '}');
 	}
 }
 
-
 /*
- * _outNode -
- *	  converts a Node into ascii string and append it to 'str'
+ * nodeToString -
+ *	   returns the ascii representation of the Node as a palloc'd string
  */
-static void
-_outNode(StringInfo str, const void *obj)
-{
-	if (obj == NULL)
-		appendStringInfoString(str, "<>");
-	else if (IsA(obj, List) ||IsA(obj, IntList) || IsA(obj, OidList))
-		_outList(str, obj);
-	else if (IsA(obj, Integer) ||
-			 IsA(obj, Float) ||
-			 IsA(obj, String) ||
-			 IsA(obj, BitString))
-	{
-		/* nodeRead does not want to see { } around these! */
-		_outValue(str, obj);
+char *
+nodeToString(const void *obj) {
+	StringInfoData str;
+
+	/* see stringinfo.h for an explanation of this maneuver */
+	initStringInfo(&str);
+	_outNode(&str, obj);
+	return str.data;
+}
+char *
+nodeSimToString(const void *obj) {
+	StringInfoData str;
+
+	/* see stringinfo.h for an explanation of this maneuver */
+	initStringInfo(&str);
+
+	_outSimNode(&str, obj);
+
+	return str.data;
+}
+void _outSimOpExpr(StringInfo str, const OpExpr *node) {
+	WRITE_OID_FIELD(opno);
+	WRITE_NODE_SIM_FIELD(args);
+
+}
+static void _outSimBoolExpr(StringInfo str, const BoolExpr *node) {
+	char *opstr = NULL;
+
+	/* do-it-yourself enum representation */
+	switch (node->boolop) {
+	case AND_EXPR:
+		opstr = "and";
+		break;
+	case OR_EXPR:
+		opstr = "or";
+		break;
+	case NOT_EXPR:
+		opstr = "not";
+		break;
 	}
+	appendStringInfoString(str, " :boolop ");
+	_outToken(str, opstr);
+
+	WRITE_NODE_SIM_FIELD(args);
+
+}
+void _outSimVar(StringInfo str, const Var *node) {
+
+	appendStringInfo(str, " %d", node->varoattno);
+
+}
+void _outSimConst(StringInfo str, const Const *node) {
+	if (node->constisnull)
+		appendStringInfoString(str, "<>");
 	else
-	{
-		appendStringInfoChar(str, '{');
-		switch (nodeTag(obj))
-		{
-			case T_PlannedStmt:
-				_outPlannedStmt(str, obj);
-				break;
-			case T_Plan:
-				_outPlan(str, obj);
-				break;
-			case T_Result:
-				_outResult(str, obj);
-				break;
-			case T_ModifyTable:
-				_outModifyTable(str, obj);
-				break;
-			case T_Append:
-				_outAppend(str, obj);
-				break;
-			case T_MergeAppend:
-				_outMergeAppend(str, obj);
-				break;
-			case T_RecursiveUnion:
-				_outRecursiveUnion(str, obj);
-				break;
-			case T_BitmapAnd:
-				_outBitmapAnd(str, obj);
-				break;
-			case T_BitmapOr:
-				_outBitmapOr(str, obj);
-				break;
-			case T_Scan:
-				_outScan(str, obj);
-				break;
-			case T_SeqScan:
-				_outSeqScan(str, obj);
-				break;
-			case T_IndexScan:
-				_outIndexScan(str, obj);
-				break;
-			case T_IndexOnlyScan:
-				_outIndexOnlyScan(str, obj);
-				break;
-			case T_BitmapIndexScan:
-				_outBitmapIndexScan(str, obj);
-				break;
-			case T_BitmapHeapScan:
-				_outBitmapHeapScan(str, obj);
-				break;
-			case T_TidScan:
-				_outTidScan(str, obj);
-				break;
-			case T_SubqueryScan:
-				_outSubqueryScan(str, obj);
-				break;
-			case T_FunctionScan:
-				_outFunctionScan(str, obj);
-				break;
-			case T_ValuesScan:
-				_outValuesScan(str, obj);
-				break;
-			case T_CteScan:
-				_outCteScan(str, obj);
-				break;
-			case T_WorkTableScan:
-				_outWorkTableScan(str, obj);
-				break;
-			case T_ForeignScan:
-				_outForeignScan(str, obj);
-				break;
-			case T_Join:
-				_outJoin(str, obj);
-				break;
-			case T_NestLoop:
-				_outNestLoop(str, obj);
-				break;
-			case T_MergeJoin:
-				_outMergeJoin(str, obj);
-				break;
-			case T_HashJoin:
-				_outHashJoin(str, obj);
-				break;
-			case T_Agg:
-				_outAgg(str, obj);
-				break;
-			case T_WindowAgg:
-				_outWindowAgg(str, obj);
-				break;
-			case T_Group:
-				_outGroup(str, obj);
-				break;
-			case T_Material:
-				_outMaterial(str, obj);
-				break;
-			case T_Sort:
-				_outSort(str, obj);
-				break;
-			case T_Unique:
-				_outUnique(str, obj);
-				break;
-			case T_Hash:
-				_outHash(str, obj);
-				break;
-			case T_SetOp:
-				_outSetOp(str, obj);
-				break;
-			case T_LockRows:
-				_outLockRows(str, obj);
-				break;
-			case T_Limit:
-				_outLimit(str, obj);
-				break;
-			case T_NestLoopParam:
-				_outNestLoopParam(str, obj);
-				break;
-			case T_PlanRowMark:
-				_outPlanRowMark(str, obj);
-				break;
-			case T_PlanInvalItem:
-				_outPlanInvalItem(str, obj);
-				break;
-			case T_Alias:
-				_outAlias(str, obj);
-				break;
-			case T_RangeVar:
-				_outRangeVar(str, obj);
-				break;
-			case T_IntoClause:
-				_outIntoClause(str, obj);
-				break;
+		_outDatum(str, node->constvalue, node->constlen, node->constbyval);
+}
+void _outSimParam(StringInfo str, const Param *node) {
+	appendStringInfo(str, " %d", node->paramid);
+
+}
+void _outSimSubPlan(StringInfo str, const SubPlan *node) {
+
+	WRITE_STRING_FIELD(plan_name);
+	WRITE_NODE_SIM_FIELD(args);
+
+}
+void _outSimRelabelType(StringInfo str, const RelabelType *node) {
+	WRITE_NODE_SIM_FIELD(arg);
+}
+void _outSimRestrictInfo(StringInfo str, const RestrictInfo *node) {
+	/* NB: this isn't a complete set of fields */
+	_outSimNode(str, node->clause);
+}
+
+void _outSimNode(StringInfo str, const void *obj) {
+
+	if (obj == NULL)
+		appendStringInfoString(str, "<>");
+	else {
+
+		if (IsA(obj, List) || IsA(obj, IntList) || IsA(obj, OidList))
+			_outList(str, obj, true);
+
+		else if (IsA(obj, Integer) || IsA(obj, Float) || IsA(obj, String)
+				|| IsA(obj, BitString)) {
+			/* nodeRead does not want to see { } around these! */
+			_outValue(str, obj);
+		} else {
+			if (nodeTag(obj) != T_RestrictInfo)
+				appendStringInfoChar(str, '{');
+			switch (nodeTag(obj)) {
+
 			case T_Var:
-				_outVar(str, obj);
+				_outSimVar(str, obj);
+				break;
+			case T_BoolExpr:
+				_outSimBoolExpr(str, obj);
 				break;
 			case T_Const:
-				_outConst(str, obj);
+				_outSimConst(str, obj);
 				break;
 			case T_Param:
-				_outParam(str, obj);
-				break;
-			case T_Aggref:
-				_outAggref(str, obj);
-				break;
-			case T_WindowFunc:
-				_outWindowFunc(str, obj);
-				break;
-			case T_ArrayRef:
-				_outArrayRef(str, obj);
-				break;
-			case T_FuncExpr:
-				_outFuncExpr(str, obj);
-				break;
-			case T_NamedArgExpr:
-				_outNamedArgExpr(str, obj);
+				_outSimParam(str, obj);
 				break;
 			case T_OpExpr:
-				_outOpExpr(str, obj);
-				break;
-			case T_DistinctExpr:
-				_outDistinctExpr(str, obj);
-				break;
-			case T_NullIfExpr:
-				_outNullIfExpr(str, obj);
-				break;
-			case T_ScalarArrayOpExpr:
-				_outScalarArrayOpExpr(str, obj);
-				break;
-			case T_BoolExpr:
-				_outBoolExpr(str, obj);
-				break;
-			case T_SubLink:
-				_outSubLink(str, obj);
-				break;
-			case T_SubPlan:
-				_outSubPlan(str, obj);
-				break;
-			case T_AlternativeSubPlan:
-				_outAlternativeSubPlan(str, obj);
-				break;
-			case T_FieldSelect:
-				_outFieldSelect(str, obj);
-				break;
-			case T_FieldStore:
-				_outFieldStore(str, obj);
+				_outSimOpExpr(str, obj);
 				break;
 			case T_RelabelType:
-				_outRelabelType(str, obj);
-				break;
-			case T_CoerceViaIO:
-				_outCoerceViaIO(str, obj);
-				break;
-			case T_ArrayCoerceExpr:
-				_outArrayCoerceExpr(str, obj);
-				break;
-			case T_ConvertRowtypeExpr:
-				_outConvertRowtypeExpr(str, obj);
-				break;
-			case T_CollateExpr:
-				_outCollateExpr(str, obj);
-				break;
-			case T_CaseExpr:
-				_outCaseExpr(str, obj);
-				break;
-			case T_CaseWhen:
-				_outCaseWhen(str, obj);
-				break;
-			case T_CaseTestExpr:
-				_outCaseTestExpr(str, obj);
-				break;
-			case T_ArrayExpr:
-				_outArrayExpr(str, obj);
-				break;
-			case T_RowExpr:
-				_outRowExpr(str, obj);
-				break;
-			case T_RowCompareExpr:
-				_outRowCompareExpr(str, obj);
-				break;
-			case T_CoalesceExpr:
-				_outCoalesceExpr(str, obj);
-				break;
-			case T_MinMaxExpr:
-				_outMinMaxExpr(str, obj);
-				break;
-			case T_XmlExpr:
-				_outXmlExpr(str, obj);
-				break;
-			case T_NullTest:
-				_outNullTest(str, obj);
-				break;
-			case T_BooleanTest:
-				_outBooleanTest(str, obj);
-				break;
-			case T_CoerceToDomain:
-				_outCoerceToDomain(str, obj);
-				break;
-			case T_CoerceToDomainValue:
-				_outCoerceToDomainValue(str, obj);
-				break;
-			case T_SetToDefault:
-				_outSetToDefault(str, obj);
-				break;
-			case T_CurrentOfExpr:
-				_outCurrentOfExpr(str, obj);
-				break;
-			case T_TargetEntry:
-				_outTargetEntry(str, obj);
-				break;
-			case T_RangeTblRef:
-				_outRangeTblRef(str, obj);
-				break;
-			case T_JoinExpr:
-				_outJoinExpr(str, obj);
-				break;
-			case T_FromExpr:
-				_outFromExpr(str, obj);
-				break;
-
-			case T_Path:
-				_outPath(str, obj);
+				_outSimRelabelType(str, obj);
 				break;
-			case T_IndexPath:
-				_outIndexPath(str, obj);
-				break;
-			case T_BitmapHeapPath:
-				_outBitmapHeapPath(str, obj);
-				break;
-			case T_BitmapAndPath:
-				_outBitmapAndPath(str, obj);
-				break;
-			case T_BitmapOrPath:
-				_outBitmapOrPath(str, obj);
-				break;
-			case T_TidPath:
-				_outTidPath(str, obj);
-				break;
-			case T_ForeignPath:
-				_outForeignPath(str, obj);
-				break;
-			case T_AppendPath:
-				_outAppendPath(str, obj);
-				break;
-			case T_MergeAppendPath:
-				_outMergeAppendPath(str, obj);
-				break;
-			case T_ResultPath:
-				_outResultPath(str, obj);
-				break;
-			case T_MaterialPath:
-				_outMaterialPath(str, obj);
-				break;
-			case T_UniquePath:
-				_outUniquePath(str, obj);
-				break;
-			case T_NestPath:
-				_outNestPath(str, obj);
-				break;
-			case T_MergePath:
-				_outMergePath(str, obj);
-				break;
-			case T_HashPath:
-				_outHashPath(str, obj);
-				break;
-			case T_PlannerGlobal:
-				_outPlannerGlobal(str, obj);
-				break;
-			case T_PlannerInfo:
-				_outPlannerInfo(str, obj);
-				break;
-			case T_RelOptInfo:
-				_outRelOptInfo(str, obj);
-				break;
-			case T_IndexOptInfo:
-				_outIndexOptInfo(str, obj);
-				break;
-			case T_EquivalenceClass:
-				_outEquivalenceClass(str, obj);
-				break;
-			case T_EquivalenceMember:
-				_outEquivalenceMember(str, obj);
-				break;
-			case T_PathKey:
-				_outPathKey(str, obj);
-				break;
-			case T_ParamPathInfo:
-				_outParamPathInfo(str, obj);
+			case T_SubPlan:
+				_outSimSubPlan(str, obj);
 				break;
 			case T_RestrictInfo:
-				_outRestrictInfo(str, obj);
-				break;
-			case T_PlaceHolderVar:
-				_outPlaceHolderVar(str, obj);
-				break;
-			case T_SpecialJoinInfo:
-				_outSpecialJoinInfo(str, obj);
-				break;
-			case T_LateralJoinInfo:
-				_outLateralJoinInfo(str, obj);
-				break;
-			case T_AppendRelInfo:
-				_outAppendRelInfo(str, obj);
-				break;
-			case T_PlaceHolderInfo:
-				_outPlaceHolderInfo(str, obj);
-				break;
-			case T_MinMaxAggInfo:
-				_outMinMaxAggInfo(str, obj);
-				break;
-			case T_PlannerParamItem:
-				_outPlannerParamItem(str, obj);
+				_outSimRestrictInfo(str, obj);
 				break;
-
-			case T_CreateStmt:
-				_outCreateStmt(str, obj);
-				break;
-			case T_CreateForeignTableStmt:
-				_outCreateForeignTableStmt(str, obj);
-				break;
-			case T_IndexStmt:
-				_outIndexStmt(str, obj);
-				break;
-			case T_NotifyStmt:
-				_outNotifyStmt(str, obj);
-				break;
-			case T_DeclareCursorStmt:
-				_outDeclareCursorStmt(str, obj);
-				break;
-			case T_SelectStmt:
-				_outSelectStmt(str, obj);
-				break;
-			case T_ColumnDef:
-				_outColumnDef(str, obj);
-				break;
-			case T_TypeName:
-				_outTypeName(str, obj);
-				break;
-			case T_TypeCast:
-				_outTypeCast(str, obj);
-				break;
-			case T_CollateClause:
-				_outCollateClause(str, obj);
-				break;
-			case T_IndexElem:
-				_outIndexElem(str, obj);
-				break;
-			case T_Query:
-				_outQuery(str, obj);
-				break;
-			case T_WithCheckOption:
-				_outWithCheckOption(str, obj);
-				break;
-			case T_SortGroupClause:
-				_outSortGroupClause(str, obj);
-				break;
-			case T_WindowClause:
-				_outWindowClause(str, obj);
-				break;
-			case T_RowMarkClause:
-				_outRowMarkClause(str, obj);
-				break;
-			case T_WithClause:
-				_outWithClause(str, obj);
-				break;
-			case T_CommonTableExpr:
-				_outCommonTableExpr(str, obj);
-				break;
-			case T_SetOperationStmt:
-				_outSetOperationStmt(str, obj);
-				break;
-			case T_RangeTblEntry:
-				_outRangeTblEntry(str, obj);
-				break;
-			case T_RangeTblFunction:
-				_outRangeTblFunction(str, obj);
-				break;
-			case T_A_Expr:
-				_outAExpr(str, obj);
-				break;
-			case T_ColumnRef:
-				_outColumnRef(str, obj);
-				break;
-			case T_ParamRef:
-				_outParamRef(str, obj);
-				break;
-			case T_A_Const:
-				_outAConst(str, obj);
-				break;
-			case T_A_Star:
-				_outA_Star(str, obj);
-				break;
-			case T_A_Indices:
-				_outA_Indices(str, obj);
-				break;
-			case T_A_Indirection:
-				_outA_Indirection(str, obj);
-				break;
-			case T_A_ArrayExpr:
-				_outA_ArrayExpr(str, obj);
-				break;
-			case T_ResTarget:
-				_outResTarget(str, obj);
-				break;
-			case T_SortBy:
-				_outSortBy(str, obj);
-				break;
-			case T_WindowDef:
-				_outWindowDef(str, obj);
-				break;
-			case T_RangeSubselect:
-				_outRangeSubselect(str, obj);
-				break;
-			case T_RangeFunction:
-				_outRangeFunction(str, obj);
-				break;
-			case T_Constraint:
-				_outConstraint(str, obj);
-				break;
-			case T_FuncCall:
-				_outFuncCall(str, obj);
-				break;
-			case T_DefElem:
-				_outDefElem(str, obj);
-				break;
-			case T_TableLikeClause:
-				_outTableLikeClause(str, obj);
-				break;
-			case T_LockingClause:
-				_outLockingClause(str, obj);
-				break;
-			case T_XmlSerialize:
-				_outXmlSerialize(str, obj);
-				break;
-
 			default:
 
 				/*
 				 * This should be an ERROR, but it's too useful to be able to
 				 * dump structures that _outNode only understands part of.
 				 */
-				elog(WARNING, "could not dump unrecognized node type: %d",
-					 (int) nodeTag(obj));
+				elog(WARNING,
+						"could not dump unrecognized node type: %d", (int) nodeTag(obj));
 				break;
+			}
+			if (nodeTag(obj) != T_RestrictInfo) {
+				appendStringInfoChar(str, '}');
+
+			}
 		}
-		appendStringInfoChar(str, '}');
+
 	}
 }
 
-/*
- * nodeToString -
- *	   returns the ascii representation of the Node as a palloc'd string
- */
-char *
-nodeToString(const void *obj)
-{
-	StringInfoData str;
-
-	/* see stringinfo.h for an explanation of this maneuver */
-	initStringInfo(&str);
-	_outNode(&str, obj);
-	return str.data;
-}
diff --git a/src/backend/optimizer/path/clausesel.c b/src/backend/optimizer/path/clausesel.c
index efeea37..173110d 100644
--- a/src/backend/optimizer/path/clausesel.c
+++ b/src/backend/optimizer/path/clausesel.c
@@ -24,6 +24,9 @@
 #include "utils/lsyscache.h"
 #include "utils/selfuncs.h"
 
+#define SELECTIVITY_DEBUG 1
+
+
 
 /*
  * Data structure for accumulating info about possible range-query
@@ -776,9 +779,9 @@ clause_selectivity(PlannerInfo *root,
 			rinfo->outer_selec = s1;
 	}
 
-#ifdef SELECTIVITY_DEBUG
-	elog(DEBUG4, "clause_selectivity: s1 %f", s1);
-#endif   /* SELECTIVITY_DEBUG */
+
+	elog(DEBUG4, "clause_selectivity: s1 %.30f", s1);
+  /* SELECTIVITY_DEBUG */
 
 	return s1;
 }
diff --git a/src/backend/optimizer/path/costsize.c b/src/backend/optimizer/path/costsize.c
index a8369fc..a9d3c5a 100644
--- a/src/backend/optimizer/path/costsize.c
+++ b/src/backend/optimizer/path/costsize.c
@@ -24,7 +24,7 @@
  *
  * Obviously, taking constants for these values is an oversimplification,
  * but it's tough enough to get any useful estimates even at this level of
- * detail.	Note that all of these parameters are user-settable, in case
+ * detail.  Note that all of these parameters are user-settable, in case
  * the default values are drastically off for a particular platform.
  *
  * seq_page_cost and random_page_cost can also be overridden for an individual
@@ -67,6 +67,7 @@
  */
 
 #include "postgres.h"
+#include "postgres.h"
 
 #ifdef _MSC_VER
 #include <float.h>				/* for _isnan */
@@ -79,6 +80,7 @@
 #include "executor/nodeHash.h"
 #include "miscadmin.h"
 #include "nodes/nodeFuncs.h"
+#include "nodes/print.h"
 #include "optimizer/clauses.h"
 #include "optimizer/cost.h"
 #include "optimizer/pathnode.h"
@@ -93,6 +95,8 @@
 #include "utils/selfuncs.h"
 #include "utils/spccache.h"
 #include "utils/tuplesort.h"
+#include "lib/stringinfo.h"
+#include "nodes/outfuncs.h"
 
 #define LOG2(x)  (log(x) / 0.693147180559945)
 
@@ -102,10 +106,12 @@ double cpu_tuple_cost = DEFAULT_CPU_TUPLE_COST;
 double cpu_index_tuple_cost = DEFAULT_CPU_INDEX_TUPLE_COST;
 double cpu_operator_cost = DEFAULT_CPU_OPERATOR_COST;
 
-int effective_cache_size = -1; /* will get replaced */
+int effective_cache_size = -1;
 
 Cost disable_cost = 1.0e10;
 
+bool enable_memo = false;
+bool mode_cost_check = false;
 bool enable_seqscan = true;
 bool enable_indexscan = true;
 bool enable_indexonlyscan = true;
@@ -117,8 +123,6 @@ bool enable_nestloop = true;
 bool enable_material = true;
 bool enable_mergejoin = true;
 bool enable_hashjoin = true;
-bool enable_memo = false;
-bool mode_cost_check = false;
 
 typedef struct {
 	PlannerInfo *root;
@@ -172,21 +176,13 @@ void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	double spc_seq_page_cost;
 	QualCost qpqual_cost;
 	Cost cpu_per_tuple;
-	path->memo_checked = false;
-
-	/* Should only be applied to base relations
-	 Assert(baserel->relid > 0);
-	 Assert(baserel->rtekind == RTE_RELATION);
 
-	 /* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
+	/* Should only be applied to base relations */
+	Assert(baserel->relid > 0);
+	Assert(baserel->rtekind == RTE_RELATION);
 
-		}
-	} else if (param_info)
+	/* Mark the path with the correct row estimate */
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -207,16 +203,10 @@ void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
-
 	run_cost += cpu_per_tuple * baserel->tuples;
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
 
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -261,30 +251,13 @@ void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-
 	if (path->path.param_info) {
-		if (mode_cost_check) {
-			path->path.rows = get_baserel_memo_size(path->path.parent->rel_name,
-					root->query_level);
-			if (path->path.rows >= 0) {
-				path->path.memo_checked = true;
-
-			}
-		} else
-			path->path.rows = path->path.param_info->ppi_rows;
+		path->path.rows = path->path.param_info->ppi_rows;
 		/* also get the set of clauses that should be enforced by the scan */
 		allclauses = list_concat(list_copy(path->path.param_info->ppi_clauses),
 				baserel->baserestrictinfo);
 	} else {
-		if (mode_cost_check) {
-			path->path.rows = get_baserel_memo_size(path->path.parent->rel_name,
-					root->query_level);
-			if (path->path.rows >= 0) {
-				path->path.memo_checked = true;
-
-			}
-		} else
-			path->path.rows = baserel->rows;
+		path->path.rows = baserel->rows;
 		/* allclauses should just be the rel's restriction clauses */
 		allclauses = baserel->baserestrictinfo;
 	}
@@ -319,7 +292,6 @@ void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
 	run_cost += indexTotalCost - indexStartupCost;
 
 	/* estimate number of main-table tuples fetched */
-
 	tuples_fetched = clamp_row_est(indexSelectivity * baserel->tuples);
 
 	/* fetch estimated page costs for tablespace containing table */
@@ -446,14 +418,13 @@ void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
-	if (mode_cost_check) {
-		path->path.mstartup_cost = startup_cost;
-		path->path.mtotal_cost = startup_cost + run_cost;
 
-	} else {
-		path->path.startup_cost = startup_cost;
+	path->path.startup_cost = startup_cost;
+	if (mode_cost_check)
+		path->path.mtotal_cost = startup_cost + run_cost;
+	else
 		path->path.total_cost = startup_cost + run_cost;
-	}
+
 }
 
 /*
@@ -491,7 +462,7 @@ void cost_index(IndexPath *path, PlannerInfo *root, double loop_count) {
  * computed for us by query_planner.
  *
  * Caller is expected to have ensured that tuples_fetched is greater than zero
- * and rounded to integer (see clamp_row_est).	The result will likewise be
+ * and rounded to integer (see clamp_row_est).  The result will likewise be
  * greater than zero and integral.
  */
 double index_pages_fetched(double tuples_fetched, BlockNumber pages,
@@ -601,7 +572,6 @@ void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	double pages_fetched;
 	double spc_seq_page_cost, spc_random_page_cost;
 	double T;
-	path->memo_checked = false;
 
 	/* Should only be applied to base relations */
 	Assert(IsA(baserel, RelOptInfo));
@@ -609,14 +579,7 @@ void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
-
-		}
-	} else if (param_info)
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -669,7 +632,7 @@ void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	/*
 	 * For small numbers of pages we should charge spc_random_page_cost
 	 * apiece, while if nearly all the table's pages are being read, it's more
-	 * appropriate to charge spc_seq_page_cost apiece.	The effect is
+	 * appropriate to charge spc_seq_page_cost apiece.  The effect is
 	 * nonlinear, too. For lack of a better idea, interpolate like this to
 	 * determine the cost per page.
 	 */
@@ -697,14 +660,9 @@ void cost_bitmap_heap_scan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 
 	run_cost += cpu_per_tuple * tuples_fetched;
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
 
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -740,7 +698,7 @@ void cost_bitmap_tree_node(Path *path, Cost *cost, Selectivity *selec) {
  *		Estimate the cost of a BitmapAnd node
  *
  * Note that this considers only the costs of index scanning and bitmap
- * creation, not the eventual heap access.	In that sense the object isn't
+ * creation, not the eventual heap access.  In that sense the object isn't
  * truly a Path, but it has enough path-like properties (costs in particular)
  * to warrant treating it as one.  We don't bother to set the path rows field,
  * however.
@@ -794,7 +752,7 @@ void cost_bitmap_or_node(BitmapOrPath *path, PlannerInfo *root) {
 	/*
 	 * We estimate OR selectivity on the assumption that the inputs are
 	 * non-overlapping, since that's often the case in "x IN (list)" type
-	 * situations.	Of course, we clamp to 1.0 at the end.
+	 * situations.  Of course, we clamp to 1.0 at the end.
 	 *
 	 * The runtime cost of the BitmapOr itself is estimated at 100x
 	 * cpu_operator_cost for each tbm_union needed.  Probably too small,
@@ -841,28 +799,19 @@ void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	int ntuples;
 	ListCell *l;
 	double spc_random_page_cost;
-	path->memo_checked = false;
 
 	/* Should only be applied to base relations */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_RELATION);
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
-
-		}
-	} else if (param_info)
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
 	/* Count how many tuples we expect to retrieve */
 	ntuples = 0;
-
 	foreach(l, tidquals) {
 		if (IsA(lfirst(l), ScalarArrayOpExpr)) {
 			/* Each element of the array yields 1 tuple */
@@ -882,7 +831,7 @@ void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 
 	/*
 	 * We must force TID scan for WHERE CURRENT OF, because only nodeTidscan.c
-	 * understands how to do it correctly.	Therefore, honor enable_tidscan
+	 * understands how to do it correctly.  Therefore, honor enable_tidscan
 	 * only when CURRENT OF isn't present.  Also note that cost_qual_eval
 	 * counts a CurrentOfExpr as having startup cost disable_cost, which we
 	 * subtract off here; that's to prevent other plan types such as seqscan
@@ -916,14 +865,8 @@ void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 			- tid_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
 
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
-
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -939,30 +882,17 @@ void cost_subqueryscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Cost run_cost;
 	QualCost qpqual_cost;
 	Cost cpu_per_tuple;
-	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are subqueries */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_SUBQUERY);
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
-
-		}
-	} else if (param_info)
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
 
-	if (mode_cost_check) {
-
-		;
-	} else {
-	}
 	/*
 	 * Cost of path is cost of evaluating the subplan, plus cost of evaluating
 	 * any restriction clauses that will be attached to the SubqueryScan node,
@@ -1013,7 +943,7 @@ void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	 *
 	 * Currently, nodeFunctionscan.c always executes the functions to
 	 * completion before returning any rows, and caches the results in a
-	 * tuplestore.	So the function eval cost is all startup cost, and per-row
+	 * tuplestore.  So the function eval cost is all startup cost, and per-row
 	 * costs are minimal.
 	 *
 	 * XXX in principle we ought to charge tuplestore spill costs if the
@@ -1021,11 +951,6 @@ void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	 * estimates for functions tend to be, there's not a lot of point in that
 	 * refinement right now.
 	 */
-	if (mode_cost_check) {
-
-		;
-	} else {
-	}
 	cost_qual_eval_node(&exprcost, (Node *) rte->functions, root);
 
 	startup_cost += exprcost.startup + exprcost.per_tuple;
@@ -1036,14 +961,9 @@ void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
 
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -1059,21 +979,13 @@ void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Cost run_cost = 0;
 	QualCost qpqual_cost;
 	Cost cpu_per_tuple;
-	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are values lists */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_VALUES);
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
-
-		}
-	} else if (param_info)
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1082,12 +994,6 @@ void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	 * For now, estimate list evaluation cost at one operator eval per list
 	 * (probably pretty bogus, but is it worth being smarter?)
 	 */
-
-	if (mode_cost_check) {
-
-		;
-	} else {
-	}
 	cpu_per_tuple = cpu_operator_cost;
 
 	/* Add scanning CPU costs */
@@ -1096,14 +1002,9 @@ void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	startup_cost += qpqual_cost.startup;
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
 
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -1112,7 +1013,7 @@ void cost_valuesscan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
  *
  * Note: this is used for both self-reference and regular CTEs; the
  * possible cost differences are below the threshold of what we could
- * estimate accurately anyway.	Note that the costs of evaluating the
+ * estimate accurately anyway.  Note that the costs of evaluating the
  * referenced CTE query are added into the final plan as initplan costs,
  * and should NOT be counted here.
  */
@@ -1122,21 +1023,13 @@ void cost_ctescan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	Cost run_cost = 0;
 	QualCost qpqual_cost;
 	Cost cpu_per_tuple;
-	path->memo_checked = false;
 
 	/* Should only be applied to base relations that are CTEs */
 	Assert(baserel->relid > 0);
 	Assert(baserel->rtekind == RTE_CTE);
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->rows = get_baserel_memo_size(path->parent->rel_name,
-				root->query_level);
-		if (path->rows >= 0) {
-			path->memo_checked = true;
-
-		}
-	} else if (param_info)
+	if (param_info)
 		path->rows = param_info->ppi_rows;
 	else
 		path->rows = baserel->rows;
@@ -1151,14 +1044,8 @@ void cost_ctescan(Path *path, PlannerInfo *root, RelOptInfo *baserel,
 	cpu_per_tuple += cpu_tuple_cost + qpqual_cost.per_tuple;
 	run_cost += cpu_per_tuple * baserel->tuples;
 
-	if (mode_cost_check) {
-		path->mstartup_cost = startup_cost;
-		path->mtotal_cost = startup_cost + run_cost;
-
-	} else {
-		path->startup_cost = startup_cost;
-		path->total_cost = startup_cost + run_cost;
-	}
+	path->startup_cost = startup_cost;
+	path->total_cost = startup_cost + run_cost;
 }
 
 /*
@@ -1216,7 +1103,7 @@ void cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm) {
  * If the total volume exceeds sort_mem, we switch to a tape-style merge
  * algorithm.  There will still be about t*log2(t) tuple comparisons in
  * total, but we will also need to write and read each tuple once per
- * merge pass.	We expect about ceil(logM(r)) merge passes where r is the
+ * merge pass.  We expect about ceil(logM(r)) merge passes where r is the
  * number of initial runs formed and M is the merge order used by tuplesort.c.
  * Since the average initial run should be about twice sort_mem, we have
  *		disk traffic = 2 * relsize * ceil(logM(p / (2*sort_mem)))
@@ -1230,7 +1117,7 @@ void cost_recursive_union(Plan *runion, Plan *nrterm, Plan *rterm) {
  * accesses (XXX can't we refine that guess?)
  *
  * By default, we charge two operator evals per tuple comparison, which should
- * be in the right ballpark in most cases.	The caller can tweak this by
+ * be in the right ballpark in most cases.  The caller can tweak this by
  * specifying nonzero comparison_cost; typically that's used for any extra
  * work that has to be done to prepare the inputs to the comparison operators.
  *
@@ -1343,7 +1230,7 @@ void cost_sort(Path *path, PlannerInfo *root, List *pathkeys, Cost input_cost,
  *	  Determines and returns the cost of a MergeAppend node.
  *
  * MergeAppend merges several pre-sorted input streams, using a heap that
- * at any given instant holds the next tuple from each stream.	If there
+ * at any given instant holds the next tuple from each stream.  If there
  * are N streams, we need about N*log2(N) tuple comparisons to construct
  * the heap at startup, and then for each output tuple, about log2(N)
  * comparisons to delete the top heap entry and another log2(N) comparisons
@@ -1490,7 +1377,7 @@ void cost_agg(Path *path, PlannerInfo *root, AggStrategy aggstrategy,
 	 * group otherwise.  We charge cpu_tuple_cost for each output tuple.
 	 *
 	 * Note: in this cost model, AGG_SORTED and AGG_HASHED have exactly the
-	 * same total CPU cost, but AGG_SORTED has lower startup cost.	If the
+	 * same total CPU cost, but AGG_SORTED has lower startup cost.  If the
 	 * input path is already sorted appropriately, AGG_SORTED should be
 	 * preferred (since it has no risk of memory overflow).  This will happen
 	 * as long as the computed total costs are indeed exactly equal --- but if
@@ -1658,13 +1545,16 @@ void initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 		SpecialJoinInfo *sjinfo, SemiAntiJoinFactors *semifactors) {
 	Cost startup_cost = 0;
 	Cost run_cost = 0;
-	double outer_path_rows = outer_path->rows;
+	double outer_path_rows =
+			mode_cost_check ? outer_path->mrows : outer_path->rows;
 	Cost inner_rescan_start_cost;
 	Cost inner_rescan_total_cost;
 	Cost inner_run_cost;
 	Cost inner_rescan_run_cost;
-
-	workspace->semifactors = semifactors;
+	double outercost =
+			mode_cost_check ? outer_path->mtotal_cost : outer_path->total_cost;
+	double innercost =
+			mode_cost_check ? inner_path->mtotal_cost : inner_path->total_cost;
 	/* estimate costs to rescan the inner relation */
 	cost_rescan(root, inner_path, &inner_rescan_start_cost,
 			&inner_rescan_total_cost);
@@ -1677,23 +1567,12 @@ void initial_cost_nestloop(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * their sum.  We'll also pay the inner path's rescan startup cost
 	 * multiple times.
 	 */
-	if (mode_cost_check) {
-		startup_cost += outer_path->mstartup_cost + inner_path->mstartup_cost;
-		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
-		if (outer_path_rows > 1)
-			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
-
-		inner_run_cost = inner_path->mtotal_cost - inner_path->mstartup_cost;
-
-	} else {
-		startup_cost += outer_path->startup_cost + inner_path->startup_cost;
-		run_cost += outer_path->total_cost - outer_path->startup_cost;
-		if (outer_path_rows > 1)
-			run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
+	startup_cost += outer_path->startup_cost + inner_path->startup_cost;
+	run_cost += outercost - outer_path->startup_cost;
+	if (outer_path_rows > 1)
+		run_cost += (outer_path_rows - 1) * inner_rescan_start_cost;
 
-		inner_run_cost = inner_path->total_cost - inner_path->startup_cost;
-
-	}
+	inner_run_cost = innercost - inner_path->startup_cost;
 	inner_rescan_run_cost = inner_rescan_total_cost - inner_rescan_start_cost;
 
 	if (jointype == JOIN_SEMI || jointype == JOIN_ANTI) {
@@ -1768,25 +1647,19 @@ void final_cost_nestloop(PlannerInfo *root, NestPath *path,
 		SemiAntiJoinFactors *semifactors) {
 	Path *outer_path = path->outerjoinpath;
 	Path *inner_path = path->innerjoinpath;
-	double outer_path_rows = outer_path->rows;
-	double inner_path_rows = inner_path->rows;
+	double outer_path_rows =
+			mode_cost_check ? outer_path->mrows : outer_path->rows;
+	double inner_path_rows =
+			mode_cost_check ? inner_path->mrows : inner_path->rows;
 	Cost startup_cost = workspace->startup_cost;
 	Cost run_cost = workspace->run_cost;
 	Cost inner_rescan_run_cost = workspace->inner_rescan_run_cost;
 	Cost cpu_per_tuple;
 	QualCost restrict_qual_cost;
 	double ntuples;
-	path->path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->path.rows = get_join_memo_size(path->path.parent->rel_name,
-				root->query_level);
-		if (path->path.rows >= 0) {
-			path->path.memo_checked = true;
-
-		}
-	} else if (path->path.param_info)
+	if (path->path.param_info)
 		path->path.rows = path->path.param_info->ppi_rows;
 	else
 		path->path.rows = path->path.parent->rows;
@@ -1845,14 +1718,17 @@ void final_cost_nestloop(PlannerInfo *root, NestPath *path,
 	startup_cost += restrict_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + restrict_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * ntuples;
+
+	path->path.startup_cost = startup_cost;
 	if (mode_cost_check) {
-		path->path.mstartup_cost = startup_cost;
 		path->path.mtotal_cost = startup_cost + run_cost;
-
-	} else {
-		path->path.startup_cost = startup_cost;
+		path->path.mstartup_cost = startup_cost;
+	} else
 		path->path.total_cost = startup_cost + run_cost;
-	}
+
+	if (!mode_cost_check)
+		printf("final nested loop %s cost is %.2f\n",
+				path->path.parent->rel_name, path->path.total_cost);
 }
 
 /*
@@ -1891,14 +1767,18 @@ void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 		SpecialJoinInfo *sjinfo) {
 	Cost startup_cost = 0;
 	Cost run_cost = 0;
-	double outer_path_rows = mode_cost_check ? 0 : outer_path->rows;
-	double inner_path_rows = mode_cost_check ? 0 : inner_path->rows;
-
+	double outer_path_rows =
+			mode_cost_check ? outer_path->mrows : outer_path->rows;
+	double inner_path_rows =
+			mode_cost_check ? inner_path->mrows : inner_path->rows;
 	Cost inner_run_cost;
 	double outer_rows, inner_rows, outer_skip_rows, inner_skip_rows;
 	Selectivity outerstartsel, outerendsel, innerstartsel, innerendsel;
 	Path sort_path; /* dummy for result of cost_sort */
-
+	double outercost =
+			mode_cost_check ? outer_path->mtotal_cost : outer_path->total_cost;
+	double innercost =
+			mode_cost_check ? inner_path->mtotal_cost : inner_path->total_cost;
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (outer_path_rows <= 0 || isnan(outer_path_rows))
 		outer_path_rows = 1;
@@ -1995,78 +1875,37 @@ void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	Assert(innerstartsel <= innerendsel);
 
 	/* cost of source data */
+
 	if (outersortkeys) /* do we need to sort outer? */
 	{
-
-		if (mode_cost_check) {
-			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
-					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
-					-1.0);
-		} else {
-
-			cost_sort(&sort_path, root, outersortkeys, outer_path->mtotal_cost,
-					outer_path_rows, outer_path->parent->width, 0.0, work_mem,
-					-1.0);
-		}
-
+		cost_sort(&sort_path, root, outersortkeys, outercost, outer_path_rows,
+				outer_path->parent->width, 0.0, work_mem, -1.0);
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
 				* outerstartsel;
 		run_cost += (sort_path.total_cost - sort_path.startup_cost)
 				* (outerendsel - outerstartsel);
-
 	} else {
-
-		if (mode_cost_check) {
-			startup_cost += outer_path->mstartup_cost;
-			startup_cost +=
-					(outer_path->mtotal_cost - outer_path->mstartup_cost)
-							* outerstartsel;
-			run_cost += (outer_path->mtotal_cost - outer_path->mstartup_cost)
-					* (outerendsel - outerstartsel);
-		} else {
-			startup_cost += outer_path->startup_cost;
-			startup_cost += (outer_path->total_cost - outer_path->startup_cost)
-					* outerstartsel;
-			run_cost += (outer_path->total_cost - outer_path->startup_cost)
-					* (outerendsel - outerstartsel);
-		}
-
+		startup_cost += outer_path->startup_cost;
+		startup_cost += (outercost - outer_path->startup_cost) * outerstartsel;
+		run_cost += (outercost - outer_path->startup_cost)
+				* (outerendsel - outerstartsel);
 	}
 
 	if (innersortkeys) /* do we need to sort inner? */
 	{
-		if (mode_cost_check) {
-			cost_sort(&sort_path, root, innersortkeys, inner_path->mtotal_cost,
-					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
-					-1.0);
-		} else {
-			cost_sort(&sort_path, root, innersortkeys, inner_path->total_cost,
-					inner_path_rows, inner_path->parent->width, 0.0, work_mem,
-					-1.0);
-		}
+		cost_sort(&sort_path, root, innersortkeys, innercost, inner_path_rows,
+				inner_path->parent->width, 0.0, work_mem, -1.0);
 		startup_cost += sort_path.startup_cost;
 		startup_cost += (sort_path.total_cost - sort_path.startup_cost)
 				* innerstartsel;
 		inner_run_cost = (sort_path.total_cost - sort_path.startup_cost)
 				* (innerendsel - innerstartsel);
 	} else {
-
-		if (mode_cost_check) {
-			startup_cost += inner_path->mstartup_cost;
-			startup_cost +=
-					(inner_path->mtotal_cost - inner_path->mstartup_cost)
-							* innerstartsel;
-			inner_run_cost = (inner_path->mtotal_cost
-					- inner_path->mstartup_cost)
-					* (innerendsel - innerstartsel);
-		} else {
-			startup_cost += inner_path->startup_cost;
-			startup_cost += (inner_path->total_cost - inner_path->startup_cost)
-					* innerstartsel;
-			inner_run_cost = (inner_path->total_cost - inner_path->startup_cost)
-					* (innerendsel - innerstartsel);
-		}
+		startup_cost += inner_path->startup_cost;
+		startup_cost += (innercost - inner_path->startup_cost) * innerstartsel;
+		inner_run_cost = (innercost - inner_path->startup_cost)
+				* (innerendsel - innerstartsel);
 	}
 
 	/*
@@ -2085,8 +1924,10 @@ void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	/* Save private data for final_cost_mergejoin */
 	workspace->run_cost = run_cost;
 	workspace->inner_run_cost = inner_run_cost;
+
 	workspace->outer_rows = outer_rows;
 	workspace->inner_rows = inner_rows;
+
 	workspace->outer_skip_rows = outer_skip_rows;
 	workspace->inner_skip_rows = inner_skip_rows;
 }
@@ -2098,10 +1939,10 @@ void initial_cost_mergejoin(PlannerInfo *root, JoinCostWorkspace *workspace,
  * Unlike other costsize functions, this routine makes one actual decision:
  * whether we should materialize the inner path.  We do that either because
  * the inner path can't support mark/restore, or because it's cheaper to
- * use an interposed Material node to handle mark/restore.	When the decision
+ * use an interposed Material node to handle mark/restore.  When the decision
  * is cost-based it would be logically cleaner to build and cost two separate
  * paths with and without that flag set; but that would require repeating most
- * of the cost calculations, which are not all that cheap.	Since the choice
+ * of the cost calculations, which are not all that cheap.  Since the choice
  * will not affect output pathkeys or startup cost, only total cost, there is
  * no possibility of wanting to keep both paths.  So it seems best to make
  * the decision here and record it in the path's materialize_inner field.
@@ -2115,7 +1956,8 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo) {
 	Path *outer_path = path->jpath.outerjoinpath;
 	Path *inner_path = path->jpath.innerjoinpath;
-	double inner_path_rows = inner_path->rows;
+	double inner_path_rows =
+			mode_cost_check ? inner_path->mrows : inner_path->rows;
 	List *mergeclauses = path->path_mergeclauses;
 	List *innersortkeys = path->innersortkeys;
 	Cost startup_cost = workspace->startup_cost;
@@ -2130,21 +1972,13 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	QualCost qp_qual_cost;
 	double mergejointuples, rescannedtuples;
 	double rescanratio;
-	path->jpath.path.memo_checked = false;
 
 	/* Protect some assumptions below that rowcounts aren't zero or NaN */
 	if (inner_path_rows <= 0 || isnan(inner_path_rows))
 		inner_path_rows = 1;
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->jpath.path.rows = get_join_memo_size(
-				path->jpath.path.parent->rel_name, root->query_level);
-		if (path->jpath.path.rows >= 0) {
-			path->jpath.path.memo_checked = true;
-
-		}
-	} else if (path->jpath.path.param_info)
+	if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2167,7 +2001,7 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	qp_qual_cost.per_tuple -= merge_qual_cost.per_tuple;
 
 	/*
-	 * Get approx # tuples passing the mergequals.	We use approx_tuple_count
+	 * Get approx # tuples passing the mergequals.  We use approx_tuple_count
 	 * here because we need an estimate done with JOIN_INNER semantics.
 	 */
 	mergejointuples = approx_tuple_count(root, &path->jpath, mergeclauses);
@@ -2181,7 +2015,7 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * estimated approximately as size of merge join output minus size of
 	 * inner relation. Assume that the distinct key values are 1, 2, ..., and
 	 * denote the number of values of each key in the outer relation as m1,
-	 * m2, ...; in the inner relation, n1, n2, ...	Then we have
+	 * m2, ...; in the inner relation, n1, n2, ...  Then we have
 	 *
 	 * size of join = m1 * n1 + m2 * n2 + ...
 	 *
@@ -2192,7 +2026,7 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	 * This equation works correctly for outer tuples having no inner match
 	 * (nk = 0), but not for inner tuples having no outer match (mk = 0); we
 	 * are effectively subtracting those from the number of rescanned tuples,
-	 * when we should not.	Can we do better without expensive selectivity
+	 * when we should not.  Can we do better without expensive selectivity
 	 * computations?
 	 *
 	 * The whole issue is moot if we are working from a unique-ified outer
@@ -2211,7 +2045,7 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 
 	/*
 	 * Decide whether we want to materialize the inner input to shield it from
-	 * mark/restore and performing re-fetches.	Our cost model for regular
+	 * mark/restore and performing re-fetches.  Our cost model for regular
 	 * re-fetches is that a re-fetch costs the same as an original fetch,
 	 * which is probably an overestimate; but on the other hand we ignore the
 	 * bookkeeping costs of mark/restore.  Not clear if it's worth developing
@@ -2304,7 +2138,7 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	/*
 	 * For each tuple that gets through the mergejoin proper, we charge
 	 * cpu_tuple_cost plus the cost of evaluating additional restriction
-	 * clauses that are to be applied at the join.	(This is pessimistic since
+	 * clauses that are to be applied at the join.  (This is pessimistic since
 	 * not all of the quals may get evaluated at each tuple.)
 	 *
 	 * Note: we could adjust for SEMI/ANTI joins skipping some qual
@@ -2313,14 +2147,16 @@ void final_cost_mergejoin(PlannerInfo *root, MergePath *path,
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * mergejointuples;
+
+	path->jpath.path.startup_cost = startup_cost;
 	if (mode_cost_check) {
-		path->jpath.path.mstartup_cost = startup_cost;
 		path->jpath.path.mtotal_cost = startup_cost + run_cost;
-
-	} else {
-		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.mstartup_cost = startup_cost;
+	} else
 		path->jpath.path.total_cost = startup_cost + run_cost;
-	}
+	if (!mode_cost_check)
+		printf("final merge join %s cost is %.2f\n",
+				path->jpath.path.parent->rel_name, path->jpath.path.total_cost);
 }
 
 /*
@@ -2396,29 +2232,33 @@ void initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 		JoinType jointype, List *hashclauses, Path *outer_path,
 		Path *inner_path, SpecialJoinInfo *sjinfo,
 		SemiAntiJoinFactors *semifactors) {
-
 	Cost startup_cost = 0;
 	Cost run_cost = 0;
-	double outer_path_rows = outer_path->rows;
-	double inner_path_rows = inner_path->rows;
+	double outer_path_rows =
+			mode_cost_check ? outer_path->mrows : outer_path->rows;
+	double inner_path_rows =
+			mode_cost_check ? inner_path->mrows : inner_path->rows;
 	int num_hashclauses = list_length(hashclauses);
 	int numbuckets;
 	int numbatches;
 	int num_skew_mcvs;
-
-	workspace->semifactors = semifactors;
-
+	double outercost =
+			mode_cost_check ? outer_path->mtotal_cost : outer_path->total_cost;
+	double innercost =
+			mode_cost_check ? inner_path->mtotal_cost : inner_path->total_cost;
 	/* cost of source data */
 	if (mode_cost_check) {
 		startup_cost += outer_path->mstartup_cost;
-		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
-		startup_cost += inner_path->total_cost;
+
+		run_cost += outercost - outer_path->mstartup_cost;
 	} else {
-		startup_cost += outer_path->mstartup_cost;
-		run_cost += outer_path->mtotal_cost - outer_path->mstartup_cost;
-		startup_cost += inner_path->mtotal_cost;
+		startup_cost += outer_path->startup_cost;
+
+		run_cost += outercost - outer_path->startup_cost;
 	}
 
+	startup_cost += innercost;
+
 	/*
 	 * Cost of computing hash function: must do it once per input tuple. We
 	 * charge one cpu_operator_cost for each column's hash function.  Also,
@@ -2450,7 +2290,7 @@ void initial_cost_hashjoin(PlannerInfo *root, JoinCostWorkspace *workspace,
 	 * If inner relation is too big then we will need to "batch" the join,
 	 * which implies writing and reading most of the tuples to disk an extra
 	 * time.  Charge seq_page_cost per page, since the I/O should be nice and
-	 * sequential.	Writing the inner rel counts as startup cost, all the rest
+	 * sequential.  Writing the inner rel counts as startup cost, all the rest
 	 * as run cost.
 	 */
 	if (numbatches > 1) {
@@ -2491,8 +2331,10 @@ void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		SemiAntiJoinFactors *semifactors) {
 	Path *outer_path = path->jpath.outerjoinpath;
 	Path *inner_path = path->jpath.innerjoinpath;
-	double outer_path_rows = outer_path->rows;
-	double inner_path_rows = inner_path->rows;
+	double outer_path_rows =
+			mode_cost_check ? outer_path->mrows : outer_path->rows;
+	double inner_path_rows =
+			mode_cost_check ? inner_path->mrows : inner_path->rows;
 	List *hashclauses = path->path_hashclauses;
 	Cost startup_cost = workspace->startup_cost;
 	Cost run_cost = workspace->run_cost;
@@ -2505,17 +2347,9 @@ void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 	double virtualbuckets;
 	Selectivity innerbucketsize;
 	ListCell *hcl;
-	path->jpath.path.memo_checked = false;
 
 	/* Mark the path with the correct row estimate */
-	if (mode_cost_check) {
-		path->jpath.path.rows = get_join_memo_size(
-				path->jpath.path.parent->rel_name, root->query_level);
-		if (path->jpath.path.rows >= 0) {
-			path->jpath.path.memo_checked = true;
-
-		}
-	} else if (path->jpath.path.param_info)
+	if (path->jpath.path.param_info)
 		path->jpath.path.rows = path->jpath.path.param_info->ppi_rows;
 	else
 		path->jpath.path.rows = path->jpath.path.parent->rows;
@@ -2645,10 +2479,12 @@ void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 				* clamp_row_est(inner_path_rows / virtualbuckets) * 0.05;
 
 		/* Get # of tuples that will pass the basic join */
+
 		if (path->jpath.jointype == JOIN_SEMI)
 			hashjointuples = outer_matched_rows;
 		else
 			hashjointuples = outer_path_rows - outer_matched_rows;
+
 	} else {
 		/*
 		 * The number of tuple comparisons needed is the number of outer
@@ -2669,26 +2505,29 @@ void final_cost_hashjoin(PlannerInfo *root, HashPath *path,
 		 * approx_tuple_count here because we need an estimate done with
 		 * JOIN_INNER semantics.
 		 */
+
 		hashjointuples = approx_tuple_count(root, &path->jpath, hashclauses);
 	}
 
 	/*
 	 * For each tuple that gets through the hashjoin proper, we charge
 	 * cpu_tuple_cost plus the cost of evaluating additional restriction
-	 * clauses that are to be applied at the join.	(This is pessimistic since
+	 * clauses that are to be applied at the join.  (This is pessimistic since
 	 * not all of the quals may get evaluated at each tuple.)
 	 */
 	startup_cost += qp_qual_cost.startup;
 	cpu_per_tuple = cpu_tuple_cost + qp_qual_cost.per_tuple;
 	run_cost += cpu_per_tuple * hashjointuples;
+
 	if (mode_cost_check) {
-		path->jpath.path.mstartup_cost = startup_cost;
 		path->jpath.path.mtotal_cost = startup_cost + run_cost;
-
-	} else {
-		path->jpath.path.startup_cost = startup_cost;
+		path->jpath.path.mstartup_cost = startup_cost;
+	} else
 		path->jpath.path.total_cost = startup_cost + run_cost;
-	}
+	if (!mode_cost_check)
+		printf("final hash join %s cost is %.2f\n",
+				path->jpath.path.parent->rel_name, path->jpath.path.total_cost);
+
 }
 
 /*
@@ -2726,7 +2565,7 @@ void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan) {
 	} else {
 		/*
 		 * Otherwise we will be rescanning the subplan output on each
-		 * evaluation.	We need to estimate how much of the output we will
+		 * evaluation.  We need to estimate how much of the output we will
 		 * actually need to scan.  NOTE: this logic should agree with the
 		 * tuple_fraction estimates used by make_subplan() in
 		 * plan/subselect.c.
@@ -2767,10 +2606,10 @@ void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan) {
 /*
  * cost_rescan
  *		Given a finished Path, estimate the costs of rescanning it after
- *		having done so the first time.	For some Path types a rescan is
+ *		having done so the first time.  For some Path types a rescan is
  *		cheaper than an original scan (if no parameters change), and this
  *		function embodies knowledge about that.  The default is to return
- *		the same costs stored in the Path.	(Note that the cost estimates
+ *		the same costs stored in the Path.  (Note that the cost estimates
  *		actually stored in Paths are always for first scans.)
  *
  * This function is not currently intended to model effects such as rescans
@@ -2781,6 +2620,8 @@ void cost_subplan(PlannerInfo *root, SubPlan *subplan, Plan *plan) {
 static void cost_rescan(PlannerInfo *root, Path *path,
 		Cost *rescan_startup_cost, /* output parameters */
 		Cost *rescan_total_cost) {
+	int mrows = mode_cost_check ? path->mrows : path->rows;
+	double mcost = mode_cost_check ? path->mtotal_cost : path->total_cost;
 	switch (path->pathtype) {
 	case T_FunctionScan:
 
@@ -2792,11 +2633,7 @@ static void cost_rescan(PlannerInfo *root, Path *path,
 		 * will be paid over again.
 		 */
 		*rescan_startup_cost = 0;
-		if (mode_cost_check) {
-			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
-		} else {
-			*rescan_total_cost = path->total_cost - path->startup_cost;
-		}
+		*rescan_total_cost = mcost - path->startup_cost;
 		break;
 	case T_HashJoin:
 
@@ -2805,22 +2642,19 @@ static void cost_rescan(PlannerInfo *root, Path *path,
 		 * building, which we won't have to do over.
 		 */
 		*rescan_startup_cost = 0;
-		if (mode_cost_check) {
-			*rescan_total_cost = path->mtotal_cost - path->mstartup_cost;
-		} else {
-			*rescan_total_cost = path->total_cost - path->startup_cost;
-		}
+		*rescan_total_cost = mcost - path->startup_cost;
 		break;
 	case T_CteScan:
 	case T_WorkTableScan: {
 		/*
 		 * These plan types materialize their final result in a
-		 * tuplestore or tuplesort object.	So the rescan cost is only
+		 * tuplestore or tuplesort object.  So the rescan cost is only
 		 * cpu_tuple_cost per tuple, unless the result is large enough
 		 * to spill to disk.
 		 */
-		Cost run_cost = cpu_tuple_cost * path->rows;
-		double nbytes = relation_byte_size(path->rows, path->parent->width);
+
+		Cost run_cost = cpu_tuple_cost * mrows;
+		double nbytes = relation_byte_size(mrows, path->parent->width);
 		long work_mem_bytes = work_mem * 1024L;
 
 		if (nbytes > work_mem_bytes) {
@@ -2837,14 +2671,14 @@ static void cost_rescan(PlannerInfo *root, Path *path,
 	case T_Sort: {
 		/*
 		 * These plan types not only materialize their results, but do
-		 * not implement qual filtering or projection.	So they are
-		 * even cheaper to rescan than the ones above.	We charge only
+		 * not implement qual filtering or projection.  So they are
+		 * even cheaper to rescan than the ones above.  We charge only
 		 * cpu_operator_cost per tuple.  (Note: keep that in sync with
 		 * the run_cost charge in cost_sort, and also see comments in
 		 * cost_material before you change it.)
 		 */
-		Cost run_cost = cpu_operator_cost * path->rows;
-		double nbytes = relation_byte_size(path->rows, path->parent->width);
+		Cost run_cost = cpu_operator_cost * mrows;
+		double nbytes = relation_byte_size(mrows, path->parent->width);
 		long work_mem_bytes = work_mem * 1024L;
 
 		if (nbytes > work_mem_bytes) {
@@ -2858,14 +2692,8 @@ static void cost_rescan(PlannerInfo *root, Path *path,
 	}
 		break;
 	default:
-		if (mode_cost_check) {
-			*rescan_startup_cost = path->mstartup_cost;
-			*rescan_total_cost = path->mtotal_cost;
-		} else {
-			*rescan_startup_cost = path->startup_cost;
-			*rescan_total_cost = path->total_cost;
-		}
-
+		*rescan_startup_cost = path->startup_cost;
+		*rescan_total_cost = mcost;
 		break;
 	}
 }
@@ -2972,7 +2800,7 @@ static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context) {
 	 * evaluation of AND/OR?  Probably *not*, because that would make the
 	 * results depend on the clause ordering, and we are not in any position
 	 * to expect that the current ordering of the clauses is the one that's
-	 * going to end up being used.	The above per-RestrictInfo caching would
+	 * going to end up being used.  The above per-RestrictInfo caching would
 	 * not mix well with trying to re-order clauses anyway.
 	 *
 	 * Another issue that is entirely ignored here is that if a set-returning
@@ -3069,7 +2897,7 @@ static bool cost_qual_eval_walker(Node *node, cost_qual_eval_context *context) {
 		return false;
 	} else if (IsA(node, AlternativeSubPlan)) {
 		/*
-		 * Arbitrarily use the first alternative plan for costing.	(We should
+		 * Arbitrarily use the first alternative plan for costing.  (We should
 		 * certainly only include one alternative, and we don't yet have
 		 * enough information to know which one the executor is most likely to
 		 * use.)
@@ -3190,13 +3018,13 @@ void compute_semi_anti_join_factors(PlannerInfo *root, RelOptInfo *outerrel,
 	/*
 	 * jselec can be interpreted as the fraction of outer-rel rows that have
 	 * any matches (this is true for both SEMI and ANTI cases).  And nselec is
-	 * the fraction of the Cartesian product that matches.	So, the average
+	 * the fraction of the Cartesian product that matches.  So, the average
 	 * number of matches for each outer-rel row that has at least one match is
 	 * nselec * inner_rows / jselec.
 	 *
 	 * Note: it is correct to use the inner rel's "rows" count here, even
 	 * though we might later be considering a parameterized inner path with
-	 * fewer rows.	This is because we have included all the join clauses in
+	 * fewer rows.  This is because we have included all the join clauses in
 	 * the selectivity estimate.
 	 */
 	if (jselec > 0) /* protect against zero divide */
@@ -3356,19 +3184,38 @@ static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals)
  */
 void set_baserel_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 	double nrows;
-
+	int rest = 0;
+	int mrows = -1;
+	Node *node = NIL;
+	char *res = NULL;
 	/* Should only be applied to base relations */
 	Assert(rel->relid > 0);
 
 	//maybe memo hacked
-	if (!enable_memo || rel->rows == -1) {
-		nrows = rel->tuples
-				* clauselist_selectivity(root, rel->baserestrictinfo, 0,
-						JOIN_INNER, NULL);
+	if (enable_memo && rel->rel_name != NULL) {
+
+		rest = list_length(rel->baserestrictinfo);
+
+
+		node = (Node *) make_ands_explicit(rel->baserestrictinfo);
+		//pprint(node);
+		res = nodeSimToString(node);
+
+		printf("checking base relation %s with %d clauses\n", rel->rel_name,
+				rest);
+		fflush(stdout);
+		mrows = get_baserel_memo_size(rel->rel_name, root->query_level, rest,
+				res);
 
-		rel->rows = clamp_row_est(nrows);
 	}
 
+	nrows = rel->tuples
+			* clauselist_selectivity(root, rel->baserestrictinfo, 0, JOIN_INNER,
+					NULL);
+
+	nrows = nrows <= mrows ? mrows : nrows;
+	rel->rows = clamp_row_est(nrows);
+
 	cost_qual_eval(&rel->baserestrictcost, rel->baserestrictinfo, root);
 
 	set_rel_width(root, rel);
@@ -3386,6 +3233,11 @@ double get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
 		List *param_clauses) {
 	List *allclauses;
 	double nrows;
+	int rest = 0;
+	int mrows = -1;
+	Node *node = NIL;
+
+	StringInfoData expr;
 
 	/*
 	 * Estimate the number of rows returned by the parameterized scan, knowing
@@ -3394,9 +3246,26 @@ double get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * non-join clauses during selectivity estimation.
 	 */
 	allclauses = list_concat(list_copy(param_clauses), rel->baserestrictinfo);
+	if (enable_memo && rel->rel_name != NULL) {
+
+		rest = list_length(rel->baserestrictinfo);
+
+		printf("checking parameterized relation %s with %d clauses\n",
+				rel->rel_name, rest);
+		fflush(stdout);
+
+		node = (Node *) make_ands_explicit(rel->baserestrictinfo);
+		char *res =nodeSimToString(node);
+
+		mrows = get_baserel_memo_size(rel->rel_name, root->query_level, rest,
+				res);
+	}
+
 	nrows = rel->tuples * clauselist_selectivity(root, allclauses, rel->relid, /* do not use 0! */
 	JOIN_INNER, NULL);
+	nrows = nrows <= mrows ? mrows : nrows;
 	nrows = clamp_row_est(nrows);
+
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
 		nrows = rel->rows;
@@ -3428,9 +3297,24 @@ double get_parameterized_baserel_size(PlannerInfo *root, RelOptInfo *rel,
 void set_joinrel_size_estimates(PlannerInfo *root, RelOptInfo *rel,
 		RelOptInfo *outer_rel, RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo,
 		List *restrictlist) {
-	if (!enable_memo || rel->rows == -1)
-		rel->rows = calc_joinrel_size_estimate(root, outer_rel->rows,
+	double nrows;
+	int rest = 0;
+	fflush(stdout);
+
+	if (enable_memo) {
+
+		rest = list_length(restrictlist);
+
+		nrows = get_join_memo_size(rel->rel_name, root->query_level,
+				restrictlist);
+	}
+	if (!enable_memo || nrows == -1) {
+
+		nrows = calc_joinrel_size_estimate(root, outer_rel->rows,
 				inner_rel->rows, sjinfo, restrictlist);
+	}
+	rel->rows = clamp_row_est(nrows);
+
 }
 
 /*
@@ -3462,8 +3346,18 @@ double get_parameterized_joinrel_size(PlannerInfo *root, RelOptInfo *rel,
 	 * on the pair of input paths provided, though ideally we'd get the same
 	 * estimate for any pair with the same parameterization.
 	 */
-	nrows = calc_joinrel_size_estimate(root, outer_rows, inner_rows, sjinfo,
-			restrict_clauses);
+	if (enable_memo && rel->rel_name != NULL) {
+
+		//rest = list_length(restrict_clauses);
+
+		nrows = get_join_memo_size(rel->rel_name, root->query_level,
+				restrict_clauses);
+	}
+	if (!enable_memo || nrows == -1) {
+		nrows = calc_joinrel_size_estimate(root, outer_rows, inner_rows, sjinfo,
+				restrict_clauses);
+	}
+
 	/* For safety, make sure result is not more than the base estimate */
 	if (nrows > rel->rows)
 		nrows = rel->rows;
@@ -3483,7 +3377,7 @@ static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
 	double nrows;
 
 	/*
-	 * Compute joinclause selectivity.	Note that we are only considering
+	 * Compute joinclause selectivity.  Note that we are only considering
 	 * clauses that become restriction clauses at this join level; we are not
 	 * double-counting them because they were not considered in estimating the
 	 * sizes of the component rels.
@@ -3525,7 +3419,7 @@ static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
 	 *
 	 * If we are doing an outer join, take that into account: the joinqual
 	 * selectivity has to be clamped using the knowledge that the output must
-	 * be at least as large as the non-nullable input.	However, any
+	 * be at least as large as the non-nullable input.  However, any
 	 * pushed-down quals are applied after the outer join, so their
 	 * selectivity applies fully.
 	 *
@@ -3560,7 +3454,7 @@ static double calc_joinrel_size_estimate(PlannerInfo *root, double outer_rows,
 		break;
 	default:
 		/* other values not expected here */
-		elog(ERROR, "unrecognized join type: %d", (int ) jointype);
+		elog(ERROR, "unrecognized join type: %d", (int) jointype);
 		nrows = 0; /* keep compiler quiet */
 		break;
 	}
@@ -3593,7 +3487,7 @@ void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 
 	/*
 	 * Compute per-output-column width estimates by examining the subquery's
-	 * targetlist.	For any output that is a plain Var, get the width estimate
+	 * targetlist.  For any output that is a plain Var, get the width estimate
 	 * that was made while planning the subquery.  Otherwise, we leave it to
 	 * set_rel_width to fill in a datatype-based default estimate.
 	 */foreach(lc, subroot->parse->targetList) {
@@ -3610,7 +3504,7 @@ void set_subquery_size_estimates(PlannerInfo *root, RelOptInfo *rel) {
 		 * The subquery could be an expansion of a view that's had columns
 		 * added to it since the current query was parsed, so that there are
 		 * non-junk tlist columns in it that don't correspond to any column
-		 * visible at our query level.	Ignore such columns.
+		 * visible at our query level.  Ignore such columns.
 		 */
 		if (te->resno < rel->min_attr || te->resno > rel->max_attr)
 			continue;
@@ -3747,7 +3641,7 @@ void set_cte_size_estimates(PlannerInfo *root, RelOptInfo *rel, Plan *cteplan) {
  * of estimating baserestrictcost, so we set that, and we also set up width
  * using what will be purely datatype-driven estimates from the targetlist.
  * There is no way to do anything sane with the rows value, so we just put
- * a default estimate and hope that the wrapper can improve on it.	The
+ * a default estimate and hope that the wrapper can improve on it.  The
  * wrapper's GetForeignRelSize function will be called momentarily.
  *
  * The rel's targetlist and restrictinfo list must have been constructed
@@ -3852,7 +3746,7 @@ static void set_rel_width(PlannerInfo *root, RelOptInfo *rel) {
 		} else {
 			/*
 			 * We could be looking at an expression pulled up from a subquery,
-			 * or a ROW() representing a whole-row child Var, etc.	Do what we
+			 * or a ROW() representing a whole-row child Var, etc.  Do what we
 			 * can using the expression type information.
 			 */
 			int32 item_width;
@@ -3912,7 +3806,6 @@ static double relation_byte_size(double tuples, int width) {
 static double page_size(double tuples, int width) {
 	return ceil(relation_byte_size(tuples, width) / BLCKSZ);
 }
-
 /*
  * GUC check_hook for effective_cache_size
  */
diff --git a/src/backend/optimizer/plan/createplan.c b/src/backend/optimizer/plan/createplan.c
index 48b4177..64081f7 100644
--- a/src/backend/optimizer/plan/createplan.c
+++ b/src/backend/optimizer/plan/createplan.c
@@ -18,6 +18,7 @@
 
 #include <limits.h>
 #include <math.h>
+#include "nodes/print.h"
 
 #include "access/skey.h"
 #include "catalog/pg_class.h"
@@ -145,9 +146,10 @@ static Plan *prepare_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree,
 static EquivalenceMember *find_ec_member_for_tle(EquivalenceClass *ec,
 		TargetEntry *tle, Relids relids);
 static Material *make_material(Plan *lefttree);
-static void print_injected_cost(const char *rel, int rows,double old_cost,  double cost_result);
-static int get_base_rows_from_memo(char *name, int level);
-static int get_join_rows_from_memo(char *name, int level);
+static void print_injected_cost(const char *rel, int rows, double old_cost,
+		double cost_result);
+static int get_base_rows_from_memo(char *name, int level, int clauses);
+static int get_join_rows_from_memo(char *name, int level, int clauses);
 FILE *file;
 
 /*
@@ -260,10 +262,9 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 	List *scan_clauses;
 	Plan *plan;
 	RelOptInfo *rel = best_path->parent;
-	int nrows;
+	int nrows = -1;
 	double mcost = -1;
 
-
 	/*
 	 * For table scans, rather than using the relation targetlist (which is
 	 * only those Vars actually needed by the query), we prefer to generate a
@@ -304,15 +305,18 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		scan_clauses = list_concat(list_copy(scan_clauses),
 				best_path->param_info->ppi_clauses);
 	if (enable_cost_check) {
-		nrows = get_base_rows_from_memo(rel->rel_name, root->query_level);
+		best_path->mrows = get_base_rows_from_memo(rel->rel_name,
+				root->query_level, list_length(scan_clauses));
 	}
+	best_path->memo_checked = best_path->mrows >= 0;
 
 	switch (best_path->pathtype) {
 	case T_SeqScan:
 		plan = (Plan *) create_seqscan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_seqscan(best_path, root, rel, best_path->param_info);
+			//cost_seqscan(best_path, root, rel, best_path->param_info);
+			best_path->mtotal_cost = best_path->total_cost;
 			mcost = best_path->mtotal_cost;
 
 		}
@@ -322,9 +326,12 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
 				tlist, scan_clauses, false);
 		if (enable_cost_check) {
-			cost_index((IndexPath *) best_path, root,
-					((IndexPath *) best_path)->indexinfo->loop_count);
+			nrows = rel->rows;
+			rel->rows = best_path->mrows;
+			cost_index((IndexPath *) best_path, root, best_path->mrows);
+			rel->rows = nrows;
 			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
+
 		}
 		break;
 
@@ -332,8 +339,7 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_indexscan_plan(root, (IndexPath *) best_path,
 				tlist, scan_clauses, true);
 		if (enable_cost_check) {
-			cost_index((IndexPath *) best_path, root,
-					((IndexPath *) best_path)->indexinfo->loop_count);
+			cost_index((IndexPath *) best_path, root, best_path->mrows);
 			mcost = ((IndexPath *) best_path)->path.mtotal_cost;
 		}
 		break;
@@ -345,8 +351,8 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 			cost_bitmap_heap_scan(best_path, root, rel,
 					((BitmapHeapPath *) best_path)->path.param_info,
 					((BitmapHeapPath *) best_path)->bitmapqual,
-					((BitmapHeapPath *) best_path)->loop);
-			mcost = best_path->mtotal_cost;
+					best_path->mrows);
+			mcost = best_path->total_cost;
 		}
 
 		break;
@@ -355,10 +361,12 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_tidscan_plan(root, (TidPath *) best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_tidscan(best_path, root, rel,
-					((TidPath *) best_path)->tidquals,
-					((TidPath *) best_path)->path.param_info);
-			mcost = best_path->mtotal_cost;
+			/*cost_tidscan(best_path, root, rel,
+			 ((TidPath *) best_path)->tidquals,
+			 ((TidPath *) best_path)->path.param_info);*/
+			best_path->mtotal_cost = best_path->total_cost;
+
+			mcost = best_path->total_cost;
 		}
 		break;
 
@@ -366,8 +374,8 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_subqueryscan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_subqueryscan(best_path, root, rel, best_path->param_info);
-			mcost = best_path->mtotal_cost;
+			//	cost_subqueryscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->total_cost;
 		}
 		break;
 
@@ -375,8 +383,8 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_functionscan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_functionscan(best_path, root, rel, best_path->param_info);
-			mcost = best_path->mtotal_cost;
+			//cost_functionscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->total_cost;
 		}
 		break;
 
@@ -384,8 +392,8 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_valuesscan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_valuesscan(best_path, root, rel, best_path->param_info);
-			mcost = best_path->mtotal_cost;
+			//	cost_valuesscan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->total_cost;
 
 		}
 		break;
@@ -394,8 +402,8 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_ctescan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_ctescan(best_path, root, rel, best_path->param_info);
-			mcost = best_path->mtotal_cost;
+			//	cost_ctescan(best_path, root, rel, best_path->param_info);
+			mcost = best_path->total_cost;
 		}
 		break;
 
@@ -403,7 +411,7 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 		plan = (Plan *) create_worktablescan_plan(root, best_path, tlist,
 				scan_clauses);
 		if (enable_cost_check) {
-			cost_ctescan(best_path, root, rel, best_path->param_info);
+			//cost_ctescan(best_path, root, rel, best_path->param_info);
 			mcost = best_path->mtotal_cost;
 		}
 		break;
@@ -429,7 +437,11 @@ create_scan_plan(PlannerInfo *root, Path *best_path) {
 	if (root->hasPseudoConstantQuals)
 		plan = create_gating_plan(root, plan, scan_clauses);
 	if (enable_cost_check) {
-		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+		print_injected_cost(rel->rel_name, best_path->mrows, plan->total_cost,
+				mcost);
+		plan->mrows = best_path->mrows;
+		plan->mtotal_cost = mcost;
+
 	}
 	return plan;
 }
@@ -591,10 +603,12 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 	Plan *plan;
 	Relids saveOuterRels = root->curOuterRels;
 	RelOptInfo *rel = best_path->path.parent;
-	int nrows;
+	int nrows = -1;
+	bool checked = false;
 	double mcost = -1;
 
 	outer_plan = create_plan_recurse(root, best_path->outerjoinpath);
+	checked = (best_path->outerjoinpath)->memo_checked;
 
 	/* For a nestloop, include outer relids in curOuterRels for inner side */
 	if (best_path->path.pathtype == T_NestLoop)
@@ -602,14 +616,28 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 				best_path->outerjoinpath->parent->relids);
 
 	inner_plan = create_plan_recurse(root, best_path->innerjoinpath);
-	if (enable_cost_check) {
-		nrows = get_join_rows_from_memo(rel->rel_name, root->query_level);
+	checked = best_path->innerjoinpath->memo_checked && checked;
+
+	if (enable_cost_check && checked) {
+		best_path->path.mrows = get_join_rows_from_memo(rel->rel_name,
+				root->query_level, list_length(rel->joininfo));
+
 	}
+	best_path->path.memo_checked = checked;
 	switch (best_path->path.pathtype) {
 	case T_MergeJoin:
-		plan = (Plan *) create_mergejoin_plan(root, (MergePath *) best_path,
-				outer_plan, inner_plan);
-		if (enable_cost_check) {
+
+		if (enable_cost_check && best_path->path.memo_checked) {
+
+			((MergePath *) best_path)->jpath.outerjoinpath->mrows =
+					outer_plan->mrows;
+			((MergePath *) best_path)->jpath.innerjoinpath->mrows =
+					inner_plan->mrows;
+			((MergePath *) best_path)->jpath.outerjoinpath->mtotal_cost =
+					outer_plan->mtotal_cost;
+			((MergePath *) best_path)->jpath.innerjoinpath->mtotal_cost =
+					inner_plan->mtotal_cost;
+
 			initial_cost_mergejoin(root, rel->workspace,
 					((MergePath *) best_path)->jpath.jointype,
 					((MergePath *) best_path)->path_mergeclauses,
@@ -622,11 +650,21 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 			mcost = ((MergePath *) best_path)->jpath.path.mtotal_cost;
 
 		}
+		plan = (Plan *) create_mergejoin_plan(root, (MergePath *) best_path,
+				outer_plan, inner_plan);
 		break;
 	case T_HashJoin:
-		plan = (Plan *) create_hashjoin_plan(root, (HashPath *) best_path,
-				outer_plan, inner_plan);
-		if (enable_cost_check ) {
+
+		if (enable_cost_check && best_path->path.memo_checked) {
+			((HashPath *) best_path)->jpath.outerjoinpath->mrows =
+					outer_plan->mrows;
+			((MergePath *) best_path)->jpath.innerjoinpath->mrows =
+					inner_plan->mrows;
+			((HashPath *) best_path)->jpath.outerjoinpath->mtotal_cost =
+					outer_plan->mtotal_cost;
+			((HashPath *) best_path)->jpath.innerjoinpath->mtotal_cost =
+					inner_plan->mtotal_cost;
+
 			initial_cost_hashjoin(root, rel->workspace,
 					((HashPath *) best_path)->jpath.jointype,
 					((HashPath *) best_path)->path_hashclauses,
@@ -638,15 +676,15 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 
 			mcost = ((HashPath *) best_path)->jpath.path.mtotal_cost;
 		}
+		plan = (Plan *) create_hashjoin_plan(root, (HashPath *) best_path,
+				outer_plan, inner_plan);
 		break;
 	case T_NestLoop:
 		/* Restore curOuterRels */
 		bms_free(root->curOuterRels);
 		root->curOuterRels = saveOuterRels;
 
-		plan = (Plan *) create_nestloop_plan(root, (NestPath *) best_path,
-				outer_plan, inner_plan);
-		if (enable_cost_check ) {
+		if (enable_cost_check && best_path->path.memo_checked) {
 			initial_cost_nestloop(root, rel->workspace, best_path->jointype,
 					best_path->outerjoinpath, best_path->innerjoinpath, NULL,
 					rel->workspace->semifactors);
@@ -655,6 +693,14 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 
 			mcost = best_path->path.mtotal_cost;
 		}
+
+		plan = (Plan *) create_nestloop_plan(root, (NestPath *) best_path,
+				outer_plan, inner_plan);
+
+		best_path->outerjoinpath->mrows = outer_plan->mrows;
+		best_path->innerjoinpath->mrows = inner_plan->mrows;
+		best_path->outerjoinpath->mtotal_cost = outer_plan->mtotal_cost;
+		best_path->innerjoinpath->mtotal_cost = inner_plan->mtotal_cost;
 		break;
 	default:
 		elog(ERROR,
@@ -685,7 +731,8 @@ create_join_plan(PlannerInfo *root, JoinPath *best_path) {
 #endif
 
 	if (enable_cost_check) {
-		print_injected_cost(rel->rel_name, nrows,plan->total_cost, mcost);
+		print_injected_cost(rel->rel_name, best_path->path.mrows,
+				plan->total_cost, mcost);
 	}
 	return plan;
 }
@@ -736,7 +783,6 @@ create_append_plan(PlannerInfo *root, AppendPath *best_path) {
 
 	plan = make_append(subplans, tlist);
 
-
 	return (Plan *) plan;
 }
 
@@ -789,6 +835,7 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path) {
 
 		/* Build the child plan */
 		subplan = create_plan_recurse(root, subpath);
+		best_path->path.memo_checked = true;
 
 		/* Compute sort column info, and adjust subplan's tlist as needed */
 		subplan = prepare_sort_from_pathkeys(root, subplan, pathkeys,
@@ -824,7 +871,6 @@ create_merge_append_plan(PlannerInfo *root, MergeAppendPath *best_path) {
 
 	node->mergeplans = subplans;
 
-
 	return (Plan *) node;
 }
 
@@ -848,7 +894,6 @@ create_result_plan(PlannerInfo *root, ResultPath *best_path) {
 
 	quals = order_qual_clauses(root, best_path->quals);
 
-
 	return make_result(root, tlist, (Node *) quals, NULL);
 }
 
@@ -865,7 +910,7 @@ create_material_plan(PlannerInfo *root, MaterialPath *best_path) {
 	Plan *subplan;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
-
+	best_path->path.memo_checked = best_path->subpath->memo_checked;
 	/* We don't want any excess columns in the materialized tuples */
 	disuse_physical_tlist(root, subplan, best_path->subpath);
 
@@ -898,6 +943,7 @@ create_unique_plan(PlannerInfo *root, UniquePath *best_path) {
 	ListCell *l;
 
 	subplan = create_plan_recurse(root, best_path->subpath);
+	best_path->path.memo_checked = best_path->subpath->memo_checked;
 
 	/* Done if we don't need to do any actual unique-ifying */
 	if (best_path->umethod == UNIQUE_PATH_NOOP)
@@ -2917,15 +2963,20 @@ order_qual_clauses(PlannerInfo *root, List *clauses) {
 static void copy_path_costsize(Plan *dest, Path *src) {
 	if (src) {
 		dest->startup_cost = src->startup_cost;
-		dest->total_cost =
-				(src->mtotal_cost == 0) ? src->total_cost : src->mtotal_cost;
+		dest->total_cost = src->total_cost;
 		dest->plan_rows = src->rows;
 		dest->plan_width = src->parent->width;
+		dest->mrows = src->mrows;
+		dest->mtotal_cost = src->mtotal_cost;
+		dest->mstartup_cost = src->mstartup_cost;
 	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
 		dest->plan_width = 0;
+		dest->mrows = src->mrows;
+		dest->mtotal_cost = src->mtotal_cost;
+		dest->mstartup_cost = src->mstartup_cost;
 	}
 }
 
@@ -2939,11 +2990,17 @@ static void copy_plan_costsize(Plan *dest, Plan *src) {
 		dest->total_cost = src->total_cost;
 		dest->plan_rows = src->plan_rows;
 		dest->plan_width = src->plan_width;
+		dest->mrows = src->mrows;
+		dest->mtotal_cost = src->mtotal_cost;
+		dest->mstartup_cost = src->mstartup_cost;
 	} else {
 		dest->startup_cost = 0;
 		dest->total_cost = 0;
 		dest->plan_rows = 0;
 		dest->plan_width = 0;
+		dest->mtotal_cost = 0;
+		dest->mstartup_cost = 0;
+		dest->mrows = 0;
 	}
 }
 
@@ -3080,7 +3137,7 @@ make_subqueryscan(List *qptlist, List *qpqual, Index scanrelid, Plan *subplan) {
 	 */
 	copy_plan_costsize(plan, subplan);
 	plan->total_cost += cpu_tuple_cost * subplan->plan_rows;
-
+	plan->mtotal_cost += cpu_tuple_cost * subplan->mrows;
 	plan->targetlist = qptlist;
 	plan->qual = qpqual;
 	plan->lefttree = NULL;
@@ -3351,6 +3408,7 @@ make_hash(Plan *lefttree, Oid skewTable, AttrNumber skewColumn,
 	 * plan; this only affects EXPLAIN display not decisions.
 	 */
 	plan->startup_cost = plan->total_cost;
+	plan->mstartup_cost = plan->mtotal_cost;
 	plan->targetlist = lefttree->targetlist;
 	plan->qual = NIL;
 	plan->lefttree = lefttree;
@@ -3418,6 +3476,9 @@ make_sort(PlannerInfo *root, Plan *lefttree, int numCols,
 	node->sortOperators = sortOperators;
 	node->collations = collations;
 	node->nullsFirst = nullsFirst;
+	plan->mrows = plan->plan_rows;
+	plan->mstartup_cost = plan->startup_cost;
+	plan->mtotal_cost = plan->total_cost;
 
 	return node;
 }
@@ -3868,6 +3929,8 @@ make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
 	Plan *plan = &node->plan;
 	Path agg_path; /* dummy for result of cost_agg */
 	QualCost qual_cost;
+	int nrows = -1;
+	double mcost = -1;
 
 	node->aggstrategy = aggstrategy;
 	node->numCols = numGroupCols;
@@ -3878,15 +3941,19 @@ make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
 	copy_plan_costsize(plan, lefttree); /* only care about copying size */
 	cost_agg(&agg_path, root, aggstrategy, aggcosts, numGroupCols, numGroups,
 			lefttree->startup_cost, lefttree->total_cost, lefttree->plan_rows);
+
 	plan->startup_cost = agg_path.startup_cost;
 	plan->total_cost = agg_path.total_cost;
 
+
+
 	/*
 	 * We will produce a single output tuple if not grouping, and a tuple per
 	 * group otherwise.
 	 */
 	if (aggstrategy == AGG_PLAIN)
 		plan->plan_rows = 1;
+
 	else
 		plan->plan_rows = numGroups;
 
@@ -3899,6 +3966,7 @@ make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
 	 * See notes in add_tlist_costs_to_plan about why only make_agg,
 	 * make_windowagg and make_group worry about tlist eval cost.
 	 */
+
 	if (qual) {
 		cost_qual_eval(&qual_cost, qual, root);
 		plan->startup_cost += qual_cost.startup;
@@ -3911,7 +3979,9 @@ make_agg(PlannerInfo *root, List *tlist, List *qual, AggStrategy aggstrategy,
 	plan->targetlist = tlist;
 	plan->lefttree = lefttree;
 	plan->righttree = NULL;
-
+	plan->mrows = plan->plan_rows;
+	plan->mstartup_cost = plan->startup_cost;
+	plan->mtotal_cost = plan->total_cost;
 	return node;
 }
 
@@ -4064,7 +4134,9 @@ make_unique(Plan *lefttree, List *distinctList) {
 	node->numCols = numCols;
 	node->uniqColIdx = uniqColIdx;
 	node->uniqOperators = uniqOperators;
-
+	plan->mrows = plan->plan_rows;
+	plan->mstartup_cost = plan->startup_cost;
+	plan->mtotal_cost = plan->total_cost;
 	return node;
 }
 
@@ -4261,6 +4333,9 @@ make_result(PlannerInfo *root, List *tlist, Node *resconstantqual,
 	plan->lefttree = subplan;
 	plan->righttree = NULL;
 	node->resconstantqual = resconstantqual;
+	plan->mrows = plan->plan_rows;
+	plan->mstartup_cost = plan->startup_cost;
+	plan->mtotal_cost = plan->total_cost;
 
 	return node;
 }
@@ -4398,26 +4473,27 @@ bool is_projection_capable_plan(Plan *plan) {
 	}
 	return true;
 }
-void print_injected_cost(const char *rel, int rows,double old_cost , double cost_result) {
+void print_injected_cost(const char *rel, int rows, double old_cost,
+		double cost_result) {
 
 	fprintf(file, "%s	%d	%.2f	%.2f\n", rel, rows, old_cost, cost_result);
 
 }
-int get_base_rows_from_memo(char *name, int level) {
+int get_base_rows_from_memo(char *name, int level, int clauses) {
 
 	if (enable_cost_check) {
 
-		return get_baserel_memo_size(name, level);
+		return get_baserel_memo_size(name, level, clauses, NIL);
 
 	}
 
 	return (-1);
 }
-int get_join_rows_from_memo(char *name, int level) {
+int get_join_rows_from_memo(char *name, int level, int clauses) {
 
 	if (enable_cost_check) {
 
-		return get_join_memo_size(name, level);
+		return get_join_memo_size(name, level, NIL);
 
 	}
 
diff --git a/src/backend/optimizer/util/pathnode.c b/src/backend/optimizer/util/pathnode.c
index e8be972..12fed3a 100644
--- a/src/backend/optimizer/util/pathnode.c
+++ b/src/backend/optimizer/util/pathnode.c
@@ -29,19 +29,19 @@
 #include "utils/selfuncs.h"
 #include "storage/fd.h"
 
-
-typedef enum
-{
-	COSTS_EQUAL,				/* path costs are fuzzily equal */
-	COSTS_BETTER1,				/* first path is cheaper than second */
-	COSTS_BETTER2,				/* second path is cheaper than first */
-	COSTS_DIFFERENT				/* neither path dominates the other on cost */
+typedef enum {
+	COSTS_EQUAL, /* path costs are fuzzily equal */
+	COSTS_BETTER1, /* first path is cheaper than second */
+	COSTS_BETTER2, /* second path is cheaper than first */
+	COSTS_DIFFERENT /* neither path dominates the other on cost */
 } PathCostComparison;
 
 static List *translate_sub_tlist(List *tlist, int relid);
 static bool query_is_distinct_for(Query *query, List *colnos, List *opids);
-static Oid	distinct_col_search(int colno, List *colnos, List *opids);
-
+static Oid distinct_col_search(int colno, List *colnos, List *opids);
+static void parse_node(char *node, char *buffer);
+static void parse_operator(char *node, char *buffer);
+static bool comp_set_clauses(char *str1, char *str2);
 
 /*****************************************************************************
  *		MISC. PATH UTILITIES
@@ -52,11 +52,8 @@ static Oid	distinct_col_search(int colno, List *colnos, List *opids);
  *	  Return -1, 0, or +1 according as path1 is cheaper, the same cost,
  *	  or more expensive than path2 for the specified criterion.
  */
-int
-compare_path_costs(Path *path1, Path *path2, CostSelector criterion)
-{
-	if (criterion == STARTUP_COST)
-	{
+int compare_path_costs(Path *path1, Path *path2, CostSelector criterion) {
+	if (criterion == STARTUP_COST) {
 		if (path1->startup_cost < path2->startup_cost)
 			return -1;
 		if (path1->startup_cost > path2->startup_cost)
@@ -70,9 +67,7 @@ compare_path_costs(Path *path1, Path *path2, CostSelector criterion)
 			return -1;
 		if (path1->total_cost > path2->total_cost)
 			return +1;
-	}
-	else
-	{
+	} else {
 		if (path1->total_cost < path2->total_cost)
 			return -1;
 		if (path1->total_cost > path2->total_cost)
@@ -98,19 +93,15 @@ compare_path_costs(Path *path1, Path *path2, CostSelector criterion)
  * If fraction is <= 0 or > 1, we interpret it as 1, ie, we select the
  * path with the cheaper total_cost.
  */
-int
-compare_fractional_path_costs(Path *path1, Path *path2,
-							  double fraction)
-{
-	Cost		cost1,
-				cost2;
+int compare_fractional_path_costs(Path *path1, Path *path2, double fraction) {
+	Cost cost1, cost2;
 
 	if (fraction <= 0.0 || fraction >= 1.0)
 		return compare_path_costs(path1, path2, TOTAL_COST);
-	cost1 = path1->startup_cost +
-		fraction * (path1->total_cost - path1->startup_cost);
-	cost2 = path2->startup_cost +
-		fraction * (path2->total_cost - path2->startup_cost);
+	cost1 = path1->startup_cost
+			+ fraction * (path1->total_cost - path1->startup_cost);
+	cost2 = path2->startup_cost
+			+ fraction * (path2->total_cost - path2->startup_cost);
 	if (cost1 < cost2)
 		return -1;
 	if (cost1 > cost2)
@@ -149,88 +140,82 @@ compare_fractional_path_costs(Path *path1, Path *path2,
  * since we deem only total cost to be of interest for a parameterized path.
  * (Unparameterized paths are more common, so we check for this case last.)
  */
-static PathCostComparison
-compare_path_costs_fuzzily(Path *path1, Path *path2, double fuzz_factor,
-						   bool consider_startup)
-{
+static PathCostComparison compare_path_costs_fuzzily(Path *path1, Path *path2,
+		double fuzz_factor, bool consider_startup) {
 	/*
 	 * Check total cost first since it's more likely to be different; many
 	 * paths have zero startup cost.
 	 */
-	if (path1->total_cost > path2->total_cost * fuzz_factor)
-	{
+	if (path1->total_cost > path2->total_cost * fuzz_factor) {
 		/* path1 fuzzily worse on total cost */
-		if (consider_startup &&
-			path2->startup_cost > path1->startup_cost * fuzz_factor &&
-			path1->param_info == NULL)
+		if (consider_startup
+				&& path2->startup_cost > path1->startup_cost * fuzz_factor&&
+				path1->param_info == NULL) {
+				/* ... but path2 fuzzily worse on startup, so DIFFERENT */
+return				COSTS_DIFFERENT;
+			}
+			/* else path2 dominates */
+			return COSTS_BETTER2;
+		}
+		if (path2->total_cost > path1->total_cost * fuzz_factor)
 		{
-			/* ... but path2 fuzzily worse on startup, so DIFFERENT */
-			return COSTS_DIFFERENT;
+			/* path2 fuzzily worse on total cost */
+			if (consider_startup &&
+					path1->startup_cost > path2->startup_cost * fuzz_factor &&
+					path2->param_info == NULL)
+			{
+				/* ... but path1 fuzzily worse on startup, so DIFFERENT */
+				return COSTS_DIFFERENT;
+			}
+			/* else path1 dominates */
+			return COSTS_BETTER1;
 		}
-		/* else path2 dominates */
-		return COSTS_BETTER2;
-	}
-	if (path2->total_cost > path1->total_cost * fuzz_factor)
-	{
-		/* path2 fuzzily worse on total cost */
-		if (consider_startup &&
-			path1->startup_cost > path2->startup_cost * fuzz_factor &&
-			path2->param_info == NULL)
+		/* fuzzily the same on total cost */
+		/* (so we may as well compare startup cost, even if !consider_startup) */
+		if (path1->startup_cost > path2->startup_cost * fuzz_factor &&
+				path2->param_info == NULL)
 		{
-			/* ... but path1 fuzzily worse on startup, so DIFFERENT */
-			return COSTS_DIFFERENT;
+			/* ... but path1 fuzzily worse on startup, so path2 wins */
+			return COSTS_BETTER2;
 		}
-		/* else path1 dominates */
-		return COSTS_BETTER1;
-	}
-	/* fuzzily the same on total cost */
-	/* (so we may as well compare startup cost, even if !consider_startup) */
-	if (path1->startup_cost > path2->startup_cost * fuzz_factor &&
-		path2->param_info == NULL)
-	{
-		/* ... but path1 fuzzily worse on startup, so path2 wins */
-		return COSTS_BETTER2;
-	}
-	if (path2->startup_cost > path1->startup_cost * fuzz_factor &&
-		path1->param_info == NULL)
-	{
-		/* ... but path2 fuzzily worse on startup, so path1 wins */
-		return COSTS_BETTER1;
+		if (path2->startup_cost > path1->startup_cost * fuzz_factor &&
+				path1->param_info == NULL)
+		{
+			/* ... but path2 fuzzily worse on startup, so path1 wins */
+			return COSTS_BETTER1;
+		}
+		/* fuzzily the same on both costs */
+		return COSTS_EQUAL;
 	}
-	/* fuzzily the same on both costs */
-	return COSTS_EQUAL;
-}
 
-/*
- * set_cheapest
- *	  Find the minimum-cost paths from among a relation's paths,
- *	  and save them in the rel's cheapest-path fields.
- *
- * cheapest_total_path is normally the cheapest-total-cost unparameterized
- * path; but if there are no unparameterized paths, we assign it to be the
- * best (cheapest least-parameterized) parameterized path.	However, only
- * unparameterized paths are considered candidates for cheapest_startup_path,
- * so that will be NULL if there are no unparameterized paths.
- *
- * The cheapest_parameterized_paths list collects all parameterized paths
- * that have survived the add_path() tournament for this relation.	(Since
- * add_path ignores pathkeys and startup cost for a parameterized path,
- * these will be paths that have best total cost or best row count for their
- * parameterization.)  cheapest_parameterized_paths always includes the
- * cheapest-total unparameterized path, too, if there is one; the users of
- * that list find it more convenient if that's included.
- *
- * This is normally called only after we've finished constructing the path
- * list for the rel node.
- */
-void
-set_cheapest(RelOptInfo *parent_rel)
-{
-	Path	   *cheapest_startup_path;
-	Path	   *cheapest_total_path;
-	Path	   *best_param_path;
-	List	   *parameterized_paths;
-	ListCell   *p;
+		/*
+		 * set_cheapest
+		 *	  Find the minimum-cost paths from among a relation's paths,
+		 *	  and save them in the rel's cheapest-path fields.
+		 *
+		 * cheapest_total_path is normally the cheapest-total-cost unparameterized
+		 * path; but if there are no unparameterized paths, we assign it to be the
+		 * best (cheapest least-parameterized) parameterized path.	However, only
+		 * unparameterized paths are considered candidates for cheapest_startup_path,
+		 * so that will be NULL if there are no unparameterized paths.
+		 *
+		 * The cheapest_parameterized_paths list collects all parameterized paths
+		 * that have survived the add_path() tournament for this relation.	(Since
+		 * add_path ignores pathkeys and startup cost for a parameterized path,
+		 * these will be paths that have best total cost or best row count for their
+		 * parameterization.)  cheapest_parameterized_paths always includes the
+		 * cheapest-total unparameterized path, too, if there is one; the users of
+		 * that list find it more convenient if that's included.
+		 *
+		 * This is normally called only after we've finished constructing the path
+		 * list for the rel node.
+		 */
+void set_cheapest(RelOptInfo *parent_rel) {
+	Path *cheapest_startup_path;
+	Path *cheapest_total_path;
+	Path *best_param_path;
+	List *parameterized_paths;
+	ListCell *p;
 
 	Assert(IsA(parent_rel, RelOptInfo));
 
@@ -240,13 +225,11 @@ set_cheapest(RelOptInfo *parent_rel)
 	cheapest_startup_path = cheapest_total_path = best_param_path = NULL;
 	parameterized_paths = NIL;
 
-	foreach(p, parent_rel->pathlist)
-	{
-		Path	   *path = (Path *) lfirst(p);
-		int			cmp;
+	foreach(p, parent_rel->pathlist) {
+		Path *path = (Path *) lfirst(p);
+		int cmp;
 
-		if (path->param_info)
-		{
+		if (path->param_info) {
 			/* Parameterized path, so add it to parameterized_paths */
 			parameterized_paths = lappend(parameterized_paths, path);
 
@@ -264,40 +247,35 @@ set_cheapest(RelOptInfo *parent_rel)
 			 */
 			if (best_param_path == NULL)
 				best_param_path = path;
-			else
-			{
+			else {
 				switch (bms_subset_compare(PATH_REQ_OUTER(path),
-										   PATH_REQ_OUTER(best_param_path)))
-				{
-					case BMS_EQUAL:
-						/* keep the cheaper one */
-						if (compare_path_costs(path, best_param_path,
-											   TOTAL_COST) < 0)
-							best_param_path = path;
-						break;
-					case BMS_SUBSET1:
-						/* new path is less-parameterized */
+						PATH_REQ_OUTER(best_param_path))) {
+				case BMS_EQUAL:
+					/* keep the cheaper one */
+					if (compare_path_costs(path, best_param_path, TOTAL_COST)
+							< 0)
 						best_param_path = path;
-						break;
-					case BMS_SUBSET2:
-						/* old path is less-parameterized, keep it */
-						break;
-					case BMS_DIFFERENT:
-
-						/*
-						 * This means that neither path has the least possible
-						 * parameterization for the rel.  We'll sit on the old
-						 * path until something better comes along.
-						 */
-						break;
+					break;
+				case BMS_SUBSET1:
+					/* new path is less-parameterized */
+					best_param_path = path;
+					break;
+				case BMS_SUBSET2:
+					/* old path is less-parameterized, keep it */
+					break;
+				case BMS_DIFFERENT:
+
+					/*
+					 * This means that neither path has the least possible
+					 * parameterization for the rel.  We'll sit on the old
+					 * path until something better comes along.
+					 */
+					break;
 				}
 			}
-		}
-		else
-		{
+		} else {
 			/* Unparameterized path, so consider it for cheapest slots */
-			if (cheapest_total_path == NULL)
-			{
+			if (cheapest_total_path == NULL) {
 				cheapest_startup_path = cheapest_total_path = path;
 				continue;
 			}
@@ -310,17 +288,17 @@ set_cheapest(RelOptInfo *parent_rel)
 			 * should keep that one.
 			 */
 			cmp = compare_path_costs(cheapest_startup_path, path, STARTUP_COST);
-			if (cmp > 0 ||
-				(cmp == 0 &&
-				 compare_pathkeys(cheapest_startup_path->pathkeys,
-								  path->pathkeys) == PATHKEYS_BETTER2))
+			if (cmp > 0
+					|| (cmp == 0
+							&& compare_pathkeys(cheapest_startup_path->pathkeys,
+									path->pathkeys) == PATHKEYS_BETTER2))
 				cheapest_startup_path = path;
 
 			cmp = compare_path_costs(cheapest_total_path, path, TOTAL_COST);
-			if (cmp > 0 ||
-				(cmp == 0 &&
-				 compare_pathkeys(cheapest_total_path->pathkeys,
-								  path->pathkeys) == PATHKEYS_BETTER2))
+			if (cmp > 0
+					|| (cmp == 0
+							&& compare_pathkeys(cheapest_total_path->pathkeys,
+									path->pathkeys) == PATHKEYS_BETTER2))
 				cheapest_total_path = path;
 		}
 	}
@@ -339,7 +317,7 @@ set_cheapest(RelOptInfo *parent_rel)
 
 	parent_rel->cheapest_startup_path = cheapest_startup_path;
 	parent_rel->cheapest_total_path = cheapest_total_path;
-	parent_rel->cheapest_unique_path = NULL;	/* computed only if needed */
+	parent_rel->cheapest_unique_path = NULL; /* computed only if needed */
 	parent_rel->cheapest_parameterized_paths = parameterized_paths;
 }
 
@@ -393,21 +371,18 @@ set_cheapest(RelOptInfo *parent_rel)
  *
  * Returns nothing, but modifies parent_rel->pathlist.
  */
-void
-add_path(RelOptInfo *parent_rel, Path *new_path)
-{
-	bool		accept_new = true;		/* unless we find a superior old path */
-	ListCell   *insert_after = NULL;	/* where to insert new item */
-	List	   *new_path_pathkeys;
-	ListCell   *p1;
-	ListCell   *p1_prev;
-	ListCell   *p1_next;
+void add_path(RelOptInfo *parent_rel, Path *new_path) {
+	bool accept_new = true; /* unless we find a superior old path */
+	ListCell *insert_after = NULL; /* where to insert new item */
+	List *new_path_pathkeys;
+	ListCell *p1;
+	ListCell *p1_prev;
+	ListCell *p1_next;
 
 	/*
 	 * This is a convenient place to check for query cancel --- no part of the
 	 * planner goes very long without calling add_path().
-	 */
-	CHECK_FOR_INTERRUPTS();
+	 */CHECK_FOR_INTERRUPTS();
 
 	/* Pretend parameterized paths have no pathkeys, per comment above */
 	new_path_pathkeys = new_path->param_info ? NIL : new_path->pathkeys;
@@ -421,10 +396,9 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 	 * list cell.
 	 */
 	p1_prev = NULL;
-	for (p1 = list_head(parent_rel->pathlist); p1 != NULL; p1 = p1_next)
-	{
-		Path	   *old_path = (Path *) lfirst(p1);
-		bool		remove_old = false; /* unless new proves superior */
+	for (p1 = list_head(parent_rel->pathlist); p1 != NULL; p1 = p1_next) {
+		Path *old_path = (Path *) lfirst(p1);
+		bool remove_old = false; /* unless new proves superior */
 		PathCostComparison costcmp;
 		PathKeysComparison keyscmp;
 		BMS_Comparison outercmp;
@@ -436,7 +410,7 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 		 * percentage need to be user-configurable?)
 		 */
 		costcmp = compare_path_costs_fuzzily(new_path, old_path, 1.01,
-											 parent_rel->consider_startup);
+				parent_rel->consider_startup);
 
 		/*
 		 * If the two paths compare differently for startup and total cost,
@@ -449,105 +423,89 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 		 * though it's cheap to compare there's not much point in checking it
 		 * earlier.)
 		 */
-		if (costcmp != COSTS_DIFFERENT)
-		{
+		if (costcmp != COSTS_DIFFERENT) {
 			/* Similarly check to see if either dominates on pathkeys */
-			List	   *old_path_pathkeys;
+			List *old_path_pathkeys;
 
 			old_path_pathkeys = old_path->param_info ? NIL : old_path->pathkeys;
-			keyscmp = compare_pathkeys(new_path_pathkeys,
-									   old_path_pathkeys);
-			if (keyscmp != PATHKEYS_DIFFERENT)
-			{
-				switch (costcmp)
-				{
-					case COSTS_EQUAL:
+			keyscmp = compare_pathkeys(new_path_pathkeys, old_path_pathkeys);
+			if (keyscmp != PATHKEYS_DIFFERENT) {
+				switch (costcmp) {
+				case COSTS_EQUAL:
+					outercmp = bms_subset_compare(PATH_REQ_OUTER(new_path),
+							PATH_REQ_OUTER(old_path));
+					if (keyscmp == PATHKEYS_BETTER1) {
+						if ((outercmp == BMS_EQUAL || outercmp == BMS_SUBSET1)
+								&& new_path->rows <= old_path->rows)
+							remove_old = true; /* new dominates old */
+					} else if (keyscmp == PATHKEYS_BETTER2) {
+						if ((outercmp == BMS_EQUAL || outercmp == BMS_SUBSET2)
+								&& new_path->rows >= old_path->rows)
+							accept_new = false; /* old dominates new */
+					} else /* keyscmp == PATHKEYS_EQUAL */
+					{
+						if (outercmp == BMS_EQUAL) {
+							/*
+							 * Same pathkeys and outer rels, and fuzzily
+							 * the same cost, so keep just one; to decide
+							 * which, first check rows and then do a fuzzy
+							 * cost comparison with very small fuzz limit.
+							 * (We used to do an exact cost comparison,
+							 * but that results in annoying
+							 * platform-specific plan variations due to
+							 * roundoff in the cost estimates.)  If things
+							 * are still tied, arbitrarily keep only the
+							 * old path.  Notice that we will keep only
+							 * the old path even if the less-fuzzy
+							 * comparison decides the startup and total
+							 * costs compare differently.
+							 */
+							if (new_path->rows < old_path->rows)
+								remove_old = true; /* new dominates old */
+							else if (new_path->rows > old_path->rows)
+								accept_new = false; /* old dominates new */
+							else if (compare_path_costs_fuzzily(new_path,
+									old_path, 1.0000000001,
+									parent_rel->consider_startup)
+									== COSTS_BETTER1)
+								remove_old = true; /* new dominates old */
+							else
+								accept_new = false; /* old equals or
+								 * dominates new */
+						} else if (outercmp == BMS_SUBSET1
+								&& new_path->rows <= old_path->rows)
+							remove_old = true; /* new dominates old */
+						else if (outercmp == BMS_SUBSET2
+								&& new_path->rows >= old_path->rows)
+							accept_new = false; /* old dominates new */
+						/* else different parameterizations, keep both */
+					}
+					break;
+				case COSTS_BETTER1:
+					if (keyscmp != PATHKEYS_BETTER2) {
 						outercmp = bms_subset_compare(PATH_REQ_OUTER(new_path),
-												   PATH_REQ_OUTER(old_path));
-						if (keyscmp == PATHKEYS_BETTER1)
-						{
-							if ((outercmp == BMS_EQUAL ||
-								 outercmp == BMS_SUBSET1) &&
-								new_path->rows <= old_path->rows)
-								remove_old = true;		/* new dominates old */
-						}
-						else if (keyscmp == PATHKEYS_BETTER2)
-						{
-							if ((outercmp == BMS_EQUAL ||
-								 outercmp == BMS_SUBSET2) &&
-								new_path->rows >= old_path->rows)
-								accept_new = false;		/* old dominates new */
-						}
-						else	/* keyscmp == PATHKEYS_EQUAL */
-						{
-							if (outercmp == BMS_EQUAL)
-							{
-								/*
-								 * Same pathkeys and outer rels, and fuzzily
-								 * the same cost, so keep just one; to decide
-								 * which, first check rows and then do a fuzzy
-								 * cost comparison with very small fuzz limit.
-								 * (We used to do an exact cost comparison,
-								 * but that results in annoying
-								 * platform-specific plan variations due to
-								 * roundoff in the cost estimates.)  If things
-								 * are still tied, arbitrarily keep only the
-								 * old path.  Notice that we will keep only
-								 * the old path even if the less-fuzzy
-								 * comparison decides the startup and total
-								 * costs compare differently.
-								 */
-								if (new_path->rows < old_path->rows)
-									remove_old = true;	/* new dominates old */
-								else if (new_path->rows > old_path->rows)
-									accept_new = false; /* old dominates new */
-								else if (compare_path_costs_fuzzily(new_path,
-																	old_path,
-																1.0000000001,
-																	parent_rel->consider_startup) == COSTS_BETTER1)
-									remove_old = true;	/* new dominates old */
-								else
-									accept_new = false; /* old equals or
-														 * dominates new */
-							}
-							else if (outercmp == BMS_SUBSET1 &&
-									 new_path->rows <= old_path->rows)
-								remove_old = true;		/* new dominates old */
-							else if (outercmp == BMS_SUBSET2 &&
-									 new_path->rows >= old_path->rows)
-								accept_new = false;		/* old dominates new */
-							/* else different parameterizations, keep both */
-						}
-						break;
-					case COSTS_BETTER1:
-						if (keyscmp != PATHKEYS_BETTER2)
-						{
-							outercmp = bms_subset_compare(PATH_REQ_OUTER(new_path),
-												   PATH_REQ_OUTER(old_path));
-							if ((outercmp == BMS_EQUAL ||
-								 outercmp == BMS_SUBSET1) &&
-								new_path->rows <= old_path->rows)
-								remove_old = true;		/* new dominates old */
-						}
-						break;
-					case COSTS_BETTER2:
-						if (keyscmp != PATHKEYS_BETTER1)
-						{
-							outercmp = bms_subset_compare(PATH_REQ_OUTER(new_path),
-												   PATH_REQ_OUTER(old_path));
-							if ((outercmp == BMS_EQUAL ||
-								 outercmp == BMS_SUBSET2) &&
-								new_path->rows >= old_path->rows)
-								accept_new = false;		/* old dominates new */
-						}
-						break;
-					case COSTS_DIFFERENT:
-
-						/*
-						 * can't get here, but keep this case to keep compiler
-						 * quiet
-						 */
-						break;
+								PATH_REQ_OUTER(old_path));
+						if ((outercmp == BMS_EQUAL || outercmp == BMS_SUBSET1)
+								&& new_path->rows <= old_path->rows)
+							remove_old = true; /* new dominates old */
+					}
+					break;
+				case COSTS_BETTER2:
+					if (keyscmp != PATHKEYS_BETTER1) {
+						outercmp = bms_subset_compare(PATH_REQ_OUTER(new_path),
+								PATH_REQ_OUTER(old_path));
+						if ((outercmp == BMS_EQUAL || outercmp == BMS_SUBSET2)
+								&& new_path->rows >= old_path->rows)
+							accept_new = false; /* old dominates new */
+					}
+					break;
+				case COSTS_DIFFERENT:
+
+					/*
+					 * can't get here, but keep this case to keep compiler
+					 * quiet
+					 */
+					break;
 				}
 			}
 		}
@@ -555,10 +513,9 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 		/*
 		 * Remove current element from pathlist if dominated by new.
 		 */
-		if (remove_old)
-		{
-			parent_rel->pathlist = list_delete_cell(parent_rel->pathlist,
-													p1, p1_prev);
+		if (remove_old) {
+			parent_rel->pathlist = list_delete_cell(parent_rel->pathlist, p1,
+					p1_prev);
 
 			/*
 			 * Delete the data pointed-to by the deleted cell, if possible
@@ -566,9 +523,7 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 			if (!IsA(old_path, IndexPath))
 				pfree(old_path);
 			/* p1_prev does not advance */
-		}
-		else
-		{
+		} else {
 			/* new belongs after this old path if it has cost >= old's */
 			if (new_path->total_cost >= old_path->total_cost)
 				insert_after = p1;
@@ -585,16 +540,13 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
 			break;
 	}
 
-	if (accept_new)
-	{
+	if (accept_new) {
 		/* Accept the new path: insert it at proper place in pathlist */
 		if (insert_after)
 			lappend_cell(parent_rel->pathlist, insert_after, new_path);
 		else
 			parent_rel->pathlist = lcons(new_path, parent_rel->pathlist);
-	}
-	else
-	{
+	} else {
 		/* Reject and recycle the new path */
 		if (!IsA(new_path, IndexPath))
 			pfree(new_path);
@@ -618,20 +570,16 @@ add_path(RelOptInfo *parent_rel, Path *new_path)
  * At the time this is called, we haven't actually built a Path structure,
  * so the required information has to be passed piecemeal.
  */
-bool
-add_path_precheck(RelOptInfo *parent_rel,
-				  Cost startup_cost, Cost total_cost,
-				  List *pathkeys, Relids required_outer)
-{
-	List	   *new_path_pathkeys;
-	ListCell   *p1;
+bool add_path_precheck(RelOptInfo *parent_rel, Cost startup_cost,
+		Cost total_cost, List *pathkeys, Relids required_outer) {
+	List *new_path_pathkeys;
+	ListCell *p1;
 
 	/* Pretend parameterized paths have no pathkeys, per add_path policy */
 	new_path_pathkeys = required_outer ? NIL : pathkeys;
 
-	foreach(p1, parent_rel->pathlist)
-	{
-		Path	   *old_path = (Path *) lfirst(p1);
+	foreach(p1, parent_rel->pathlist) {
+		Path *old_path = (Path *) lfirst(p1);
 		PathKeysComparison keyscmp;
 
 		/*
@@ -644,31 +592,25 @@ add_path_precheck(RelOptInfo *parent_rel,
 		 * old path dominates the new path exactly on both costs, it will
 		 * surely do so fuzzily.
 		 */
-		if (total_cost >= old_path->total_cost)
-		{
+		if (total_cost >= old_path->total_cost) {
 			/* can win on startup cost only if unparameterized */
-			if (startup_cost >= old_path->startup_cost || required_outer)
-			{
+			if (startup_cost >= old_path->startup_cost || required_outer) {
 				/* new path does not win on cost, so check pathkeys... */
-				List	   *old_path_pathkeys;
+				List *old_path_pathkeys;
 
-				old_path_pathkeys = old_path->param_info ? NIL : old_path->pathkeys;
+				old_path_pathkeys =
+						old_path->param_info ? NIL : old_path->pathkeys;
 				keyscmp = compare_pathkeys(new_path_pathkeys,
-										   old_path_pathkeys);
-				if (keyscmp == PATHKEYS_EQUAL ||
-					keyscmp == PATHKEYS_BETTER2)
-				{
+						old_path_pathkeys);
+				if (keyscmp == PATHKEYS_EQUAL || keyscmp == PATHKEYS_BETTER2) {
 					/* new path does not win on pathkeys... */
-					if (bms_equal(required_outer, PATH_REQ_OUTER(old_path)))
-					{
+					if (bms_equal(required_outer, PATH_REQ_OUTER(old_path))) {
 						/* Found an old path that dominates the new one */
 						return false;
 					}
 				}
 			}
-		}
-		else
-		{
+		} else {
 			/*
 			 * Since the pathlist is sorted by total_cost, we can stop looking
 			 * once we reach a path with a total_cost larger than the new
@@ -681,7 +623,6 @@ add_path_precheck(RelOptInfo *parent_rel,
 	return true;
 }
 
-
 /*****************************************************************************
  *		PATH NODE CREATION ROUTINES
  *****************************************************************************/
@@ -692,15 +633,13 @@ add_path_precheck(RelOptInfo *parent_rel,
  *	  pathnode.
  */
 Path *
-create_seqscan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+create_seqscan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_SeqScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
-	pathnode->pathkeys = NIL;	/* seqscan has unordered result */
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
+	pathnode->pathkeys = NIL; /* seqscan has unordered result */
 
 	cost_seqscan(pathnode, root, rel, pathnode->param_info);
 
@@ -732,32 +671,23 @@ create_seqscan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer)
  * Returns the new path node.
  */
 IndexPath *
-create_index_path(PlannerInfo *root,
-				  IndexOptInfo *index,
-				  List *indexclauses,
-				  List *indexclausecols,
-				  List *indexorderbys,
-				  List *indexorderbycols,
-				  List *pathkeys,
-				  ScanDirection indexscandir,
-				  bool indexonly,
-				  Relids required_outer,
-				  double loop_count)
-{
-	IndexPath  *pathnode = makeNode(IndexPath);
+create_index_path(PlannerInfo *root, IndexOptInfo *index, List *indexclauses,
+		List *indexclausecols, List *indexorderbys, List *indexorderbycols,
+		List *pathkeys, ScanDirection indexscandir, bool indexonly,
+		Relids required_outer, double loop_count) {
+	IndexPath *pathnode = makeNode(IndexPath);
 	RelOptInfo *rel = index->rel;
-	List	   *indexquals,
-			   *indexqualcols;
+	List *indexquals, *indexqualcols;
 
 	pathnode->path.pathtype = indexonly ? T_IndexOnlyScan : T_IndexScan;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_baserel_parampathinfo(root, rel,
-														  required_outer);
+			required_outer);
 	pathnode->path.pathkeys = pathkeys;
 
 	/* Convert clauses to indexquals the executor can handle */
 	expand_indexqual_conditions(index, indexclauses, indexclausecols,
-								&indexquals, &indexqualcols);
+			&indexquals, &indexqualcols);
 
 	/* Fill in the pathnode */
 	pathnode->indexinfo = index;
@@ -786,25 +716,20 @@ create_index_path(PlannerInfo *root,
  * IndexPaths.
  */
 BitmapHeapPath *
-create_bitmap_heap_path(PlannerInfo *root,
-						RelOptInfo *rel,
-						Path *bitmapqual,
-						Relids required_outer,
-						double loop_count)
-{
+create_bitmap_heap_path(PlannerInfo *root, RelOptInfo *rel, Path *bitmapqual,
+		Relids required_outer, double loop_count) {
 	BitmapHeapPath *pathnode = makeNode(BitmapHeapPath);
 
 	pathnode->path.pathtype = T_BitmapHeapScan;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_baserel_parampathinfo(root, rel,
-														  required_outer);
-	pathnode->path.pathkeys = NIL;		/* always unordered */
+			required_outer);
+	pathnode->path.pathkeys = NIL; /* always unordered */
 
 	pathnode->bitmapqual = bitmapqual;
 
-	cost_bitmap_heap_scan(&pathnode->path, root, rel,
-						  pathnode->path.param_info,
-						  bitmapqual, loop_count);
+	cost_bitmap_heap_scan(&pathnode->path, root, rel, pathnode->path.param_info,
+			bitmapqual, loop_count);
 
 	return pathnode;
 }
@@ -814,16 +739,13 @@ create_bitmap_heap_path(PlannerInfo *root,
  *	  Creates a path node representing a BitmapAnd.
  */
 BitmapAndPath *
-create_bitmap_and_path(PlannerInfo *root,
-					   RelOptInfo *rel,
-					   List *bitmapquals)
-{
+create_bitmap_and_path(PlannerInfo *root, RelOptInfo *rel, List *bitmapquals) {
 	BitmapAndPath *pathnode = makeNode(BitmapAndPath);
 
 	pathnode->path.pathtype = T_BitmapAnd;
 	pathnode->path.parent = rel;
-	pathnode->path.param_info = NULL;	/* not used in bitmap trees */
-	pathnode->path.pathkeys = NIL;		/* always unordered */
+	pathnode->path.param_info = NULL; /* not used in bitmap trees */
+	pathnode->path.pathkeys = NIL; /* always unordered */
 
 	pathnode->bitmapquals = bitmapquals;
 
@@ -838,16 +760,13 @@ create_bitmap_and_path(PlannerInfo *root,
  *	  Creates a path node representing a BitmapOr.
  */
 BitmapOrPath *
-create_bitmap_or_path(PlannerInfo *root,
-					  RelOptInfo *rel,
-					  List *bitmapquals)
-{
+create_bitmap_or_path(PlannerInfo *root, RelOptInfo *rel, List *bitmapquals) {
 	BitmapOrPath *pathnode = makeNode(BitmapOrPath);
 
 	pathnode->path.pathtype = T_BitmapOr;
 	pathnode->path.parent = rel;
-	pathnode->path.param_info = NULL;	/* not used in bitmap trees */
-	pathnode->path.pathkeys = NIL;		/* always unordered */
+	pathnode->path.param_info = NULL; /* not used in bitmap trees */
+	pathnode->path.pathkeys = NIL; /* always unordered */
 
 	pathnode->bitmapquals = bitmapquals;
 
@@ -863,20 +782,19 @@ create_bitmap_or_path(PlannerInfo *root,
  */
 TidPath *
 create_tidscan_path(PlannerInfo *root, RelOptInfo *rel, List *tidquals,
-					Relids required_outer)
-{
-	TidPath    *pathnode = makeNode(TidPath);
+		Relids required_outer) {
+	TidPath *pathnode = makeNode(TidPath);
 
 	pathnode->path.pathtype = T_TidScan;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_baserel_parampathinfo(root, rel,
-														  required_outer);
-	pathnode->path.pathkeys = NIL;		/* always unordered */
+			required_outer);
+	pathnode->path.pathkeys = NIL; /* always unordered */
 
 	pathnode->tidquals = tidquals;
 
 	cost_tidscan(&pathnode->path, root, rel, tidquals,
-				 pathnode->path.param_info);
+			pathnode->path.param_info);
 
 	return pathnode;
 }
@@ -889,17 +807,16 @@ create_tidscan_path(PlannerInfo *root, RelOptInfo *rel, List *tidquals,
  * Note that we must handle subpaths = NIL, representing a dummy access path.
  */
 AppendPath *
-create_append_path(RelOptInfo *rel, List *subpaths, Relids required_outer)
-{
+create_append_path(RelOptInfo *rel, List *subpaths, Relids required_outer) {
 	AppendPath *pathnode = makeNode(AppendPath);
-	ListCell   *l;
+	ListCell *l;
 
 	pathnode->path.pathtype = T_Append;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_appendrel_parampathinfo(rel,
-															required_outer);
-	pathnode->path.pathkeys = NIL;		/* result is always considered
-										 * unsorted */
+			required_outer);
+	pathnode->path.pathkeys = NIL; /* result is always considered
+	 * unsorted */
 	pathnode->subpaths = subpaths;
 
 	/*
@@ -913,13 +830,12 @@ create_append_path(RelOptInfo *rel, List *subpaths, Relids required_outer)
 	pathnode->path.rows = 0;
 	pathnode->path.startup_cost = 0;
 	pathnode->path.total_cost = 0;
-	foreach(l, subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
+	foreach(l, subpaths) {
+		Path *subpath = (Path *) lfirst(l);
 
 		pathnode->path.rows += subpath->rows;
 
-		if (l == list_head(subpaths))	/* first node? */
+		if (l == list_head(subpaths)) /* first node? */
 			pathnode->path.startup_cost = subpath->startup_cost;
 		pathnode->path.total_cost += subpath->total_cost;
 
@@ -936,21 +852,17 @@ create_append_path(RelOptInfo *rel, List *subpaths, Relids required_outer)
  *	  pathnode.
  */
 MergeAppendPath *
-create_merge_append_path(PlannerInfo *root,
-						 RelOptInfo *rel,
-						 List *subpaths,
-						 List *pathkeys,
-						 Relids required_outer)
-{
+create_merge_append_path(PlannerInfo *root, RelOptInfo *rel, List *subpaths,
+		List *pathkeys, Relids required_outer) {
 	MergeAppendPath *pathnode = makeNode(MergeAppendPath);
-	Cost		input_startup_cost;
-	Cost		input_total_cost;
-	ListCell   *l;
+	Cost input_startup_cost;
+	Cost input_total_cost;
+	ListCell *l;
 
 	pathnode->path.pathtype = T_MergeAppend;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_appendrel_parampathinfo(rel,
-															required_outer);
+			required_outer);
 	pathnode->path.pathkeys = pathkeys;
 	pathnode->subpaths = subpaths;
 
@@ -969,32 +881,22 @@ create_merge_append_path(PlannerInfo *root,
 	pathnode->path.rows = 0;
 	input_startup_cost = 0;
 	input_total_cost = 0;
-	foreach(l, subpaths)
-	{
-		Path	   *subpath = (Path *) lfirst(l);
+	foreach(l, subpaths) {
+		Path *subpath = (Path *) lfirst(l);
 
 		pathnode->path.rows += subpath->rows;
 
-		if (pathkeys_contained_in(pathkeys, subpath->pathkeys))
-		{
+		if (pathkeys_contained_in(pathkeys, subpath->pathkeys)) {
 			/* Subpath is adequately ordered, we won't need to sort it */
 			input_startup_cost += subpath->startup_cost;
 			input_total_cost += subpath->total_cost;
-		}
-		else
-		{
+		} else {
 			/* We'll need to insert a Sort node, so include cost for that */
-			Path		sort_path;		/* dummy for result of cost_sort */
-
-			cost_sort(&sort_path,
-					  root,
-					  pathkeys,
-					  subpath->total_cost,
-					  subpath->parent->tuples,
-					  subpath->parent->width,
-					  0.0,
-					  work_mem,
-					  pathnode->limit_tuples);
+			Path sort_path; /* dummy for result of cost_sort */
+
+			cost_sort(&sort_path, root, pathkeys, subpath->total_cost,
+					subpath->parent->tuples, subpath->parent->width, 0.0,
+					work_mem, pathnode->limit_tuples);
 			input_startup_cost += sort_path.startup_cost;
 			input_total_cost += sort_path.total_cost;
 		}
@@ -1004,10 +906,8 @@ create_merge_append_path(PlannerInfo *root,
 	}
 
 	/* Now we can compute total costs of the MergeAppend */
-	cost_merge_append(&pathnode->path, root,
-					  pathkeys, list_length(subpaths),
-					  input_startup_cost, input_total_cost,
-					  rel->tuples);
+	cost_merge_append(&pathnode->path, root, pathkeys, list_length(subpaths),
+			input_startup_cost, input_total_cost, rel->tuples);
 
 	return pathnode;
 }
@@ -1018,13 +918,12 @@ create_merge_append_path(PlannerInfo *root,
  *	  This is only used for the case of a query with an empty jointree.
  */
 ResultPath *
-create_result_path(List *quals)
-{
+create_result_path(List *quals) {
 	ResultPath *pathnode = makeNode(ResultPath);
 
 	pathnode->path.pathtype = T_Result;
 	pathnode->path.parent = NULL;
-	pathnode->path.param_info = NULL;	/* there are no other rels... */
+	pathnode->path.param_info = NULL; /* there are no other rels... */
 	pathnode->path.pathkeys = NIL;
 	pathnode->quals = quals;
 
@@ -1049,8 +948,7 @@ create_result_path(List *quals)
  *	  pathnode.
  */
 MaterialPath *
-create_material_path(RelOptInfo *rel, Path *subpath)
-{
+create_material_path(RelOptInfo *rel, Path *subpath) {
 	MaterialPath *pathnode = makeNode(MaterialPath);
 
 	Assert(subpath->parent == rel);
@@ -1062,11 +960,8 @@ create_material_path(RelOptInfo *rel, Path *subpath)
 
 	pathnode->subpath = subpath;
 
-	cost_material(&pathnode->path,
-				  subpath->startup_cost,
-				  subpath->total_cost,
-				  subpath->rows,
-				  rel->width);
+	cost_material(&pathnode->path, subpath->startup_cost, subpath->total_cost,
+			subpath->rows, rel->width);
 
 	return pathnode;
 }
@@ -1084,18 +979,17 @@ create_material_path(RelOptInfo *rel, Path *subpath)
  */
 UniquePath *
 create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
-				   SpecialJoinInfo *sjinfo)
-{
+		SpecialJoinInfo *sjinfo) {
 	UniquePath *pathnode;
-	Path		sort_path;		/* dummy for result of cost_sort */
-	Path		agg_path;		/* dummy for result of cost_agg */
+	Path sort_path; /* dummy for result of cost_sort */
+	Path agg_path; /* dummy for result of cost_agg */
 	MemoryContext oldcontext;
-	List	   *in_operators;
-	List	   *uniq_exprs;
-	bool		all_btree;
-	bool		all_hash;
-	int			numCols;
-	ListCell   *lc;
+	List *in_operators;
+	List *uniq_exprs;
+	bool all_btree;
+	bool all_hash;
+	int numCols;
+	ListCell *lc;
 
 	/* Caller made a mistake if subpath isn't cheapest_total ... */
 	Assert(subpath == rel->cheapest_total_path);
@@ -1150,27 +1044,23 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 	in_operators = NIL;
 	uniq_exprs = NIL;
 	all_btree = true;
-	all_hash = enable_hashagg;	/* don't consider hash if not enabled */
-	foreach(lc, sjinfo->join_quals)
-	{
-		OpExpr	   *op = (OpExpr *) lfirst(lc);
-		Oid			opno;
-		Node	   *left_expr;
-		Node	   *right_expr;
-		Relids		left_varnos;
-		Relids		right_varnos;
-		Relids		all_varnos;
-		Oid			opinputtype;
+	all_hash = enable_hashagg; /* don't consider hash if not enabled */
+	foreach(lc, sjinfo->join_quals) {
+		OpExpr *op = (OpExpr *) lfirst(lc);
+		Oid opno;
+		Node *left_expr;
+		Node *right_expr;
+		Relids left_varnos;
+		Relids right_varnos;
+		Relids all_varnos;
+		Oid opinputtype;
 
 		/* Is it a binary opclause? */
-		if (!IsA(op, OpExpr) ||
-			list_length(op->args) != 2)
-		{
+		if (!IsA(op, OpExpr) || list_length(op->args) != 2) {
 			/* No, but does it reference both sides? */
 			all_varnos = pull_varnos((Node *) op);
-			if (!bms_overlap(all_varnos, sjinfo->syn_righthand) ||
-				bms_is_subset(all_varnos, sjinfo->syn_righthand))
-			{
+			if (!bms_overlap(all_varnos, sjinfo->syn_righthand)
+					|| bms_is_subset(all_varnos, sjinfo->syn_righthand)) {
 				/*
 				 * Clause refers to only one rel, so ignore it --- unless it
 				 * contains volatile functions, in which case we'd better
@@ -1194,9 +1084,8 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 		opinputtype = exprType(left_expr);
 
 		/* Does it reference both sides? */
-		if (!bms_overlap(all_varnos, sjinfo->syn_righthand) ||
-			bms_is_subset(all_varnos, sjinfo->syn_righthand))
-		{
+		if (!bms_overlap(all_varnos, sjinfo->syn_righthand)
+				|| bms_is_subset(all_varnos, sjinfo->syn_righthand)) {
 			/*
 			 * Clause refers to only one rel, so ignore it --- unless it
 			 * contains volatile functions, in which case we'd better punt.
@@ -1207,35 +1096,29 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 		}
 
 		/* check rel membership of arguments */
-		if (!bms_is_empty(right_varnos) &&
-			bms_is_subset(right_varnos, sjinfo->syn_righthand) &&
-			!bms_overlap(left_varnos, sjinfo->syn_righthand))
-		{
+		if (!bms_is_empty(right_varnos)
+				&& bms_is_subset(right_varnos, sjinfo->syn_righthand)
+				&& !bms_overlap(left_varnos, sjinfo->syn_righthand)) {
 			/* typical case, right_expr is RHS variable */
-		}
-		else if (!bms_is_empty(left_varnos) &&
-				 bms_is_subset(left_varnos, sjinfo->syn_righthand) &&
-				 !bms_overlap(right_varnos, sjinfo->syn_righthand))
-		{
+		} else if (!bms_is_empty(left_varnos)
+				&& bms_is_subset(left_varnos, sjinfo->syn_righthand)
+				&& !bms_overlap(right_varnos, sjinfo->syn_righthand)) {
 			/* flipped case, left_expr is RHS variable */
 			opno = get_commutator(opno);
 			if (!OidIsValid(opno))
 				goto no_unique_path;
 			right_expr = left_expr;
-		}
-		else
+		} else
 			goto no_unique_path;
 
 		/* all operators must be btree equality or hash equality */
-		if (all_btree)
-		{
+		if (all_btree) {
 			/* oprcanmerge is considered a hint... */
 			if (!op_mergejoinable(opno, opinputtype) ||
-				get_mergejoin_opfamilies(opno) == NIL)
+			get_mergejoin_opfamilies(opno) == NIL)
 				all_btree = false;
 		}
-		if (all_hash)
-		{
+		if (all_hash) {
 			/* ... but oprcanhash had better be correct */
 			if (!op_hashjoinable(opno, opinputtype))
 				all_hash = false;
@@ -1284,10 +1167,9 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 	 * relation_has_unique_index_for automatically considers restriction
 	 * clauses for the rel, as well.
 	 */
-	if (rel->rtekind == RTE_RELATION && all_btree &&
-		relation_has_unique_index_for(root, rel, NIL,
-									  uniq_exprs, in_operators))
-	{
+	if (rel->rtekind == RTE_RELATION && all_btree
+			&& relation_has_unique_index_for(root, rel, NIL, uniq_exprs,
+					in_operators)) {
 		pathnode->umethod = UNIQUE_PATH_NOOP;
 		pathnode->path.rows = rel->rows;
 		pathnode->path.startup_cost = subpath->startup_cost;
@@ -1310,17 +1192,15 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 	 * referencing subquery outputs.  (Possibly we could do something with
 	 * expressions in the subquery outputs, too, but for now keep it simple.)
 	 */
-	if (rel->rtekind == RTE_SUBQUERY)
-	{
+	if (rel->rtekind == RTE_SUBQUERY) {
 		RangeTblEntry *rte = planner_rt_fetch(rel->relid, root);
-		List	   *sub_tlist_colnos;
+		List *sub_tlist_colnos;
 
 		sub_tlist_colnos = translate_sub_tlist(uniq_exprs, rel->relid);
 
-		if (sub_tlist_colnos &&
-			query_is_distinct_for(rte->subquery,
-								  sub_tlist_colnos, in_operators))
-		{
+		if (sub_tlist_colnos
+				&& query_is_distinct_for(rte->subquery, sub_tlist_colnos,
+						in_operators)) {
 			pathnode->umethod = UNIQUE_PATH_NOOP;
 			pathnode->path.rows = rel->rows;
 			pathnode->path.startup_cost = subpath->startup_cost;
@@ -1339,18 +1219,12 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 	pathnode->path.rows = estimate_num_groups(root, uniq_exprs, rel->rows);
 	numCols = list_length(uniq_exprs);
 
-	if (all_btree)
-	{
+	if (all_btree) {
 		/*
 		 * Estimate cost for sort+unique implementation
 		 */
-		cost_sort(&sort_path, root, NIL,
-				  subpath->total_cost,
-				  rel->rows,
-				  rel->width,
-				  0.0,
-				  work_mem,
-				  -1.0);
+		cost_sort(&sort_path, root, NIL, subpath->total_cost, rel->rows,
+				rel->width, 0.0, work_mem, -1.0);
 
 		/*
 		 * Charge one cpu_operator_cost per comparison per input tuple. We
@@ -1361,46 +1235,37 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 		sort_path.total_cost += cpu_operator_cost * rel->rows * numCols;
 	}
 
-	if (all_hash)
-	{
+	if (all_hash) {
 		/*
 		 * Estimate the overhead per hashtable entry at 64 bytes (same as in
 		 * planner.c).
 		 */
-		int			hashentrysize = rel->width + 64;
+		int hashentrysize = rel->width + 64;
 
 		if (hashentrysize * pathnode->path.rows > work_mem * 1024L)
-			all_hash = false;	/* don't try to hash */
+			all_hash = false; /* don't try to hash */
 		else
-			cost_agg(&agg_path, root,
-					 AGG_HASHED, NULL,
-					 numCols, pathnode->path.rows,
-					 subpath->startup_cost,
-					 subpath->total_cost,
-					 rel->rows);
+			cost_agg(&agg_path, root, AGG_HASHED, NULL, numCols,
+					pathnode->path.rows, subpath->startup_cost,
+					subpath->total_cost, rel->rows);
 	}
 
-	if (all_btree && all_hash)
-	{
+	if (all_btree && all_hash) {
 		if (agg_path.total_cost < sort_path.total_cost)
 			pathnode->umethod = UNIQUE_PATH_HASH;
 		else
 			pathnode->umethod = UNIQUE_PATH_SORT;
-	}
-	else if (all_btree)
+	} else if (all_btree)
 		pathnode->umethod = UNIQUE_PATH_SORT;
 	else if (all_hash)
 		pathnode->umethod = UNIQUE_PATH_HASH;
 	else
 		goto no_unique_path;
 
-	if (pathnode->umethod == UNIQUE_PATH_HASH)
-	{
+	if (pathnode->umethod == UNIQUE_PATH_HASH) {
 		pathnode->path.startup_cost = agg_path.startup_cost;
 		pathnode->path.total_cost = agg_path.total_cost;
-	}
-	else
-	{
+	} else {
 		pathnode->path.startup_cost = sort_path.startup_cost;
 		pathnode->path.total_cost = sort_path.total_cost;
 	}
@@ -1411,7 +1276,7 @@ create_unique_path(PlannerInfo *root, RelOptInfo *rel, Path *subpath,
 
 	return pathnode;
 
-no_unique_path:			/* failure exit */
+	no_unique_path: /* failure exit */
 
 	/* Mark the SpecialJoinInfo as not unique-able */
 	sjinfo->join_quals = NIL;
@@ -1433,18 +1298,15 @@ no_unique_path:			/* failure exit */
  * return NIL.
  */
 static List *
-translate_sub_tlist(List *tlist, int relid)
-{
-	List	   *result = NIL;
-	ListCell   *l;
+translate_sub_tlist(List *tlist, int relid) {
+	List *result = NIL;
+	ListCell *l;
 
-	foreach(l, tlist)
-	{
-		Var		   *var = (Var *) lfirst(l);
+	foreach(l, tlist) {
+		Var *var = (Var *) lfirst(l);
 
-		if (!var || !IsA(var, Var) ||
-			var->varno != relid)
-			return NIL;			/* punt */
+		if (!var || !IsA(var, Var) || var->varno != relid)
+			return NIL; /* punt */
 
 		result = lappend_int(result, var->varattno);
 	}
@@ -1466,11 +1328,9 @@ translate_sub_tlist(List *tlist, int relid)
  * should give trustworthy answers for all operators that we might need
  * to deal with here.)
  */
-static bool
-query_is_distinct_for(Query *query, List *colnos, List *opids)
-{
-	ListCell   *l;
-	Oid			opid;
+static bool query_is_distinct_for(Query *query, List *colnos, List *opids) {
+	ListCell *l;
+	Oid opid;
 
 	Assert(list_length(colnos) == list_length(opids));
 
@@ -1479,20 +1339,17 @@ query_is_distinct_for(Query *query, List *colnos, List *opids)
 	 * columns in the DISTINCT clause appear in colnos and operator semantics
 	 * match.
 	 */
-	if (query->distinctClause)
-	{
-		foreach(l, query->distinctClause)
-		{
+	if (query->distinctClause) {
+		foreach(l, query->distinctClause) {
 			SortGroupClause *sgc = (SortGroupClause *) lfirst(l);
-			TargetEntry *tle = get_sortgroupclause_tle(sgc,
-													   query->targetList);
+			TargetEntry *tle = get_sortgroupclause_tle(sgc, query->targetList);
 
 			opid = distinct_col_search(tle->resno, colnos, opids);
-			if (!OidIsValid(opid) ||
-				!equality_ops_are_compatible(opid, sgc->eqop))
-				break;			/* exit early if no match */
+			if (!OidIsValid(opid)
+					|| !equality_ops_are_compatible(opid, sgc->eqop))
+				break; /* exit early if no match */
 		}
-		if (l == NULL)			/* had matches for all? */
+		if (l == NULL) /* had matches for all? */
 			return true;
 	}
 
@@ -1500,24 +1357,19 @@ query_is_distinct_for(Query *query, List *colnos, List *opids)
 	 * Similarly, GROUP BY guarantees uniqueness if all the grouped columns
 	 * appear in colnos and operator semantics match.
 	 */
-	if (query->groupClause)
-	{
-		foreach(l, query->groupClause)
-		{
+	if (query->groupClause) {
+		foreach(l, query->groupClause) {
 			SortGroupClause *sgc = (SortGroupClause *) lfirst(l);
-			TargetEntry *tle = get_sortgroupclause_tle(sgc,
-													   query->targetList);
+			TargetEntry *tle = get_sortgroupclause_tle(sgc, query->targetList);
 
 			opid = distinct_col_search(tle->resno, colnos, opids);
-			if (!OidIsValid(opid) ||
-				!equality_ops_are_compatible(opid, sgc->eqop))
-				break;			/* exit early if no match */
+			if (!OidIsValid(opid)
+					|| !equality_ops_are_compatible(opid, sgc->eqop))
+				break; /* exit early if no match */
 		}
-		if (l == NULL)			/* had matches for all? */
+		if (l == NULL) /* had matches for all? */
 			return true;
-	}
-	else
-	{
+	} else {
 		/*
 		 * If we have no GROUP BY, but do have aggregates or HAVING, then the
 		 * result is at most one row so it's surely unique, for any operators.
@@ -1530,26 +1382,23 @@ query_is_distinct_for(Query *query, List *colnos, List *opids)
 	 * UNION, INTERSECT, EXCEPT guarantee uniqueness of the whole output row,
 	 * except with ALL.
 	 */
-	if (query->setOperations)
-	{
+	if (query->setOperations) {
 		SetOperationStmt *topop = (SetOperationStmt *) query->setOperations;
 
 		Assert(IsA(topop, SetOperationStmt));
 		Assert(topop->op != SETOP_NONE);
 
-		if (!topop->all)
-		{
-			ListCell   *lg;
+		if (!topop->all) {
+			ListCell *lg;
 
 			/* We're good if all the nonjunk output columns are in colnos */
 			lg = list_head(topop->groupClauses);
-			foreach(l, query->targetList)
-			{
+			foreach(l, query->targetList) {
 				TargetEntry *tle = (TargetEntry *) lfirst(l);
 				SortGroupClause *sgc;
 
 				if (tle->resjunk)
-					continue;	/* ignore resjunk columns */
+					continue; /* ignore resjunk columns */
 
 				/* non-resjunk columns should have grouping clauses */
 				Assert(lg != NULL);
@@ -1557,11 +1406,11 @@ query_is_distinct_for(Query *query, List *colnos, List *opids)
 				lg = lnext(lg);
 
 				opid = distinct_col_search(tle->resno, colnos, opids);
-				if (!OidIsValid(opid) ||
-					!equality_ops_are_compatible(opid, sgc->eqop))
-					break;		/* exit early if no match */
+				if (!OidIsValid(opid)
+						|| !equality_ops_are_compatible(opid, sgc->eqop))
+					break; /* exit early if no match */
 			}
-			if (l == NULL)		/* had matches for all? */
+			if (l == NULL) /* had matches for all? */
 				return true;
 		}
 	}
@@ -1581,14 +1430,10 @@ query_is_distinct_for(Query *query, List *colnos, List *opids)
  * else return InvalidOid.	(We expect colnos does not contain duplicates,
  * so the result is well-defined.)
  */
-static Oid
-distinct_col_search(int colno, List *colnos, List *opids)
-{
-	ListCell   *lc1,
-			   *lc2;
-
-	forboth(lc1, colnos, lc2, opids)
-	{
+static Oid distinct_col_search(int colno, List *colnos, List *opids) {
+	ListCell *lc1, *lc2;
+
+	forboth(lc1, colnos, lc2, opids) {
 		if (colno == lfirst_int(lc1))
 			return lfirst_oid(lc2);
 	}
@@ -1601,15 +1446,13 @@ distinct_col_search(int colno, List *colnos, List *opids)
  *	  returning the pathnode.
  */
 Path *
-create_subqueryscan_path(PlannerInfo *root, RelOptInfo *rel,
-						 List *pathkeys, Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+create_subqueryscan_path(PlannerInfo *root, RelOptInfo *rel, List *pathkeys,
+		Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_SubqueryScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
 	pathnode->pathkeys = pathkeys;
 
 	cost_subqueryscan(pathnode, root, rel, pathnode->param_info);
@@ -1623,15 +1466,13 @@ create_subqueryscan_path(PlannerInfo *root, RelOptInfo *rel,
  *	  returning the pathnode.
  */
 Path *
-create_functionscan_path(PlannerInfo *root, RelOptInfo *rel,
-						 List *pathkeys, Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+create_functionscan_path(PlannerInfo *root, RelOptInfo *rel, List *pathkeys,
+		Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_FunctionScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
 	pathnode->pathkeys = pathkeys;
 
 	cost_functionscan(pathnode, root, rel, pathnode->param_info);
@@ -1646,15 +1487,13 @@ create_functionscan_path(PlannerInfo *root, RelOptInfo *rel,
  */
 Path *
 create_valuesscan_path(PlannerInfo *root, RelOptInfo *rel,
-					   Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+		Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_ValuesScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
-	pathnode->pathkeys = NIL;	/* result is always unordered */
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
+	pathnode->pathkeys = NIL; /* result is always unordered */
 
 	cost_valuesscan(pathnode, root, rel, pathnode->param_info);
 
@@ -1667,15 +1506,13 @@ create_valuesscan_path(PlannerInfo *root, RelOptInfo *rel,
  *	  returning the pathnode.
  */
 Path *
-create_ctescan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+create_ctescan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_CteScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
-	pathnode->pathkeys = NIL;	/* XXX for now, result is always unordered */
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
+	pathnode->pathkeys = NIL; /* XXX for now, result is always unordered */
 
 	cost_ctescan(pathnode, root, rel, pathnode->param_info);
 
@@ -1689,15 +1526,13 @@ create_ctescan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer)
  */
 Path *
 create_worktablescan_path(PlannerInfo *root, RelOptInfo *rel,
-						  Relids required_outer)
-{
-	Path	   *pathnode = makeNode(Path);
+		Relids required_outer) {
+	Path *pathnode = makeNode(Path);
 
 	pathnode->pathtype = T_WorkTableScan;
 	pathnode->parent = rel;
-	pathnode->param_info = get_baserel_parampathinfo(root, rel,
-													 required_outer);
-	pathnode->pathkeys = NIL;	/* result is always unordered */
+	pathnode->param_info = get_baserel_parampathinfo(root, rel, required_outer);
+	pathnode->pathkeys = NIL; /* result is always unordered */
 
 	/* Cost is the same as for a regular CTE scan */
 	cost_ctescan(pathnode, root, rel, pathnode->param_info);
@@ -1716,18 +1551,15 @@ create_worktablescan_path(PlannerInfo *root, RelOptInfo *rel,
  * way to calculate them in core.
  */
 ForeignPath *
-create_foreignscan_path(PlannerInfo *root, RelOptInfo *rel,
-						double rows, Cost startup_cost, Cost total_cost,
-						List *pathkeys,
-						Relids required_outer,
-						List *fdw_private)
-{
+create_foreignscan_path(PlannerInfo *root, RelOptInfo *rel, double rows,
+		Cost startup_cost, Cost total_cost, List *pathkeys,
+		Relids required_outer, List *fdw_private) {
 	ForeignPath *pathnode = makeNode(ForeignPath);
 
 	pathnode->path.pathtype = T_ForeignScan;
 	pathnode->path.parent = rel;
 	pathnode->path.param_info = get_baserel_parampathinfo(root, rel,
-														  required_outer);
+			required_outer);
 	pathnode->path.rows = rows;
 	pathnode->path.startup_cost = startup_cost;
 	pathnode->path.total_cost = total_cost;
@@ -1744,12 +1576,10 @@ create_foreignscan_path(PlannerInfo *root, RelOptInfo *rel,
  *
  * Note: result must not share storage with either input
  */
-Relids
-calc_nestloop_required_outer(Path *outer_path, Path *inner_path)
-{
-	Relids		outer_paramrels = PATH_REQ_OUTER(outer_path);
-	Relids		inner_paramrels = PATH_REQ_OUTER(inner_path);
-	Relids		required_outer;
+Relids calc_nestloop_required_outer(Path *outer_path, Path *inner_path) {
+	Relids outer_paramrels = PATH_REQ_OUTER(outer_path);
+	Relids inner_paramrels = PATH_REQ_OUTER(inner_path);
+	Relids required_outer;
 
 	/* inner_path can require rels from outer path, but not vice versa */
 	Assert(!bms_overlap(outer_paramrels, inner_path->parent->relids));
@@ -1760,10 +1590,9 @@ calc_nestloop_required_outer(Path *outer_path, Path *inner_path)
 	required_outer = bms_union(outer_paramrels, inner_paramrels);
 	/* ... and remove any mention of now-satisfied outer rels */
 	required_outer = bms_del_members(required_outer,
-									 outer_path->parent->relids);
+			outer_path->parent->relids);
 	/* maintain invariant that required_outer is exactly NULL if empty */
-	if (bms_is_empty(required_outer))
-	{
+	if (bms_is_empty(required_outer)) {
 		bms_free(required_outer);
 		required_outer = NULL;
 	}
@@ -1776,12 +1605,10 @@ calc_nestloop_required_outer(Path *outer_path, Path *inner_path)
  *
  * Note: result must not share storage with either input
  */
-Relids
-calc_non_nestloop_required_outer(Path *outer_path, Path *inner_path)
-{
-	Relids		outer_paramrels = PATH_REQ_OUTER(outer_path);
-	Relids		inner_paramrels = PATH_REQ_OUTER(inner_path);
-	Relids		required_outer;
+Relids calc_non_nestloop_required_outer(Path *outer_path, Path *inner_path) {
+	Relids outer_paramrels = PATH_REQ_OUTER(outer_path);
+	Relids inner_paramrels = PATH_REQ_OUTER(inner_path);
+	Relids required_outer;
 
 	/* neither path can require rels from the other */
 	Assert(!bms_overlap(outer_paramrels, inner_path->parent->relids));
@@ -1811,20 +1638,12 @@ calc_non_nestloop_required_outer(Path *outer_path, Path *inner_path)
  * Returns the resulting path node.
  */
 NestPath *
-create_nestloop_path(PlannerInfo *root,
-					 RelOptInfo *joinrel,
-					 JoinType jointype,
-					 JoinCostWorkspace *workspace,
-					 SpecialJoinInfo *sjinfo,
-					 SemiAntiJoinFactors *semifactors,
-					 Path *outer_path,
-					 Path *inner_path,
-					 List *restrict_clauses,
-					 List *pathkeys,
-					 Relids required_outer)
-{
-	NestPath   *pathnode = makeNode(NestPath);
-	Relids		inner_req_outer = PATH_REQ_OUTER(inner_path);
+create_nestloop_path(PlannerInfo *root, RelOptInfo *joinrel, JoinType jointype,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors, Path *outer_path, Path *inner_path,
+		List *restrict_clauses, List *pathkeys, Relids required_outer) {
+	NestPath *pathnode = makeNode(NestPath);
+	Relids inner_req_outer = PATH_REQ_OUTER(inner_path);
 
 	/*
 	 * If the inner path is parameterized by the outer, we must drop any
@@ -1833,20 +1652,17 @@ create_nestloop_path(PlannerInfo *root,
 	 * because the restrict_clauses list can affect the size and cost
 	 * estimates for this path.
 	 */
-	if (bms_overlap(inner_req_outer, outer_path->parent->relids))
-	{
-		Relids		inner_and_outer = bms_union(inner_path->parent->relids,
-												inner_req_outer);
-		List	   *jclauses = NIL;
-		ListCell   *lc;
-
-		foreach(lc, restrict_clauses)
-		{
+	if (bms_overlap(inner_req_outer, outer_path->parent->relids)) {
+		Relids inner_and_outer = bms_union(inner_path->parent->relids,
+				inner_req_outer);
+		List *jclauses = NIL;
+		ListCell *lc;
+
+		foreach(lc, restrict_clauses) {
 			RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
-			if (!join_clause_is_movable_into(rinfo,
-											 inner_path->parent->relids,
-											 inner_and_outer))
+			if (!join_clause_is_movable_into(rinfo, inner_path->parent->relids,
+					inner_and_outer))
 				jclauses = lappend(jclauses, rinfo);
 		}
 		restrict_clauses = jclauses;
@@ -1854,14 +1670,8 @@ create_nestloop_path(PlannerInfo *root,
 
 	pathnode->path.pathtype = T_NestLoop;
 	pathnode->path.parent = joinrel;
-	pathnode->path.param_info =
-		get_joinrel_parampathinfo(root,
-								  joinrel,
-								  outer_path,
-								  inner_path,
-								  sjinfo,
-								  required_outer,
-								  &restrict_clauses);
+	pathnode->path.param_info = get_joinrel_parampathinfo(root, joinrel,
+			outer_path, inner_path, sjinfo, required_outer, &restrict_clauses);
 	pathnode->path.pathkeys = pathkeys;
 	pathnode->jointype = jointype;
 	pathnode->outerjoinpath = outer_path;
@@ -1893,32 +1703,17 @@ create_nestloop_path(PlannerInfo *root,
  * 'innersortkeys' are the sort varkeys for the inner relation
  */
 MergePath *
-create_mergejoin_path(PlannerInfo *root,
-					  RelOptInfo *joinrel,
-					  JoinType jointype,
-					  JoinCostWorkspace *workspace,
-					  SpecialJoinInfo *sjinfo,
-					  Path *outer_path,
-					  Path *inner_path,
-					  List *restrict_clauses,
-					  List *pathkeys,
-					  Relids required_outer,
-					  List *mergeclauses,
-					  List *outersortkeys,
-					  List *innersortkeys)
-{
-	MergePath  *pathnode = makeNode(MergePath);
+create_mergejoin_path(PlannerInfo *root, RelOptInfo *joinrel, JoinType jointype,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo, Path *outer_path,
+		Path *inner_path, List *restrict_clauses, List *pathkeys,
+		Relids required_outer, List *mergeclauses, List *outersortkeys,
+		List *innersortkeys) {
+	MergePath *pathnode = makeNode(MergePath);
 
 	pathnode->jpath.path.pathtype = T_MergeJoin;
 	pathnode->jpath.path.parent = joinrel;
-	pathnode->jpath.path.param_info =
-		get_joinrel_parampathinfo(root,
-								  joinrel,
-								  outer_path,
-								  inner_path,
-								  sjinfo,
-								  required_outer,
-								  &restrict_clauses);
+	pathnode->jpath.path.param_info = get_joinrel_parampathinfo(root, joinrel,
+			outer_path, inner_path, sjinfo, required_outer, &restrict_clauses);
 	pathnode->jpath.path.pathkeys = pathkeys;
 	pathnode->jpath.jointype = jointype;
 	pathnode->jpath.outerjoinpath = outer_path;
@@ -1951,30 +1746,16 @@ create_mergejoin_path(PlannerInfo *root,
  *		(this should be a subset of the restrict_clauses list)
  */
 HashPath *
-create_hashjoin_path(PlannerInfo *root,
-					 RelOptInfo *joinrel,
-					 JoinType jointype,
-					 JoinCostWorkspace *workspace,
-					 SpecialJoinInfo *sjinfo,
-					 SemiAntiJoinFactors *semifactors,
-					 Path *outer_path,
-					 Path *inner_path,
-					 List *restrict_clauses,
-					 Relids required_outer,
-					 List *hashclauses)
-{
-	HashPath   *pathnode = makeNode(HashPath);
+create_hashjoin_path(PlannerInfo *root, RelOptInfo *joinrel, JoinType jointype,
+		JoinCostWorkspace *workspace, SpecialJoinInfo *sjinfo,
+		SemiAntiJoinFactors *semifactors, Path *outer_path, Path *inner_path,
+		List *restrict_clauses, Relids required_outer, List *hashclauses) {
+	HashPath *pathnode = makeNode(HashPath);
 
 	pathnode->jpath.path.pathtype = T_HashJoin;
 	pathnode->jpath.path.parent = joinrel;
-	pathnode->jpath.path.param_info =
-		get_joinrel_parampathinfo(root,
-								  joinrel,
-								  outer_path,
-								  inner_path,
-								  sjinfo,
-								  required_outer,
-								  &restrict_clauses);
+	pathnode->jpath.path.param_info = get_joinrel_parampathinfo(root, joinrel,
+			outer_path, inner_path, sjinfo, required_outer, &restrict_clauses);
 
 	/*
 	 * A hashjoin never has pathkeys, since its output ordering is
@@ -2018,75 +1799,78 @@ create_hashjoin_path(PlannerInfo *root,
  * as members of an append path.
  */
 Path *
-reparameterize_path(PlannerInfo *root, Path *path,
-					Relids required_outer,
-					double loop_count)
-{
+reparameterize_path(PlannerInfo *root, Path *path, Relids required_outer,
+		double loop_count) {
 	RelOptInfo *rel = path->parent;
 
 	/* Can only increase, not decrease, path's parameterization */
 	if (!bms_is_subset(PATH_REQ_OUTER(path), required_outer))
 		return NULL;
-	switch (path->pathtype)
-	{
-		case T_SeqScan:
-			return create_seqscan_path(root, rel, required_outer);
-		case T_IndexScan:
-		case T_IndexOnlyScan:
-			{
-				IndexPath  *ipath = (IndexPath *) path;
-				IndexPath  *newpath = makeNode(IndexPath);
+	switch (path->pathtype) {
+	case T_SeqScan:
+		return create_seqscan_path(root, rel, required_outer);
+	case T_IndexScan:
+	case T_IndexOnlyScan: {
+		IndexPath *ipath = (IndexPath *) path;
+		IndexPath *newpath = makeNode(IndexPath);
 
-				/*
-				 * We can't use create_index_path directly, and would not want
-				 * to because it would re-compute the indexqual conditions
-				 * which is wasted effort.	Instead we hack things a bit:
-				 * flat-copy the path node, revise its param_info, and redo
-				 * the cost estimate.
-				 */
-				memcpy(newpath, ipath, sizeof(IndexPath));
-				newpath->path.param_info =
-					get_baserel_parampathinfo(root, rel, required_outer);
-				cost_index(newpath, root, loop_count);
-				return (Path *) newpath;
-			}
-		case T_BitmapHeapScan:
-			{
-				BitmapHeapPath *bpath = (BitmapHeapPath *) path;
+		/*
+		 * We can't use create_index_path directly, and would not want
+		 * to because it would re-compute the indexqual conditions
+		 * which is wasted effort.	Instead we hack things a bit:
+		 * flat-copy the path node, revise its param_info, and redo
+		 * the cost estimate.
+		 */
+		memcpy(newpath, ipath, sizeof(IndexPath));
+		newpath->path.param_info = get_baserel_parampathinfo(root, rel,
+				required_outer);
+		cost_index(newpath, root, loop_count);
+		return (Path *) newpath;
+	}
+	case T_BitmapHeapScan: {
+		BitmapHeapPath *bpath = (BitmapHeapPath *) path;
 
-				return (Path *) create_bitmap_heap_path(root,
-														rel,
-														bpath->bitmapqual,
-														required_outer,
-														loop_count);
-			}
-		case T_SubqueryScan:
-			return create_subqueryscan_path(root, rel, path->pathkeys,
-											required_outer);
-		default:
-			break;
+		return (Path *) create_bitmap_heap_path(root, rel, bpath->bitmapqual,
+				required_outer, loop_count);
+	}
+	case T_SubqueryScan:
+		return create_subqueryscan_path(root, rel, path->pathkeys,
+				required_outer);
+	default:
+		break;
 	}
 	return NULL;
 }
-int get_baserel_memo_size(char *rel_name, int level) {
+int get_baserel_memo_size(char *rel_name, int level, int clauses_length,
+		char *quals) {
 	FILE *file = AllocateFile("memoTxt.txt", "rb");
 	char buffer[200];
 	char relname[200];
+	char cquals[200];
 	int level_n;
 	int estsize;
 	int actsize;
 	int max = 200;
+
+	memset(cquals, '\0', sizeof(cquals));
+
 	printf("Checking rows for %s at level %d\n", rel_name, level);
-		fflush(stdout);
+
+	fflush(stdout);
 	while (fgets(buffer, max, file) != NULL) {
 
-		if (sscanf(buffer, "%d %s %d %d", &level_n,relname, &estsize, &actsize) > 0) {
+		if (sscanf(buffer, "%d %s %d %d %[^\n]", &level_n, relname, &estsize,
+				&actsize, cquals) > 0) {
 			//printf("token rel: %s\n\r", buffer);
-			if (!strcmp(relname, rel_name) && level_n == level) {
-			printf("found rel: %s at level %d\n", rel_name,level_n);
-			fflush(stdout);
+			if (!strcmp(relname, rel_name) && level_n == level
+					&& comp_set_clauses(cquals, quals)) {
+				printf("found rel: %s at level %d with %d clauses \n", rel_name,
+						level_n, clauses_length);
+				fflush(stdout);
 				return actsize;
 			}
+			memset(relname, '\0', sizeof(relname));
+			level_n = 0;
 
 		}
 
@@ -2096,25 +1880,52 @@ int get_baserel_memo_size(char *rel_name, int level) {
 
 }
 
-int get_join_memo_size(char *rel_names, int level) {
+static void parse_node(char *node, char *buffer) {
+	char start = node[0];
+	switch (start) {
+	case '{':
+		parse_operator(&node[1], buffer);
+		break;
+	case '(':
+
+	default:
+		printf("String malformed ");
+		break;
+
+	}
+
+}
+static void parse_operator(char *node, char *buffer) {
+	char operator[15];
+	char value[4];
+	int length = strlen(node);
+	char rest[length];
+	sscanf(node, ":%s %s %s", &operator, value, &rest);
+
+}
+
+int get_join_memo_size(char *rel_names, int level, char *quals) {
 
 	FILE *file = AllocateFile("memoTxt.txt", "rb");
-	int max = strlen(rel_names);
+
 	char buffer[200];
-	char relnames[max];
+	char relnames[100];
 	int level_n;
 	int estsize;
 	int actsize;
+	int lclauses;
 	const char s[2] = ",";
-
 	char *found;
 
 	char *rel_name;
-	printf("Checking rows for %s at level %d\n", rel_names, level);
+
+	printf("Checking join rows for %s at level %d\n", rel_names, level);
 	fflush(stdout);
 	while (fgets(buffer, 200, file) != NULL) {
-		if (sscanf(buffer, "%d [ %s ] %d %d",&level_n, relnames, &estsize, &actsize) > 0) {
-			if (max == strlen(relnames) && level == level_n) {
+		if (sscanf(buffer, "%d [ %s ] %d %d %s", &level_n, relnames, &estsize,
+				&actsize, &lclauses) > 0) {
+
+			if (strlen(rel_names) == strlen(relnames) && level == level_n) {
 				rel_name = strtok(relnames, s);
 				while (rel_name != NULL) {
 
@@ -2125,12 +1936,15 @@ int get_join_memo_size(char *rel_names, int level) {
 
 				}
 				if (found != NULL) {
-					printf("found rel: %s at level %d\n", rel_names,level_n);
-								fflush(stdout);
+					printf("found  join rel: %s at level %d and rows %d\n",
+							rel_names, level_n, actsize);
+					fflush(stdout);
 					return actsize;
 				}
 
 			}
+			memset(relnames, '\0', sizeof(relnames));
+			level_n = 0;
 
 		}
 	}
@@ -2138,3 +1952,36 @@ int get_join_memo_size(char *rel_names, int level) {
 	return -1;
 
 }
+bool comp_set_clauses(char *str_1, char *str_2) {
+
+	char *found;
+	int len1 = strlen(str_1) + 1;
+	int len2 = strlen(str_2) + 1;
+	char str1[len1];
+	char str2[len2];
+	strcpy(str1, str_1);
+	strcpy(str2, str_2);
+
+	char *tmp;
+	const char s[2] = ",";
+
+	if (strlen(str1) == strlen(str2)) {
+		tmp = strtok(str2, s);
+		while (tmp != NULL) {
+
+			found = strstr(str1, tmp);
+			if (found == NULL)
+				break;
+			tmp = strtok(NULL, s);
+
+		}
+		if (found != NULL) {
+			printf("found string %s \n", str_2);
+			fflush(stdout);
+			return true;
+		}
+
+	}
+	return false;
+
+}
diff --git a/src/backend/optimizer/util/relnode.c b/src/backend/optimizer/util/relnode.c
index 0197beb..ca18708 100644
--- a/src/backend/optimizer/util/relnode.c
+++ b/src/backend/optimizer/util/relnode.c
@@ -29,6 +29,7 @@
 #include "catalog/namespace.h"
 #include "c.h"
 #include "storage/fd.h"
+#include "nodes/print.h"
 
 typedef struct JoinHashEntry {
 	Relids join_relids; /* hash key --- MUST BE FIRST */
@@ -66,8 +67,7 @@ void setup_simple_rel_arrays(PlannerInfo *root) {
 	root->simple_rte_array = (RangeTblEntry **) palloc0(
 			root->simple_rel_array_size * sizeof(RangeTblEntry *));
 	rti = 1;
-	foreach(lc, root->parse->rtable)
-	{
+	foreach(lc, root->parse->rtable) {
 		RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);
 
 		root->simple_rte_array[rti++] = rte;
@@ -82,7 +82,7 @@ RelOptInfo *
 build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 	RelOptInfo *rel;
 	RangeTblEntry *rte;
-	int memo_size;
+	Relation relation;
 	/* Rel should not exist already */
 	Assert(relid > 0 && relid < root->simple_rel_array_size);
 	if (root->simple_rel_array[relid] != NULL)
@@ -135,12 +135,6 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 		/* Table --- retrieve statistics from the system catalogs */
 		get_relation_info(root, rte->relid, rte->inh, rel);
 		/*hack for memo*/
-		if (enable_memo) {
-			printf("memo status : %d", enable_memo);
-			memo_size = get_baserel_memo_size(rel->rel_name,root->query_level);
-			//printf("rel size was : %d", memo_size );
-			rel->rows = memo_size;
-		}
 		break;
 	case RTE_SUBQUERY:
 	case RTE_FUNCTION:
@@ -153,6 +147,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 		 *
 		 * Note: 0 is included in range to support whole-row Vars
 		 */
+
 		rel->min_attr = 0;
 		rel->max_attr = list_length(rte->eref->colnames);
 		rel->attr_needed = (Relids *) palloc0(
@@ -177,8 +172,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptKind reloptkind) {
 	if (rte->inh) {
 		ListCell *l;
 
-		foreach(l, root->append_rel_list)
-		{
+		foreach(l, root->append_rel_list) {
 			AppendRelInfo *appinfo = (AppendRelInfo *) lfirst(l);
 
 			/* append_rel_list contains all append rels; ignore others */
@@ -231,11 +225,9 @@ static void build_join_rel_hash(PlannerInfo *root) {
 	hash_ctl.match = bitmap_match;
 	hash_ctl.hcxt = CurrentMemoryContext;
 	hashtab = hash_create("JoinRelHashTable", 256L, &hash_ctl,
-	HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
+			HASH_ELEM | HASH_FUNCTION | HASH_COMPARE | HASH_CONTEXT);
 
-	/* Insert all the already-existing joinrels */
-	foreach(l, root->join_rel_list)
-	{
+	/* Insert all the already-existing joinrels */foreach(l, root->join_rel_list) {
 		RelOptInfo *rel = (RelOptInfo *) lfirst(l);
 		JoinHashEntry *hentry;
 		bool found;
@@ -276,15 +268,13 @@ find_join_rel(PlannerInfo *root, Relids relids) {
 		JoinHashEntry *hentry;
 
 		hentry = (JoinHashEntry *) hash_search(root->join_rel_hash, &hashkey,
-				HASH_FIND,
-				NULL);
+				HASH_FIND, NULL);
 		if (hentry)
 			return hentry->join_rel;
 	} else {
 		ListCell *l;
 
-		foreach(l, root->join_rel_list)
-		{
+		foreach(l, root->join_rel_list) {
 			RelOptInfo *rel = (RelOptInfo *) lfirst(l);
 
 			if (bms_equal(rel->relids, relids))
@@ -384,14 +374,14 @@ build_join_rel(PlannerInfo *root, Relids joinrelids, RelOptInfo *outer_rel,
 	/* We build the join mane  separated by colons using names of childs*/
 	/* see stringinfo.h for an explanation of this maneuver */
 	initStringInfo(&join_name);
+
 	appendStringInfoString(&join_name, inner_rel->rel_name);
+
 	appendStringInfoChar(&join_name, ',');
+
 	appendStringInfoString(&join_name, outer_rel->rel_name);
+
 	joinrel->rel_name = join_name.data;
-	name_len = strlen(join_name.data) + 1;
-	rel_names = palloc(name_len * sizeof(joinrel->rel_name));
-	memset(rel_names, '\0', name_len);
-	strcpy(rel_names, joinrel->rel_name);
 
 	/*
 	 * Create a new tlist containing just the vars that need to be output from
@@ -426,15 +416,8 @@ build_join_rel(PlannerInfo *root, Relids joinrelids, RelOptInfo *outer_rel,
 	 * Set estimates of the joinrel's size.
 	 */
 
-	/* hack for memo injection*/ // to-do set_rel
-	if (enable_memo){
-		memo_size = get_join_memo_size(rel_names,root->query_level);
-		joinrel->rows = memo_size;}
-
-
-
-		set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel, sjinfo,
-				restrictlist);
+	set_joinrel_size_estimates(root, joinrel, outer_rel, inner_rel, sjinfo,
+			restrictlist);
 
 	/*
 	 * Add the joinrel to the query's joinrel list, and store it into the
@@ -486,8 +469,7 @@ static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
 	Relids relids = joinrel->relids;
 	ListCell *vars;
 
-	foreach(vars, input_rel->reltargetlist)
-	{
+	foreach(vars, input_rel->reltargetlist) {
 		Var *var = (Var *) lfirst(vars);
 		RelOptInfo *baserel;
 		int ndx;
@@ -505,8 +487,8 @@ static void build_joinrel_tlist(PlannerInfo *root, RelOptInfo *joinrel,
 		 * rels, which will never be seen here.)
 		 */
 		if (!IsA(var, Var))
-			elog(ERROR, "unexpected node type in reltargetlist: %d",
-					(int) nodeTag(var));
+			elog(ERROR,
+					"unexpected node type in reltargetlist: %d", (int) nodeTag(var));
 
 		/* Get the Var's original base rel */
 		baserel = find_base_rel(root, var->varno);
@@ -609,8 +591,7 @@ subbuild_joinrel_restrictlist(RelOptInfo *joinrel, List *joininfo_list,
 		List *new_restrictlist) {
 	ListCell *l;
 
-	foreach(l, joininfo_list)
-	{
+	foreach(l, joininfo_list) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
@@ -638,8 +619,7 @@ subbuild_joinrel_joinlist(RelOptInfo *joinrel, List *joininfo_list,
 		List *new_joininfo) {
 	ListCell *l;
 
-	foreach(l, joininfo_list)
-	{
+	foreach(l, joininfo_list) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(l);
 
 		if (bms_is_subset(rinfo->required_relids, joinrel->relids)) {
@@ -706,8 +686,7 @@ find_childrel_appendrelinfo(PlannerInfo *root, RelOptInfo *rel) {
 	/* Should only be called on child rels */
 	Assert(rel->reloptkind == RELOPT_OTHER_MEMBER_REL);
 
-	foreach(lc, root->append_rel_list)
-	{
+	foreach(lc, root->append_rel_list) {
 		AppendRelInfo *appinfo = (AppendRelInfo *) lfirst(lc);
 
 		if (appinfo->child_relid == relid)
@@ -737,6 +716,7 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	List *pclauses;
 	double rows;
 	ListCell *lc;
+	int lcls = 0;
 
 	/* Unparameterized paths have no ParamPathInfo */
 	if (bms_is_empty(required_outer))
@@ -744,10 +724,9 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 
 	Assert(!bms_overlap(baserel->relids, required_outer));
 
-	/* If we already have a PPI for this parameterization, just return it */
-	foreach(lc, baserel->ppilist)
-	{
+	/* If we already have a PPI for this parameterization, just return it */foreach(lc, baserel->ppilist) {
 		ppi = (ParamPathInfo *) lfirst(lc);
+
 		if (bms_equal(ppi->ppi_req_outer, required_outer))
 			return ppi;
 	}
@@ -758,10 +737,9 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 	 */
 	joinrelids = bms_union(baserel->relids, required_outer);
 	pclauses = NIL;
-	foreach(lc, baserel->joininfo)
-	{
+	foreach(lc, baserel->joininfo) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
-
+		;
 		if (join_clause_is_movable_into(rinfo, baserel->relids, joinrelids))
 			pclauses = lappend(pclauses, rinfo);
 	}
@@ -774,16 +752,12 @@ get_baserel_parampathinfo(PlannerInfo *root, RelOptInfo *baserel,
 			generate_join_implied_equalities(root, joinrelids, required_outer,
 					baserel));
 
-	/* Estimate the number of rows returned by the parameterized scan */
-	if(enable_memo){
-		rows = get_baserel_memo_size(baserel->rel_name,root->query_level);
-		}
-		if(rows == -1){
 	rows = get_parameterized_baserel_size(root, baserel, pclauses);
-		}
+
 	/* And now we can build the ParamPathInfo */
 	ppi = makeNode(ParamPathInfo);
 	ppi->ppi_req_outer = required_outer;
+
 	ppi->ppi_rows = rows;
 	ppi->ppi_clauses = pclauses;
 	baserel->ppilist = lappend(baserel->ppilist, ppi);
@@ -860,8 +834,7 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 		inner_and_req = NULL; /* inner path does not accept parameters */
 
 	pclauses = NIL;
-	foreach(lc, joinrel->joininfo)
-	{
+	foreach(lc, joinrel->joininfo) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
 
 		if (join_clause_is_movable_into(rinfo, joinrel->relids, join_and_req)
@@ -875,14 +848,10 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	/* Consider joinclauses generated by EquivalenceClasses, too */
 	eclauses = generate_join_implied_equalities(root, join_and_req,
 			required_outer, joinrel);
-	/* We only want ones that aren't movable to lower levels */
-	foreach(lc, eclauses)
-	{
+	/* We only want ones that aren't movable to lower levels */foreach(lc, eclauses) {
 		RestrictInfo *rinfo = (RestrictInfo *) lfirst(lc);
-
 		Assert(
-				join_clause_is_movable_into(rinfo, joinrel->relids,
-						join_and_req));
+				join_clause_is_movable_into(rinfo, joinrel->relids, join_and_req));
 		if (!join_clause_is_movable_into(rinfo, outer_path->parent->relids,
 				outer_and_req)
 				&& !join_clause_is_movable_into(rinfo,
@@ -897,22 +866,14 @@ get_joinrel_parampathinfo(PlannerInfo *root, RelOptInfo *joinrel,
 	 */
 	*restrict_clauses = list_concat(pclauses, *restrict_clauses);
 
-	/* If we already have a PPI for this parameterization, just return it */
-	foreach(lc, joinrel->ppilist)
-	{
+	/* If we already have a PPI for this parameterization, just return it */foreach(lc, joinrel->ppilist) {
 		ppi = (ParamPathInfo *) lfirst(lc);
 		if (bms_equal(ppi->ppi_req_outer, required_outer))
 			return ppi;
 	}
 
-	if(enable_memo){
-	rows = get_join_memo_size(joinrel->rel_name,root->query_level);
-	}
-	if(rows == -1){
-	/* Estimate the number of rows returned by the parameterized join */
 	rows = get_parameterized_joinrel_size(root, joinrel, outer_path->rows,
 			inner_path->rows, sjinfo, *restrict_clauses);
-	}
 
 	/*
 	 * And now we can build the ParamPathInfo.	No point in saving the
@@ -951,9 +912,7 @@ get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer) {
 
 	Assert(!bms_overlap(appendrel->relids, required_outer));
 
-	/* If we already have a PPI for this parameterization, just return it */
-	foreach(lc, appendrel->ppilist)
-	{
+	/* If we already have a PPI for this parameterization, just return it */foreach(lc, appendrel->ppilist) {
 		ppi = (ParamPathInfo *) lfirst(lc);
 		if (bms_equal(ppi->ppi_req_outer, required_outer))
 			return ppi;
@@ -969,4 +928,3 @@ get_appendrel_parampathinfo(RelOptInfo *appendrel, Relids required_outer) {
 	return ppi;
 }
 
-
diff --git a/src/backend/utils/misc/guc.c b/src/backend/utils/misc/guc.c
index 2d8264f..cf8d158 100644
--- a/src/backend/utils/misc/guc.c
+++ b/src/backend/utils/misc/guc.c
@@ -810,6 +810,15 @@ static struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 	{
+		{"enable_explain_memo", PGC_USERSET, QUERY_TUNING_METHOD,
+			gettext_noop("Enables explain output special values for memo optimization."),
+			NULL
+		},
+		&enable_explain_memo,
+		false,
+		NULL, NULL, NULL
+	},
+	{
 		{"enable_cost_check", PGC_USERSET, QUERY_TUNING_METHOD,
 			gettext_noop("Enables memo query optimization."),
 			NULL
diff --git a/src/include/commands/prepare.h b/src/include/commands/prepare.h
index 9d438bb..f266059 100644
--- a/src/include/commands/prepare.h
+++ b/src/include/commands/prepare.h
@@ -33,7 +33,7 @@ typedef struct
 	TimestampTz prepare_time;	/* the time when the stmt was prepared */
 } PreparedStatement;
 
-
+extern bool enable_explain_memo;
 /* Utility statements PREPARE, EXECUTE, DEALLOCATE, EXPLAIN EXECUTE */
 extern void PrepareQuery(PrepareStmt *stmt, const char *queryString);
 extern void ExecuteQuery(ExecuteStmt *stmt, IntoClause *intoClause,
diff --git a/src/include/nodes/nodes.h b/src/include/nodes/nodes.h
index 5b8df59..177a626 100644
--- a/src/include/nodes/nodes.h
+++ b/src/include/nodes/nodes.h
@@ -503,6 +503,8 @@ extern PGDLLIMPORT Node *newNodeMacroHolder;
  */
 extern char *nodeToString(const void *obj);
 
+extern char *nodeSimToString(const void *obj);
+
 /*
  * nodes/{readfuncs.c,read.c}
  */
diff --git a/src/include/nodes/plannodes.h b/src/include/nodes/plannodes.h
index b1c78f3..616399e 100644
--- a/src/include/nodes/plannodes.h
+++ b/src/include/nodes/plannodes.h
@@ -96,6 +96,8 @@ typedef struct Plan
 	Cost		startup_cost;	/* cost expended before fetching any tuples */
 	Cost		total_cost;		/* total cost (assuming all tuples fetched) */
 	Cost 		mtotal_cost;
+	Cost 		mstartup_cost;
+	int 		mrows;
 	/*
 	 * planner's estimate of result size of this plan step
 	 */
diff --git a/src/include/nodes/relation.h b/src/include/nodes/relation.h
index f9f7fc6..8ab2bcd 100644
--- a/src/include/nodes/relation.h
+++ b/src/include/nodes/relation.h
@@ -481,7 +481,6 @@ typedef struct RelOptInfo
 	/* size estimates generated by planner */
 	double		rows;			/* estimated number of result tuples */
 	int			width;			/* estimated avg width of result tuples */
-
 	/* per-relation planner control flags */
 	bool		consider_startup;		/* keep cheap-startup-cost paths? */
 
@@ -1301,7 +1300,7 @@ typedef struct RestrictInfo
 	EquivalenceClass *left_ec;	/* EquivalenceClass containing lefthand */
 	EquivalenceClass *right_ec; /* EquivalenceClass containing righthand */
 	EquivalenceMember *left_em; /* EquivalenceMember for lefthand */
-	EquivalenceMember *right_em;	/* EquivalenceMember for righthand */
+	EquivalenceMember *right_em;/* EquivalenceMember for righthand */
 	List	   *scansel_cache;	/* list of MergeScanSelCache structs */
 
 	/* transient workspace for use while considering a specific join path */
diff --git a/src/include/optimizer/pathnode.h b/src/include/optimizer/pathnode.h
index 44c6b36..77c6cb9 100644
--- a/src/include/optimizer/pathnode.h
+++ b/src/include/optimizer/pathnode.h
@@ -157,7 +157,7 @@ extern ParamPathInfo *get_joinrel_parampathinfo(PlannerInfo *root,
 						  List **restrict_clauses);
 extern ParamPathInfo *get_appendrel_parampathinfo(RelOptInfo *appendrel,
 							Relids required_outer);
-extern int get_join_memo_size(char *rel_names, int level);
-extern int get_baserel_memo_size(char *rel_name, int level);
+extern int get_join_memo_size(char *rel_names, int level, char *quals);
+extern int get_baserel_memo_size(char *rel_name, int level, int lclauses, char *quals);
 
 #endif   /* PATHNODE_H */
-- 
1.9.1

